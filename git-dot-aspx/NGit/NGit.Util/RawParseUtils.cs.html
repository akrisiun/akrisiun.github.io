<!DOCTYPE html>
<html><head><title>RawParseUtils.cs</title><link rel="stylesheet" href="../../styles.css"><script src="../../scripts.js"></script></head>
<body class="cB" onload="i(1266);"><div class="dH">
<table style="width: 100%">
<tr><td>File: <a id="filePath" class="blueLink" href="/#NGit/NGit.Util/RawParseUtils.cs" target="_top">NGit.Util\RawParseUtils.cs</a><br/></td><td></td></tr>
<tr><td>Project: <a id="projectPath" class="blueLink" href="/#NGit" target="_top">lib\NGit\NGit\NGit.csproj</a> (NGit)</td><td></td></tr>
</table>
</div>
<div class="cz"><table class="tb" cellpadding="0" cellspacing="0"><tr><td valign="top" align="right"><pre id="ln"></pre></td><td valign="top" align="left"><pre id="code">
<span class="c">/*
This code is derived from jgit (http://eclipse.org/jgit).
Copyright owners are documented in jgit&#39;s IP log.

This program and the accompanying materials are made available
under the terms of the Eclipse Distribution License v1.0 which
accompanies this distribution, is reproduced below, and is
available at http://www.eclipse.org/org/documents/edl-v10.php

All rights reserved.

Redistribution and use in source and binary forms, with or
without modification, are permitted provided that the following
conditions are met:

- Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

- Redistributions in binary form must reproduce the above
  copyright notice, this list of conditions and the following
  disclaimer in the documentation and/or other materials provided
  with the distribution.

- Neither the name of the Eclipse Foundation, Inc. nor the
  names of its contributors may be used to endorse or promote
  products derived from this software without specific prior
  written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND
CONTRIBUTORS &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES,
INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/</span>

<b>using</b> <span class="i n">System</span>;
<b>using</b> <span class="i n">System</span>.<span class="i n">Collections</span>.<span class="i n">Generic</span>;
<b>using</b> <span class="i n">System</span>.<span class="i n">Text</span>;
<b>using</b> <span class="i n">NGit</span>;
<b>using</b> <span class="i n">NGit</span>.<span class="i n">Util</span>;
<b>using</b> <span class="i n">Sharpen</span>;

<b>namespace</b> <span class="i n">NGit</span>.<span class="i n">Util</span>
{
	<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">summary</span><span class="c">&gt;</span><span class="c">Handy utility functions to parse raw object contents.</span><span class="c">&lt;/</span><span class="c">summary</span><span class="c">&gt;</span>
	<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">remarks</span><span class="c">&gt;</span><span class="c">Handy utility functions to parse raw object contents.</span><span class="c">&lt;/</span><span class="c">remarks</span><span class="c">&gt;</span>
	<b>public sealed class</b> <a id="f87abe4d24b03b12" href="../R/f87abe4d24b03b12.html" target="n" data-glyph="0,0" class="t t">RawParseUtils</a>
	{
		<b>private static readonly byte</b>[] <a id="506c247333a5d965" href="../R/506c247333a5d965.html" target="n" data-glyph="46,1" class="i field">digits10</a>;

		<b>private static readonly sbyte</b>[] <a id="25b86b6baf495515" href="../R/25b86b6baf495515.html" target="n" data-glyph="46,1" class="i field">digits16</a>;

		<b>private static readonly byte</b>[] <a id="b2b546f29e23fd15" href="../R/b2b546f29e23fd15.html" target="n" data-glyph="46,1" class="i field">footerLineKeyChars</a>;

		<b>private static readonly</b> <a href="@0@mscorlib/A.html#20343df0c96b629b" class="t t">IDictionary</a>&lt;<b>string</b>, <span class="i n">System</span>.<span class="i n">Text</span>.<a href="@0@mscorlib/A.html#3b6090c501893c25" class="t t">Encoding</a>&gt; <a id="ff411770f2744297" href="../R/ff411770f2744297.html" target="n" data-glyph="46,1" class="i field">encodingAliases</a>;

		<b>static</b> <a id="17761eb3a82c7eb0" href="../R/../../0000000000.html" target="n" data-glyph="76,1" class="i method">RawParseUtils</a>()
		{
			<a href="#ff411770f2744297" class="i field">encodingAliases</a> = <b>new</b> <a href="@0@mscorlib/A.html#bf6849e410b43c4c" class="t constructor">Dictionary</a>&lt;<b>string</b>, <span class="i n">System</span>.<span class="i n">Text</span>.<a href="@0@mscorlib/A.html#3b6090c501893c25" class="t t">Encoding</a>&gt;();
			<a href="#ff411770f2744297" class="i field">encodingAliases</a>.<a href="/Sharpen/A.html#a7c201171ab1d7de" class="i method">Put</a>(<span class="s">&quot;latin-1&quot;</span>, <span class="i n">Sharpen</span>.<a href="/Sharpen/A.html#229d48bbca3d4b45" class="t t">Extensions</a>.<a href="/Sharpen/A.html#fced17ebf6f54d8b" class="i method">GetEncoding</a>(<span class="s">&quot;ISO-8859-1&quot;</span>));
			<a href="#506c247333a5d965" class="i field">digits10</a> = <b>new</b> <b>byte</b>[(<b>byte</b>)(<span class="s">&#39;9&#39;</span>) + 1];
			<a href="/Sharpen/A.html#7342d8d23595dd8e" class="t t">Arrays</a>.<a href="/Sharpen/A.html#45c0598ff22dee88" class="i method">Fill</a>(<a href="#506c247333a5d965" class="i field">digits10</a>, <b>unchecked</b>((<b>byte</b>)-1));
			<b>for</b> (<b>char</b> <span id="r0 rd" class="r0 r">i</span> = <span class="s">&#39;0&#39;</span>; <span class="r0 r">i</span> &lt;= <span class="s">&#39;9&#39;</span>; <span class="r0 r">i</span>++)
			{
				<a href="#506c247333a5d965" class="i field">digits10</a>[<span class="r0 r">i</span>] = <b>unchecked</b>((<b>byte</b>)(<span class="r0 r">i</span> - (<b>byte</b>)(<span class="s">&#39;0&#39;</span>)));
			}
			<a href="#25b86b6baf495515" class="i field">digits16</a> = <b>new</b> <b>sbyte</b>[(<b>byte</b>)(<span class="s">&#39;f&#39;</span>) + 1];
			<a href="/Sharpen/A.html#7342d8d23595dd8e" class="t t">Arrays</a>.<a href="/Sharpen/A.html#45c0598ff22dee88" class="i method">Fill</a>(<a href="#25b86b6baf495515" class="i field">digits16</a>, (<b>sbyte</b>)-1);
			<b>for</b> (<b>char</b> <span id="r1 rd" class="r1 r">i_1</span> = <span class="s">&#39;0&#39;</span>; <span class="r1 r">i_1</span> &lt;= <span class="s">&#39;9&#39;</span>; <span class="r1 r">i_1</span>++)
			{
				<a href="#25b86b6baf495515" class="i field">digits16</a>[<span class="r1 r">i_1</span>] = (<b>sbyte</b>)(<span class="r1 r">i_1</span> - (<b>sbyte</b>)(<span class="s">&#39;0&#39;</span>));
			}
			<b>for</b> (<b>char</b> <span id="r2 rd" class="r2 r">i_2</span> = <span class="s">&#39;a&#39;</span>; <span class="r2 r">i_2</span> &lt;= <span class="s">&#39;f&#39;</span>; <span class="r2 r">i_2</span>++)
			{
				<a href="#25b86b6baf495515" class="i field">digits16</a>[<span class="r2 r">i_2</span>] = (<b>sbyte</b>)((<span class="r2 r">i_2</span> - (<b>sbyte</b>)(<span class="s">&#39;a&#39;</span>)) + 10);
			}
			<b>for</b> (<b>char</b> <span id="r3 rd" class="r3 r">i_3</span> = <span class="s">&#39;A&#39;</span>; <span class="r3 r">i_3</span> &lt;= <span class="s">&#39;F&#39;</span>; <span class="r3 r">i_3</span>++)
			{
				<a href="#25b86b6baf495515" class="i field">digits16</a>[<span class="r3 r">i_3</span>] = (<b>sbyte</b>)((<span class="r3 r">i_3</span> - (<b>sbyte</b>)(<span class="s">&#39;A&#39;</span>)) + 10);
			}
			<a href="#b2b546f29e23fd15" class="i field">footerLineKeyChars</a> = <b>new</b> <b>byte</b>[(<b>byte</b>)(<span class="s">&#39;z&#39;</span>) + 1];
			<a href="#b2b546f29e23fd15" class="i field">footerLineKeyChars</a>[(<b>byte</b>)(<span class="s">&#39;-&#39;</span>)] = 1;
			<b>for</b> (<b>char</b> <span id="r4 rd" class="r4 r">i_4</span> = <span class="s">&#39;0&#39;</span>; <span class="r4 r">i_4</span> &lt;= <span class="s">&#39;9&#39;</span>; <span class="r4 r">i_4</span>++)
			{
				<a href="#b2b546f29e23fd15" class="i field">footerLineKeyChars</a>[<span class="r4 r">i_4</span>] = 1;
			}
			<b>for</b> (<b>char</b> <span id="r5 rd" class="r5 r">i_5</span> = <span class="s">&#39;A&#39;</span>; <span class="r5 r">i_5</span> &lt;= <span class="s">&#39;Z&#39;</span>; <span class="r5 r">i_5</span>++)
			{
				<a href="#b2b546f29e23fd15" class="i field">footerLineKeyChars</a>[<span class="r5 r">i_5</span>] = 1;
			}
			<b>for</b> (<b>char</b> <span id="r6 rd" class="r6 r">i_6</span> = <span class="s">&#39;a&#39;</span>; <span class="r6 r">i_6</span> &lt;= <span class="s">&#39;z&#39;</span>; <span class="r6 r">i_6</span>++)
			{
				<a href="#b2b546f29e23fd15" class="i field">footerLineKeyChars</a>[<span class="r6 r">i_6</span>] = 1;
			}
		}

		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">summary</span><span class="c">&gt;</span><span class="c">Determine if b[ptr] matches src.</span><span class="c">&lt;/</span><span class="c">summary</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">remarks</span><span class="c">&gt;</span><span class="c">Determine if b[ptr] matches src.</span><span class="c">&lt;/</span><span class="c">remarks</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">param</span><span class="c"> </span><span class="c">name</span><span class="c">=</span><span class="c">&quot;</span><span class="r7 r">b</span><span class="c">&quot;</span><span class="c">&gt;</span><span class="c">the buffer to scan.</span><span class="c">&lt;/</span><span class="c">param</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">param</span><span class="c"> </span><span class="c">name</span><span class="c">=</span><span class="c">&quot;</span><span class="r8 r">ptr</span><span class="c">&quot;</span><span class="c">&gt;</span><span class="c">first position within b, this should match src[0].</span><span class="c">&lt;/</span><span class="c">param</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">param</span><span class="c"> </span><span class="c">name</span><span class="c">=</span><span class="c">&quot;</span><span class="r9 r">src</span><span class="c">&quot;</span><span class="c">&gt;</span><span class="c">the buffer to test for equality with b.</span><span class="c">&lt;/</span><span class="c">param</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">returns</span><span class="c">&gt;</span><span class="c">ptr + src.length if b[ptr..src.length] == src; else -1.</span><span class="c">&lt;/</span><span class="c">returns</span><span class="c">&gt;</span>
		<b>public static int</b> <a id="2e7e3c9c7c12e27d" href="../R/2e7e3c9c7c12e27d.html" target="n" data-glyph="72,1" class="i method">Match</a>(<b>byte</b>[] <span id="r7 rd" class="r7 r">b</span>, <b>int</b> <span id="r8 rd" class="r8 r">ptr</span>, <b>byte</b>[] <span id="r9 rd" class="r9 r">src</span>)
		{
			<b>if</b> (<span class="r8 r">ptr</span> + <span class="r9 r">src</span>.<a href="@0@mscorlib/A.html#42e9b7616956cf94" class="i property">Length</a> &gt; <span class="r7 r">b</span>.<a href="@0@mscorlib/A.html#42e9b7616956cf94" class="i property">Length</a>)
			{
				<b>return</b> -1;
			}
			<b>for</b> (<b>int</b> <span id="r10 rd" class="r10 r">i</span> = 0; <span class="r10 r">i</span> &lt; <span class="r9 r">src</span>.<a href="@0@mscorlib/A.html#42e9b7616956cf94" class="i property">Length</a>; <span class="r10 r">i</span>++, <span class="r8 r">ptr</span>++)
			{
				<b>if</b> (<span class="r7 r">b</span>[<span class="r8 r">ptr</span>] != <span class="r9 r">src</span>[<span class="r10 r">i</span>])
				{
					<b>return</b> -1;
				}
			}
			<b>return</b> <span class="r8 r">ptr</span>;
		}

		<b>private static readonly byte</b>[] <a id="c9381c70beba18f2" href="../R/c9381c70beba18f2.html" target="n" data-glyph="46,1" class="i field">base10byte</a> = <b>new</b> <b>byte</b>[] { (<b>byte</b>)(<span class="s">&#39;0&#39;</span>), (<b>byte</b>)(<span class="s">&#39;1&#39;</span>)
			, (<b>byte</b>)(<span class="s">&#39;2&#39;</span>), (<b>byte</b>)(<span class="s">&#39;3&#39;</span>), (<b>byte</b>)(<span class="s">&#39;4&#39;</span>), (<b>byte</b>)(<span class="s">&#39;5&#39;</span>), (<b>byte</b>)(<span class="s">&#39;6&#39;</span>), (<b>byte</b>)(<span class="s">&#39;7&#39;</span>), 
			(<b>byte</b>)(<span class="s">&#39;8&#39;</span>), (<b>byte</b>)(<span class="s">&#39;9&#39;</span>) };

		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">summary</span><span class="c">&gt;</span><span class="c">Format a base 10 numeric into a temporary buffer.</span><span class="c">&lt;/</span><span class="c">summary</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">remarks</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> Format a base 10 numeric into a temporary buffer.</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">p</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> Formatting is performed backwards. The method starts at offset</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">code</span><span class="c">&gt;</span><span class="c">o-1</span><span class="c">&lt;/</span><span class="c">code</span><span class="c">&gt;</span><span class="c"> and ends at </span><span class="c">&lt;</span><span class="c">code</span><span class="c">&gt;</span><span class="c">o-1-digits</span><span class="c">&lt;/</span><span class="c">code</span><span class="c">&gt;</span><span class="c">, where</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">code</span><span class="c">&gt;</span><span class="c">digits</span><span class="c">&lt;/</span><span class="c">code</span><span class="c">&gt;</span><span class="c"> is the number of positions necessary to store the</span>
		<span class="c">///</span><span class="c"> base 10 value.</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">p</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> The argument and return values from this method make it easy to chain</span>
		<span class="c">///</span><span class="c"> writing, for example:</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;/</span><span class="c">p</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">pre</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> final byte[] tmp = new byte[64];</span>
		<span class="c">///</span><span class="c"> int ptr = tmp.length;</span>
		<span class="c">///</span><span class="c"> tmp[--ptr] = &#39;\n&#39;;</span>
		<span class="c">///</span><span class="c"> ptr = RawParseUtils.formatBase10(tmp, ptr, 32);</span>
		<span class="c">///</span><span class="c"> tmp[--ptr] = &#39; &#39;;</span>
		<span class="c">///</span><span class="c"> ptr = RawParseUtils.formatBase10(tmp, ptr, 18);</span>
		<span class="c">///</span><span class="c"> tmp[--ptr] = 0;</span>
		<span class="c">///</span><span class="c"> final String str = new String(tmp, ptr, tmp.length - ptr);</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;/</span><span class="c">pre</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;/</span><span class="c">remarks</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">param</span><span class="c"> </span><span class="c">name</span><span class="c">=</span><span class="c">&quot;</span><span class="r11 r">b</span><span class="c">&quot;</span><span class="c">&gt;</span><span class="c">buffer to write into.</span><span class="c">&lt;/</span><span class="c">param</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">param</span><span class="c"> </span><span class="c">name</span><span class="c">=</span><span class="c">&quot;</span><span class="r12 r">o</span><span class="c">&quot;</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> one offset past the location where writing will begin; writing</span>
		<span class="c">///</span><span class="c"> proceeds towards lower index values.</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;/</span><span class="c">param</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">param</span><span class="c"> </span><span class="c">name</span><span class="c">=</span><span class="c">&quot;</span><span class="r13 r">value</span><span class="c">&quot;</span><span class="c">&gt;</span><span class="c">the value to store.</span><span class="c">&lt;/</span><span class="c">param</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">returns</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> the new offset value </span><span class="c">&lt;</span><span class="c">code</span><span class="c">&gt;</span><span class="c">o</span><span class="c">&lt;/</span><span class="c">code</span><span class="c">&gt;</span><span class="c">. This is the position of</span>
		<span class="c">///</span><span class="c"> the last byte written. Additional writing should start at one</span>
		<span class="c">///</span><span class="c"> position earlier.</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;/</span><span class="c">returns</span><span class="c">&gt;</span>
		<b>public static int</b> <a id="963f6760a7213d52" href="../R/963f6760a7213d52.html" target="n" data-glyph="72,1" class="i method">FormatBase10</a>(<b>byte</b>[] <span id="r11 rd" class="r11 r">b</span>, <b>int</b> <span id="r12 rd" class="r12 r">o</span>, <b>int</b> <span id="r13 rd" class="r13 r">value</span>)
		{
			<b>if</b> (<span class="r13 r">value</span> == 0)
			{
				<span class="r11 r">b</span>[--<span class="r12 r">o</span>] = (<b>byte</b>)(<span class="s">&#39;0&#39;</span>);
				<b>return</b> <span class="r12 r">o</span>;
			}
			<b>bool</b> <span id="r14 rd" class="r14 r">isneg</span> = <span class="r13 r">value</span> &lt; 0;
			<b>if</b> (<span class="r14 r">isneg</span>)
			{
				<span class="r13 r">value</span> = -<span class="r13 r">value</span>;
			}
			<b>while</b> (<span class="r13 r">value</span> != 0)
			{
				<span class="r11 r">b</span>[--<span class="r12 r">o</span>] = <a href="#c9381c70beba18f2" class="i field">base10byte</a>[<span class="r13 r">value</span> % 10];
				<span class="r13 r">value</span> /= 10;
			}
			<b>if</b> (<span class="r14 r">isneg</span>)
			{
				<span class="r11 r">b</span>[--<span class="r12 r">o</span>] = (<b>byte</b>)(<span class="s">&#39;-&#39;</span>);
			}
			<b>return</b> <span class="r12 r">o</span>;
		}

		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">summary</span><span class="c">&gt;</span><span class="c">Parse a base 10 numeric from a sequence of ASCII digits into an int.</span><span class="c">&lt;/</span><span class="c">summary</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">remarks</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> Parse a base 10 numeric from a sequence of ASCII digits into an int.</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">p</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> Digit sequences can begin with an optional run of spaces before the</span>
		<span class="c">///</span><span class="c"> sequence, and may start with a &#39;+&#39; or a &#39;-&#39; to indicate sign position.</span>
		<span class="c">///</span><span class="c"> Any other characters will cause the method to stop and return the current</span>
		<span class="c">///</span><span class="c"> result to the caller.</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;/</span><span class="c">remarks</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">param</span><span class="c"> </span><span class="c">name</span><span class="c">=</span><span class="c">&quot;</span><span class="r15 r">b</span><span class="c">&quot;</span><span class="c">&gt;</span><span class="c">buffer to scan.</span><span class="c">&lt;/</span><span class="c">param</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">param</span><span class="c"> </span><span class="c">name</span><span class="c">=</span><span class="c">&quot;</span><span class="r16 r">ptr</span><span class="c">&quot;</span><span class="c">&gt;</span><span class="c">position within buffer to start parsing digits at.</span><span class="c">&lt;/</span><span class="c">param</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">param</span><span class="c"> </span><span class="c">name</span><span class="c">=</span><span class="c">&quot;</span><span class="r17 r">ptrResult</span><span class="c">&quot;</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> optional location to return the new ptr value through. If null</span>
		<span class="c">///</span><span class="c"> the ptr value will be discarded.</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;/</span><span class="c">param</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">returns</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> the value at this location; 0 if the location is not a valid</span>
		<span class="c">///</span><span class="c"> numeric.</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;/</span><span class="c">returns</span><span class="c">&gt;</span>
		<b>public static int</b> <a id="2555a55f548438db" href="../R/2555a55f548438db.html" target="n" data-glyph="72,1" class="i method">ParseBase10</a>(<b>byte</b>[] <span id="r15 rd" class="r15 r">b</span>, <b>int</b> <span id="r16 rd" class="r16 r">ptr</span>, <a href="MutableInteger.cs.html#66f1edb633e848e3" class="t t">MutableInteger</a> <span id="r17 rd" class="r17 r">ptrResult</span>)
		{
			<b>int</b> <span id="r18 rd" class="r18 r">r</span> = 0;
			<b>int</b> <span id="r19 rd" class="r19 r">sign</span> = 0;
			<b>try</b>
			{
				<b>int</b> <span id="r20 rd" class="r20 r">sz</span> = <span class="r15 r">b</span>.<a href="@0@mscorlib/A.html#42e9b7616956cf94" class="i property">Length</a>;
				<b>while</b> (<span class="r16 r">ptr</span> &lt; <span class="r20 r">sz</span> &amp;&amp; <span class="r15 r">b</span>[<span class="r16 r">ptr</span>] == <span class="s">&#39; &#39;</span>)
				{
					<span class="r16 r">ptr</span>++;
				}
				<b>if</b> (<span class="r16 r">ptr</span> &gt;= <span class="r20 r">sz</span>)
				{
					<b>return</b> 0;
				}
				<b>switch</b> (<span class="r15 r">b</span>[<span class="r16 r">ptr</span>])
				{
					<b>case</b> (<b>byte</b>)(<span class="s">&#39;-&#39;</span>):
					{
						<span class="r19 r">sign</span> = -1;
						<span class="r16 r">ptr</span>++;
						<b>break</b>;
					}

					<b>case</b> (<b>byte</b>)(<span class="s">&#39;+&#39;</span>):
					{
						<span class="r16 r">ptr</span>++;
						<b>break</b>;
					}
				}
				<b>while</b> (<span class="r16 r">ptr</span> &lt; <span class="r20 r">sz</span>)
				{
					<b>byte</b> <span id="r21 rd" class="r21 r">v</span> = <a href="#506c247333a5d965" class="i field">digits10</a>[<span class="r15 r">b</span>[<span class="r16 r">ptr</span>]];
					<b>if</b> (((<b>sbyte</b>)<span class="r21 r">v</span>) &lt; 0)
					{
						<b>break</b>;
					}
					<span class="r18 r">r</span> = (<span class="r18 r">r</span> * 10) + <span class="r21 r">v</span>;
					<span class="r16 r">ptr</span>++;
				}
			}
			<b>catch</b> (<a href="@0@mscorlib/A.html#acba961d918b2408" class="t t">IndexOutOfRangeException</a>)
			{
			}
			<span class="c">// Not a valid digit.</span>
			<b>if</b> (<span class="r17 r">ptrResult</span> != <b>null</b>)
			{
				<span class="r17 r">ptrResult</span>.<a href="MutableInteger.cs.html#b6e5bddb557534b1" class="i field">value</a> = <span class="r16 r">ptr</span>;
			}
			<b>return</b> <span class="r19 r">sign</span> &lt; 0 ? -<span class="r18 r">r</span> : <span class="r18 r">r</span>;
		}

		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">summary</span><span class="c">&gt;</span><span class="c">Parse a base 10 numeric from a sequence of ASCII digits into a long.</span><span class="c">&lt;/</span><span class="c">summary</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">remarks</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> Parse a base 10 numeric from a sequence of ASCII digits into a long.</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">p</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> Digit sequences can begin with an optional run of spaces before the</span>
		<span class="c">///</span><span class="c"> sequence, and may start with a &#39;+&#39; or a &#39;-&#39; to indicate sign position.</span>
		<span class="c">///</span><span class="c"> Any other characters will cause the method to stop and return the current</span>
		<span class="c">///</span><span class="c"> result to the caller.</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;/</span><span class="c">remarks</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">param</span><span class="c"> </span><span class="c">name</span><span class="c">=</span><span class="c">&quot;</span><span class="r22 r">b</span><span class="c">&quot;</span><span class="c">&gt;</span><span class="c">buffer to scan.</span><span class="c">&lt;/</span><span class="c">param</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">param</span><span class="c"> </span><span class="c">name</span><span class="c">=</span><span class="c">&quot;</span><span class="r23 r">ptr</span><span class="c">&quot;</span><span class="c">&gt;</span><span class="c">position within buffer to start parsing digits at.</span><span class="c">&lt;/</span><span class="c">param</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">param</span><span class="c"> </span><span class="c">name</span><span class="c">=</span><span class="c">&quot;</span><span class="r24 r">ptrResult</span><span class="c">&quot;</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> optional location to return the new ptr value through. If null</span>
		<span class="c">///</span><span class="c"> the ptr value will be discarded.</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;/</span><span class="c">param</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">returns</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> the value at this location; 0 if the location is not a valid</span>
		<span class="c">///</span><span class="c"> numeric.</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;/</span><span class="c">returns</span><span class="c">&gt;</span>
		<b>public static long</b> <a id="e66132e4054e1848" href="../R/e66132e4054e1848.html" target="n" data-glyph="72,1" class="i method">ParseLongBase10</a>(<b>byte</b>[] <span id="r22 rd" class="r22 r">b</span>, <b>int</b> <span id="r23 rd" class="r23 r">ptr</span>, <a href="MutableInteger.cs.html#66f1edb633e848e3" class="t t">MutableInteger</a> <span id="r24 rd" class="r24 r">ptrResult</span>)
		{
			<b>long</b> <span id="r25 rd" class="r25 r">r</span> = 0;
			<b>int</b> <span id="r26 rd" class="r26 r">sign</span> = 0;
			<b>try</b>
			{
				<b>int</b> <span id="r27 rd" class="r27 r">sz</span> = <span class="r22 r">b</span>.<a href="@0@mscorlib/A.html#42e9b7616956cf94" class="i property">Length</a>;
				<b>while</b> (<span class="r23 r">ptr</span> &lt; <span class="r27 r">sz</span> &amp;&amp; <span class="r22 r">b</span>[<span class="r23 r">ptr</span>] == <span class="s">&#39; &#39;</span>)
				{
					<span class="r23 r">ptr</span>++;
				}
				<b>if</b> (<span class="r23 r">ptr</span> &gt;= <span class="r27 r">sz</span>)
				{
					<b>return</b> 0;
				}
				<b>switch</b> (<span class="r22 r">b</span>[<span class="r23 r">ptr</span>])
				{
					<b>case</b> (<b>byte</b>)(<span class="s">&#39;-&#39;</span>):
					{
						<span class="r26 r">sign</span> = -1;
						<span class="r23 r">ptr</span>++;
						<b>break</b>;
					}

					<b>case</b> (<b>byte</b>)(<span class="s">&#39;+&#39;</span>):
					{
						<span class="r23 r">ptr</span>++;
						<b>break</b>;
					}
				}
				<b>while</b> (<span class="r23 r">ptr</span> &lt; <span class="r27 r">sz</span>)
				{
					<b>byte</b> <span id="r28 rd" class="r28 r">v</span> = <a href="#506c247333a5d965" class="i field">digits10</a>[<span class="r22 r">b</span>[<span class="r23 r">ptr</span>]];
					<b>if</b> (((<b>sbyte</b>)<span class="r28 r">v</span>) &lt; 0)
					{
						<b>break</b>;
					}
					<span class="r25 r">r</span> = (<span class="r25 r">r</span> * 10) + <span class="r28 r">v</span>;
					<span class="r23 r">ptr</span>++;
				}
			}
			<b>catch</b> (<a href="@0@mscorlib/A.html#acba961d918b2408" class="t t">IndexOutOfRangeException</a>)
			{
			}
			<span class="c">// Not a valid digit.</span>
			<b>if</b> (<span class="r24 r">ptrResult</span> != <b>null</b>)
			{
				<span class="r24 r">ptrResult</span>.<a href="MutableInteger.cs.html#b6e5bddb557534b1" class="i field">value</a> = <span class="r23 r">ptr</span>;
			}
			<b>return</b> <span class="r26 r">sign</span> &lt; 0 ? -<span class="r25 r">r</span> : <span class="r25 r">r</span>;
		}

		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">summary</span><span class="c">&gt;</span><span class="c">Parse 4 character base 16 (hex) formatted string to unsigned integer.</span><span class="c">&lt;/</span><span class="c">summary</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">remarks</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> Parse 4 character base 16 (hex) formatted string to unsigned integer.</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">p</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> The number is read in network byte order, that is, most significant</span>
		<span class="c">///</span><span class="c"> nybble first.</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;/</span><span class="c">remarks</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">param</span><span class="c"> </span><span class="c">name</span><span class="c">=</span><span class="c">&quot;</span><span class="r29 r">bs</span><span class="c">&quot;</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> buffer to parse digits from; positions</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">code</span><span class="c">&gt;</span><span class="c">[p, p+4)</span><span class="c">&lt;/</span><span class="c">code</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> will</span>
		<span class="c">///</span><span class="c"> be parsed.</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;/</span><span class="c">param</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">param</span><span class="c"> </span><span class="c">name</span><span class="c">=</span><span class="c">&quot;</span><span class="r30 r">p</span><span class="c">&quot;</span><span class="c">&gt;</span><span class="c">first position within the buffer to parse.</span><span class="c">&lt;/</span><span class="c">param</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">returns</span><span class="c">&gt;</span><span class="c">the integer value.</span><span class="c">&lt;/</span><span class="c">returns</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">exception</span><span class="c"> </span><span class="c">cref</span><span class="c">=</span><span class="c">&quot;</span><span class="i n">System</span>.<a href="@0@mscorlib/A.html#acba961d918b2408" class="t t">IndexOutOfRangeException</a><span class="c">&quot;</span><span class="c">&gt;</span><span class="c">if the string is not hex formatted.</span>
		<span class="c">///</span><span class="c"> 	</span><span class="c">&lt;/</span><span class="c">exception</span><span class="c">&gt;</span>
		<b>public static int</b> <a id="a2a4a9f802c29900" href="../R/a2a4a9f802c29900.html" target="n" data-glyph="72,1" class="i method">ParseHexInt16</a>(<b>byte</b>[] <span id="r29 rd" class="r29 r">bs</span>, <b>int</b> <span id="r30 rd" class="r30 r">p</span>)
		{
			<b>int</b> <span id="r31 rd" class="r31 r">r</span> = <a href="#25b86b6baf495515" class="i field">digits16</a>[<span class="r29 r">bs</span>[<span class="r30 r">p</span>]] &lt;&lt; 4;
			<span class="r31 r">r</span> |= <a href="#25b86b6baf495515" class="i field">digits16</a>[<span class="r29 r">bs</span>[<span class="r30 r">p</span> + 1]];
			<span class="r31 r">r</span> &lt;&lt;= 4;
			<span class="r31 r">r</span> |= <a href="#25b86b6baf495515" class="i field">digits16</a>[<span class="r29 r">bs</span>[<span class="r30 r">p</span> + 2]];
			<span class="r31 r">r</span> &lt;&lt;= 4;
			<span class="r31 r">r</span> |= <a href="#25b86b6baf495515" class="i field">digits16</a>[<span class="r29 r">bs</span>[<span class="r30 r">p</span> + 3]];
			<b>if</b> (<span class="r31 r">r</span> &lt; 0)
			{
				<b>throw</b> <b>new</b> <a href="@0@mscorlib/A.html#b9c8ef7b0f7b8fbc" class="t constructor">IndexOutOfRangeException</a>();
			}
			<b>return</b> <span class="r31 r">r</span>;
		}

		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">summary</span><span class="c">&gt;</span><span class="c">Parse 8 character base 16 (hex) formatted string to unsigned integer.</span><span class="c">&lt;/</span><span class="c">summary</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">remarks</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> Parse 8 character base 16 (hex) formatted string to unsigned integer.</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">p</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> The number is read in network byte order, that is, most significant</span>
		<span class="c">///</span><span class="c"> nybble first.</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;/</span><span class="c">remarks</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">param</span><span class="c"> </span><span class="c">name</span><span class="c">=</span><span class="c">&quot;</span><span class="r32 r">bs</span><span class="c">&quot;</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> buffer to parse digits from; positions</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">code</span><span class="c">&gt;</span><span class="c">[p, p+8)</span><span class="c">&lt;/</span><span class="c">code</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> will</span>
		<span class="c">///</span><span class="c"> be parsed.</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;/</span><span class="c">param</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">param</span><span class="c"> </span><span class="c">name</span><span class="c">=</span><span class="c">&quot;</span><span class="r33 r">p</span><span class="c">&quot;</span><span class="c">&gt;</span><span class="c">first position within the buffer to parse.</span><span class="c">&lt;/</span><span class="c">param</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">returns</span><span class="c">&gt;</span><span class="c">the integer value.</span><span class="c">&lt;/</span><span class="c">returns</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">exception</span><span class="c"> </span><span class="c">cref</span><span class="c">=</span><span class="c">&quot;</span><span class="i n">System</span>.<a href="@0@mscorlib/A.html#acba961d918b2408" class="t t">IndexOutOfRangeException</a><span class="c">&quot;</span><span class="c">&gt;</span><span class="c">if the string is not hex formatted.</span>
		<span class="c">///</span><span class="c"> 	</span><span class="c">&lt;/</span><span class="c">exception</span><span class="c">&gt;</span>
		<b>public static int</b> <a id="ff7cd25a9f5942b7" href="../R/ff7cd25a9f5942b7.html" target="n" data-glyph="72,1" class="i method">ParseHexInt32</a>(<b>byte</b>[] <span id="r32 rd" class="r32 r">bs</span>, <b>int</b> <span id="r33 rd" class="r33 r">p</span>)
		{
			<b>int</b> <span id="r34 rd" class="r34 r">r</span> = <a href="#25b86b6baf495515" class="i field">digits16</a>[<span class="r32 r">bs</span>[<span class="r33 r">p</span>]] &lt;&lt; 4;
			<span class="r34 r">r</span> |= <a href="#25b86b6baf495515" class="i field">digits16</a>[<span class="r32 r">bs</span>[<span class="r33 r">p</span> + 1]];
			<span class="r34 r">r</span> &lt;&lt;= 4;
			<span class="r34 r">r</span> |= <a href="#25b86b6baf495515" class="i field">digits16</a>[<span class="r32 r">bs</span>[<span class="r33 r">p</span> + 2]];
			<span class="r34 r">r</span> &lt;&lt;= 4;
			<span class="r34 r">r</span> |= <a href="#25b86b6baf495515" class="i field">digits16</a>[<span class="r32 r">bs</span>[<span class="r33 r">p</span> + 3]];
			<span class="r34 r">r</span> &lt;&lt;= 4;
			<span class="r34 r">r</span> |= <a href="#25b86b6baf495515" class="i field">digits16</a>[<span class="r32 r">bs</span>[<span class="r33 r">p</span> + 4]];
			<span class="r34 r">r</span> &lt;&lt;= 4;
			<span class="r34 r">r</span> |= <a href="#25b86b6baf495515" class="i field">digits16</a>[<span class="r32 r">bs</span>[<span class="r33 r">p</span> + 5]];
			<span class="r34 r">r</span> &lt;&lt;= 4;
			<span class="r34 r">r</span> |= <a href="#25b86b6baf495515" class="i field">digits16</a>[<span class="r32 r">bs</span>[<span class="r33 r">p</span> + 6]];
			<b>int</b> <span id="r35 rd" class="r35 r">last</span> = <a href="#25b86b6baf495515" class="i field">digits16</a>[<span class="r32 r">bs</span>[<span class="r33 r">p</span> + 7]];
			<b>if</b> (<span class="r34 r">r</span> &lt; 0 || <span class="r35 r">last</span> &lt; 0)
			{
				<b>throw</b> <b>new</b> <a href="@0@mscorlib/A.html#b9c8ef7b0f7b8fbc" class="t constructor">IndexOutOfRangeException</a>();
			}
			<b>return</b> (<span class="r34 r">r</span> &lt;&lt; 4) | <span class="r35 r">last</span>;
		}

		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">summary</span><span class="c">&gt;</span><span class="c">Parse a single hex digit to its numeric value (0-15).</span><span class="c">&lt;/</span><span class="c">summary</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">remarks</span><span class="c">&gt;</span><span class="c">Parse a single hex digit to its numeric value (0-15).</span><span class="c">&lt;/</span><span class="c">remarks</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">param</span><span class="c"> </span><span class="c">name</span><span class="c">=</span><span class="c">&quot;</span><span class="r36 r">digit</span><span class="c">&quot;</span><span class="c">&gt;</span><span class="c">hex character to parse.</span><span class="c">&lt;/</span><span class="c">param</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">returns</span><span class="c">&gt;</span><span class="c">numeric value, in the range 0-15.</span><span class="c">&lt;/</span><span class="c">returns</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">exception</span><span class="c"> </span><span class="c">cref</span><span class="c">=</span><span class="c">&quot;</span><span class="i n">System</span>.<a href="@0@mscorlib/A.html#acba961d918b2408" class="t t">IndexOutOfRangeException</a><span class="c">&quot;</span><span class="c">&gt;</span><span class="c">if the input digit is not a valid hex digit.</span>
		<span class="c">///</span><span class="c"> 	</span><span class="c">&lt;/</span><span class="c">exception</span><span class="c">&gt;</span>
		<b>public static int</b> <a id="ec1a4227d2cfe658" href="../R/ec1a4227d2cfe658.html" target="n" data-glyph="72,1" class="i method">ParseHexInt4</a>(<b>byte</b> <span id="r36 rd" class="r36 r">digit</span>)
		{
			<b>sbyte</b> <span id="r37 rd" class="r37 r">r</span> = <a href="#25b86b6baf495515" class="i field">digits16</a>[<span class="r36 r">digit</span>];
			<b>if</b> (<span class="r37 r">r</span> &lt; 0)
			{
				<b>throw</b> <b>new</b> <a href="@0@mscorlib/A.html#b9c8ef7b0f7b8fbc" class="t constructor">IndexOutOfRangeException</a>();
			}
			<b>return</b> <span class="r37 r">r</span>;
		}

		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">summary</span><span class="c">&gt;</span><span class="c">Parse a Git style timezone string.</span><span class="c">&lt;/</span><span class="c">summary</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">remarks</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> Parse a Git style timezone string.</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">p</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> The sequence &quot;-0315&quot; will be parsed as the numeric value -195, as the</span>
		<span class="c">///</span><span class="c"> lower two positions count minutes, not 100ths of an hour.</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;/</span><span class="c">remarks</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">param</span><span class="c"> </span><span class="c">name</span><span class="c">=</span><span class="c">&quot;</span><span class="r38 r">b</span><span class="c">&quot;</span><span class="c">&gt;</span><span class="c">buffer to scan.</span><span class="c">&lt;/</span><span class="c">param</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">param</span><span class="c"> </span><span class="c">name</span><span class="c">=</span><span class="c">&quot;</span><span class="r39 r">ptr</span><span class="c">&quot;</span><span class="c">&gt;</span><span class="c">position within buffer to start parsing digits at.</span><span class="c">&lt;/</span><span class="c">param</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">returns</span><span class="c">&gt;</span><span class="c">the timezone at this location, expressed in minutes.</span><span class="c">&lt;/</span><span class="c">returns</span><span class="c">&gt;</span>
		<b>public static int</b> <a id="8738fc151f575ad0" href="../R/8738fc151f575ad0.html" target="n" data-glyph="72,1" class="i method">ParseTimeZoneOffset</a>(<b>byte</b>[] <span id="r38 rd" class="r38 r">b</span>, <b>int</b> <span id="r39 rd" class="r39 r">ptr</span>)
		{
			<b>int</b> <span id="r40 rd" class="r40 r">v</span> = <a href="#2555a55f548438db" class="i method">ParseBase10</a>(<span class="r38 r">b</span>, <span class="r39 r">ptr</span>, <b>null</b>);
			<b>int</b> <span id="r41 rd" class="r41 r">tzMins</span> = <span class="r40 r">v</span> % 100;
			<b>int</b> <span id="r42 rd" class="r42 r">tzHours</span> = <span class="r40 r">v</span> / 100;
			<b>return</b> <span class="r42 r">tzHours</span> * 60 + <span class="r41 r">tzMins</span>;
		}

		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">summary</span><span class="c">&gt;</span><span class="c">Locate the first position after a given character.</span><span class="c">&lt;/</span><span class="c">summary</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">remarks</span><span class="c">&gt;</span><span class="c">Locate the first position after a given character.</span><span class="c">&lt;/</span><span class="c">remarks</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">param</span><span class="c"> </span><span class="c">name</span><span class="c">=</span><span class="c">&quot;</span><span class="r43 r">b</span><span class="c">&quot;</span><span class="c">&gt;</span><span class="c">buffer to scan.</span><span class="c">&lt;/</span><span class="c">param</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">param</span><span class="c"> </span><span class="c">name</span><span class="c">=</span><span class="c">&quot;</span><span class="r44 r">ptr</span><span class="c">&quot;</span><span class="c">&gt;</span><span class="c">position within buffer to start looking for chrA at.</span><span class="c">&lt;/</span><span class="c">param</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">param</span><span class="c"> </span><span class="c">name</span><span class="c">=</span><span class="c">&quot;</span><span class="r45 r">chrA</span><span class="c">&quot;</span><span class="c">&gt;</span><span class="c">character to find.</span><span class="c">&lt;/</span><span class="c">param</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">returns</span><span class="c">&gt;</span><span class="c">new position just after chrA.</span><span class="c">&lt;/</span><span class="c">returns</span><span class="c">&gt;</span>
		<b>public static int</b> <a id="1532c916b30cbb08" href="../R/1532c916b30cbb08.html" target="n" data-glyph="72,1" class="i method">Next</a>(<b>byte</b>[] <span id="r43 rd" class="r43 r">b</span>, <b>int</b> <span id="r44 rd" class="r44 r">ptr</span>, <b>char</b> <span id="r45 rd" class="r45 r">chrA</span>)
		{
			<b>int</b> <span id="r46 rd" class="r46 r">sz</span> = <span class="r43 r">b</span>.<a href="@0@mscorlib/A.html#42e9b7616956cf94" class="i property">Length</a>;
			<b>while</b> (<span class="r44 r">ptr</span> &lt; <span class="r46 r">sz</span>)
			{
				<b>if</b> (<span class="r43 r">b</span>[<span class="r44 r">ptr</span>++] == <span class="r45 r">chrA</span>)
				{
					<b>return</b> <span class="r44 r">ptr</span>;
				}
			}
			<b>return</b> <span class="r44 r">ptr</span>;
		}

		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">summary</span><span class="c">&gt;</span><span class="c">Locate the first position after the next LF.</span><span class="c">&lt;/</span><span class="c">summary</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">remarks</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> Locate the first position after the next LF.</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">p</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> This method stops on the first &#39;\n&#39; it finds.</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;/</span><span class="c">remarks</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">param</span><span class="c"> </span><span class="c">name</span><span class="c">=</span><span class="c">&quot;</span><span class="r47 r">b</span><span class="c">&quot;</span><span class="c">&gt;</span><span class="c">buffer to scan.</span><span class="c">&lt;/</span><span class="c">param</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">param</span><span class="c"> </span><span class="c">name</span><span class="c">=</span><span class="c">&quot;</span><span class="r48 r">ptr</span><span class="c">&quot;</span><span class="c">&gt;</span><span class="c">position within buffer to start looking for LF at.</span><span class="c">&lt;/</span><span class="c">param</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">returns</span><span class="c">&gt;</span><span class="c">new position just after the first LF found.</span><span class="c">&lt;/</span><span class="c">returns</span><span class="c">&gt;</span>
		<b>public static int</b> <a id="162ee2e46b60d416" href="../R/162ee2e46b60d416.html" target="n" data-glyph="72,1" class="i method">NextLF</a>(<b>byte</b>[] <span id="r47 rd" class="r47 r">b</span>, <b>int</b> <span id="r48 rd" class="r48 r">ptr</span>)
		{
			<b>return</b> <a href="#1532c916b30cbb08" class="i method">Next</a>(<span class="r47 r">b</span>, <span class="r48 r">ptr</span>, <span class="s">&#39;\n&#39;</span>);
		}

		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">summary</span><span class="c">&gt;</span><span class="c">Locate the first position after either the given character or LF.</span><span class="c">&lt;/</span><span class="c">summary</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">remarks</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> Locate the first position after either the given character or LF.</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">p</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> This method stops on the first match it finds from either chrA or &#39;\n&#39;.</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;/</span><span class="c">remarks</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">param</span><span class="c"> </span><span class="c">name</span><span class="c">=</span><span class="c">&quot;</span><span class="r49 r">b</span><span class="c">&quot;</span><span class="c">&gt;</span><span class="c">buffer to scan.</span><span class="c">&lt;/</span><span class="c">param</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">param</span><span class="c"> </span><span class="c">name</span><span class="c">=</span><span class="c">&quot;</span><span class="r50 r">ptr</span><span class="c">&quot;</span><span class="c">&gt;</span><span class="c">position within buffer to start looking for chrA or LF at.</span><span class="c">&lt;/</span><span class="c">param</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">param</span><span class="c"> </span><span class="c">name</span><span class="c">=</span><span class="c">&quot;</span><span class="r51 r">chrA</span><span class="c">&quot;</span><span class="c">&gt;</span><span class="c">character to find.</span><span class="c">&lt;/</span><span class="c">param</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">returns</span><span class="c">&gt;</span><span class="c">new position just after the first chrA or LF to be found.</span><span class="c">&lt;/</span><span class="c">returns</span><span class="c">&gt;</span>
		<b>public static int</b> <a id="8b1df44ee0b6ff07" href="../R/8b1df44ee0b6ff07.html" target="n" data-glyph="72,1" class="i method">NextLF</a>(<b>byte</b>[] <span id="r49 rd" class="r49 r">b</span>, <b>int</b> <span id="r50 rd" class="r50 r">ptr</span>, <b>char</b> <span id="r51 rd" class="r51 r">chrA</span>)
		{
			<b>int</b> <span id="r52 rd" class="r52 r">sz</span> = <span class="r49 r">b</span>.<a href="@0@mscorlib/A.html#42e9b7616956cf94" class="i property">Length</a>;
			<b>while</b> (<span class="r50 r">ptr</span> &lt; <span class="r52 r">sz</span>)
			{
				<b>byte</b> <span id="r53 rd" class="r53 r">c</span> = <span class="r49 r">b</span>[<span class="r50 r">ptr</span>++];
				<b>if</b> (<span class="r53 r">c</span> == <span class="r51 r">chrA</span> || <span class="r53 r">c</span> == <span class="s">&#39;\n&#39;</span>)
				{
					<b>return</b> <span class="r50 r">ptr</span>;
				}
			}
			<b>return</b> <span class="r50 r">ptr</span>;
		}

		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">summary</span><span class="c">&gt;</span><span class="c">Locate the first position before a given character.</span><span class="c">&lt;/</span><span class="c">summary</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">remarks</span><span class="c">&gt;</span><span class="c">Locate the first position before a given character.</span><span class="c">&lt;/</span><span class="c">remarks</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">param</span><span class="c"> </span><span class="c">name</span><span class="c">=</span><span class="c">&quot;</span><span class="r54 r">b</span><span class="c">&quot;</span><span class="c">&gt;</span><span class="c">buffer to scan.</span><span class="c">&lt;/</span><span class="c">param</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">param</span><span class="c"> </span><span class="c">name</span><span class="c">=</span><span class="c">&quot;</span><span class="r55 r">ptr</span><span class="c">&quot;</span><span class="c">&gt;</span><span class="c">position within buffer to start looking for chrA at.</span><span class="c">&lt;/</span><span class="c">param</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">param</span><span class="c"> </span><span class="c">name</span><span class="c">=</span><span class="c">&quot;</span><span class="r56 r">chrA</span><span class="c">&quot;</span><span class="c">&gt;</span><span class="c">character to find.</span><span class="c">&lt;/</span><span class="c">param</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">returns</span><span class="c">&gt;</span><span class="c">new position just before chrA, -1 for not found</span><span class="c">&lt;/</span><span class="c">returns</span><span class="c">&gt;</span>
		<b>public static int</b> <a id="9ff3aa6d2b23a177" href="../R/9ff3aa6d2b23a177.html" target="n" data-glyph="72,1" class="i method">Prev</a>(<b>byte</b>[] <span id="r54 rd" class="r54 r">b</span>, <b>int</b> <span id="r55 rd" class="r55 r">ptr</span>, <b>char</b> <span id="r56 rd" class="r56 r">chrA</span>)
		{
			<b>if</b> (<span class="r55 r">ptr</span> == <span class="r54 r">b</span>.<a href="@0@mscorlib/A.html#42e9b7616956cf94" class="i property">Length</a>)
			{
				--<span class="r55 r">ptr</span>;
			}
			<b>while</b> (<span class="r55 r">ptr</span> &gt;= 0)
			{
				<b>if</b> (<span class="r54 r">b</span>[<span class="r55 r">ptr</span>--] == <span class="r56 r">chrA</span>)
				{
					<b>return</b> <span class="r55 r">ptr</span>;
				}
			}
			<b>return</b> <span class="r55 r">ptr</span>;
		}

		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">summary</span><span class="c">&gt;</span><span class="c">Locate the first position before the previous LF.</span><span class="c">&lt;/</span><span class="c">summary</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">remarks</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> Locate the first position before the previous LF.</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">p</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> This method stops on the first &#39;\n&#39; it finds.</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;/</span><span class="c">remarks</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">param</span><span class="c"> </span><span class="c">name</span><span class="c">=</span><span class="c">&quot;</span><span class="r57 r">b</span><span class="c">&quot;</span><span class="c">&gt;</span><span class="c">buffer to scan.</span><span class="c">&lt;/</span><span class="c">param</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">param</span><span class="c"> </span><span class="c">name</span><span class="c">=</span><span class="c">&quot;</span><span class="r58 r">ptr</span><span class="c">&quot;</span><span class="c">&gt;</span><span class="c">position within buffer to start looking for LF at.</span><span class="c">&lt;/</span><span class="c">param</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">returns</span><span class="c">&gt;</span><span class="c">new position just before the first LF found, -1 for not found</span><span class="c">&lt;/</span><span class="c">returns</span><span class="c">&gt;</span>
		<b>public static int</b> <a id="dc02903e8823308e" href="../R/dc02903e8823308e.html" target="n" data-glyph="72,1" class="i method">PrevLF</a>(<b>byte</b>[] <span id="r57 rd" class="r57 r">b</span>, <b>int</b> <span id="r58 rd" class="r58 r">ptr</span>)
		{
			<b>return</b> <a href="#9ff3aa6d2b23a177" class="i method">Prev</a>(<span class="r57 r">b</span>, <span class="r58 r">ptr</span>, <span class="s">&#39;\n&#39;</span>);
		}

		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">summary</span><span class="c">&gt;</span><span class="c">Locate the previous position before either the given character or LF.</span><span class="c">&lt;/</span><span class="c">summary</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">remarks</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> Locate the previous position before either the given character or LF.</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">p</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> This method stops on the first match it finds from either chrA or &#39;\n&#39;.</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;/</span><span class="c">remarks</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">param</span><span class="c"> </span><span class="c">name</span><span class="c">=</span><span class="c">&quot;</span><span class="r59 r">b</span><span class="c">&quot;</span><span class="c">&gt;</span><span class="c">buffer to scan.</span><span class="c">&lt;/</span><span class="c">param</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">param</span><span class="c"> </span><span class="c">name</span><span class="c">=</span><span class="c">&quot;</span><span class="r60 r">ptr</span><span class="c">&quot;</span><span class="c">&gt;</span><span class="c">position within buffer to start looking for chrA or LF at.</span><span class="c">&lt;/</span><span class="c">param</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">param</span><span class="c"> </span><span class="c">name</span><span class="c">=</span><span class="c">&quot;</span><span class="r61 r">chrA</span><span class="c">&quot;</span><span class="c">&gt;</span><span class="c">character to find.</span><span class="c">&lt;/</span><span class="c">param</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">returns</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> new position just before the first chrA or LF to be found, -1 for</span>
		<span class="c">///</span><span class="c"> not found</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;/</span><span class="c">returns</span><span class="c">&gt;</span>
		<b>public static int</b> <a id="5c46264b00029a9f" href="../R/../../0000000000.html" target="n" data-glyph="72,1" class="i method">PrevLF</a>(<b>byte</b>[] <span id="r59 rd" class="r59 r">b</span>, <b>int</b> <span id="r60 rd" class="r60 r">ptr</span>, <b>char</b> <span id="r61 rd" class="r61 r">chrA</span>)
		{
			<b>if</b> (<span class="r60 r">ptr</span> == <span class="r59 r">b</span>.<a href="@0@mscorlib/A.html#42e9b7616956cf94" class="i property">Length</a>)
			{
				--<span class="r60 r">ptr</span>;
			}
			<b>while</b> (<span class="r60 r">ptr</span> &gt;= 0)
			{
				<b>byte</b> <span id="r62 rd" class="r62 r">c</span> = <span class="r59 r">b</span>[<span class="r60 r">ptr</span>--];
				<b>if</b> (<span class="r62 r">c</span> == <span class="r61 r">chrA</span> || <span class="r62 r">c</span> == <span class="s">&#39;\n&#39;</span>)
				{
					<b>return</b> <span class="r60 r">ptr</span>;
				}
			}
			<b>return</b> <span class="r60 r">ptr</span>;
		}

		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">summary</span><span class="c">&gt;</span><span class="c">Index the region between </span><span class="c">&lt;</span><span class="c">code</span><span class="c">&gt;</span><span class="c">[ptr, end)</span><span class="c">&lt;/</span><span class="c">code</span><span class="c">&gt;</span><span class="c"> to find line starts.</span><span class="c">&lt;/</span><span class="c">summary</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">remarks</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> Index the region between </span><span class="c">&lt;</span><span class="c">code</span><span class="c">&gt;</span><span class="c">[ptr, end)</span><span class="c">&lt;/</span><span class="c">code</span><span class="c">&gt;</span><span class="c"> to find line starts.</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">p</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> The returned list is 1 indexed. Index 0 contains</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">see</span><span class="c"> </span><span class="c">cref</span><span class="c">=</span><span class="c">&quot;</span><b>int</b>.<a href="@0@mscorlib/A.html#e3cfc4661f06e948" class="i field">MinValue</a><span class="c">&quot;</span><span class="c">&gt;</span><span class="c">int.MinValue</span><span class="c">&lt;/</span><span class="c">see</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> to pad the list out.</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">p</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> Using a 1 indexed list means that line numbers can be directly accessed</span>
		<span class="c">///</span><span class="c"> from the list, so </span><span class="c">&lt;</span><span class="c">code</span><span class="c">&gt;</span><span class="c">list.get(1)</span><span class="c">&lt;/</span><span class="c">code</span><span class="c">&gt;</span><span class="c"> (aka get line 1) returns</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">code</span><span class="c">&gt;</span><span class="c">ptr</span><span class="c">&lt;/</span><span class="c">code</span><span class="c">&gt;</span><span class="c">.</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">p</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> The last element (index </span><span class="c">&lt;</span><span class="c">code</span><span class="c">&gt;</span><span class="c">map.size()-1</span><span class="c">&lt;/</span><span class="c">code</span><span class="c">&gt;</span><span class="c">) always contains</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">code</span><span class="c">&gt;</span><span class="c">end</span><span class="c">&lt;/</span><span class="c">code</span><span class="c">&gt;</span><span class="c">.</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;/</span><span class="c">remarks</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">param</span><span class="c"> </span><span class="c">name</span><span class="c">=</span><span class="c">&quot;</span><span class="r63 r">buf</span><span class="c">&quot;</span><span class="c">&gt;</span><span class="c">buffer to scan.</span><span class="c">&lt;/</span><span class="c">param</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">param</span><span class="c"> </span><span class="c">name</span><span class="c">=</span><span class="c">&quot;</span><span class="r64 r">ptr</span><span class="c">&quot;</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> position within the buffer corresponding to the first byte of</span>
		<span class="c">///</span><span class="c"> line 1.</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;/</span><span class="c">param</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">param</span><span class="c"> </span><span class="c">name</span><span class="c">=</span><span class="c">&quot;</span><span class="r65 r">end</span><span class="c">&quot;</span><span class="c">&gt;</span><span class="c">1 past the end of the content within </span><span class="c">&lt;</span><span class="c">code</span><span class="c">&gt;</span><span class="c">buf</span><span class="c">&lt;/</span><span class="c">code</span><span class="c">&gt;</span><span class="c">.</span><span class="c">&lt;/</span><span class="c">param</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">returns</span><span class="c">&gt;</span><span class="c">a line map indexing the start position of each line.</span><span class="c">&lt;/</span><span class="c">returns</span><span class="c">&gt;</span>
		<b>public static</b> <a href="IntList.cs.html#290b0080ed2bb69b" class="t t">IntList</a> <a id="263d22cca6fbeacc" href="../R/263d22cca6fbeacc.html" target="n" data-glyph="72,1" class="i method">LineMap</a>(<b>byte</b>[] <span id="r63 rd" class="r63 r">buf</span>, <b>int</b> <span id="r64 rd" class="r64 r">ptr</span>, <b>int</b> <span id="r65 rd" class="r65 r">end</span>)
		{
			<span class="c">// Experimentally derived from multiple source repositories</span>
			<span class="c">// the average number of bytes/line is 36. Its a rough guess</span>
			<span class="c">// to initially size our map close to the target.</span>
			<span class="c">//</span>
			<a href="IntList.cs.html#290b0080ed2bb69b" class="t t">IntList</a> <span id="r66 rd" class="r66 r">map</span> = <b>new</b> <a href="IntList.cs.html#c0526534db1a2452" class="t constructor">IntList</a>((<span class="r65 r">end</span> - <span class="r64 r">ptr</span>) / 36);
			<span class="r66 r">map</span>.<a href="IntList.cs.html#0ce944bba43effc8" class="i method">FillTo</a>(1, <b>int</b>.<a href="@0@mscorlib/A.html#e3cfc4661f06e948" class="i field">MinValue</a>);
			<b>for</b> (; <span class="r64 r">ptr</span> &lt; <span class="r65 r">end</span>; <span class="r64 r">ptr</span> = <a href="#162ee2e46b60d416" class="i method">NextLF</a>(<span class="r63 r">buf</span>, <span class="r64 r">ptr</span>))
			{
				<span class="r66 r">map</span>.<a href="IntList.cs.html#755f1c634b741bea" class="i method">Add</a>(<span class="r64 r">ptr</span>);
			}
			<span class="r66 r">map</span>.<a href="IntList.cs.html#755f1c634b741bea" class="i method">Add</a>(<span class="r65 r">end</span>);
			<b>return</b> <span class="r66 r">map</span>;
		}

		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">summary</span><span class="c">&gt;</span><span class="c">Locate the &quot;author &quot; header line data.</span><span class="c">&lt;/</span><span class="c">summary</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">remarks</span><span class="c">&gt;</span><span class="c">Locate the &quot;author &quot; header line data.</span><span class="c">&lt;/</span><span class="c">remarks</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">param</span><span class="c"> </span><span class="c">name</span><span class="c">=</span><span class="c">&quot;</span><span class="r67 r">b</span><span class="c">&quot;</span><span class="c">&gt;</span><span class="c">buffer to scan.</span><span class="c">&lt;/</span><span class="c">param</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">param</span><span class="c"> </span><span class="c">name</span><span class="c">=</span><span class="c">&quot;</span><span class="r68 r">ptr</span><span class="c">&quot;</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> position in buffer to start the scan at. Most callers should</span>
		<span class="c">///</span><span class="c"> pass 0 to ensure the scan starts from the beginning of the</span>
		<span class="c">///</span><span class="c"> commit buffer and does not accidentally look at message body.</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;/</span><span class="c">param</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">returns</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> position just after the space in &quot;author &quot;, so the first</span>
		<span class="c">///</span><span class="c"> character of the author&#39;s name. If no author header can be</span>
		<span class="c">///</span><span class="c"> located -1 is returned.</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;/</span><span class="c">returns</span><span class="c">&gt;</span>
		<b>public static int</b> <a id="5483a0d710def1f4" href="../R/5483a0d710def1f4.html" target="n" data-glyph="72,1" class="i method">Author</a>(<b>byte</b>[] <span id="r67 rd" class="r67 r">b</span>, <b>int</b> <span id="r68 rd" class="r68 r">ptr</span>)
		{
			<b>int</b> <span id="r69 rd" class="r69 r">sz</span> = <span class="r67 r">b</span>.<a href="@0@mscorlib/A.html#42e9b7616956cf94" class="i property">Length</a>;
			<b>if</b> (<span class="r68 r">ptr</span> == 0)
			{
				<span class="r68 r">ptr</span> += 46;
			}
			<span class="c">// skip the &quot;tree ...&quot; line.</span>
			<b>while</b> (<span class="r68 r">ptr</span> &lt; <span class="r69 r">sz</span> &amp;&amp; <span class="r67 r">b</span>[<span class="r68 r">ptr</span>] == <span class="s">&#39;p&#39;</span>)
			{
				<span class="r68 r">ptr</span> += 48;
			}
			<span class="c">// skip this parent.</span>
			<b>return</b> <a href="#2e7e3c9c7c12e27d" class="i method">Match</a>(<span class="r67 r">b</span>, <span class="r68 r">ptr</span>, <a href="../NGit/ObjectChecker.cs.html#d4c6595dae32ff3a" class="t t">ObjectChecker</a>.<a href="../NGit/ObjectChecker.cs.html#c60a4a0cc63b8c9a" class="i field">author</a>);
		}

		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">summary</span><span class="c">&gt;</span><span class="c">Locate the &quot;committer &quot; header line data.</span><span class="c">&lt;/</span><span class="c">summary</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">remarks</span><span class="c">&gt;</span><span class="c">Locate the &quot;committer &quot; header line data.</span><span class="c">&lt;/</span><span class="c">remarks</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">param</span><span class="c"> </span><span class="c">name</span><span class="c">=</span><span class="c">&quot;</span><span class="r70 r">b</span><span class="c">&quot;</span><span class="c">&gt;</span><span class="c">buffer to scan.</span><span class="c">&lt;/</span><span class="c">param</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">param</span><span class="c"> </span><span class="c">name</span><span class="c">=</span><span class="c">&quot;</span><span class="r71 r">ptr</span><span class="c">&quot;</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> position in buffer to start the scan at. Most callers should</span>
		<span class="c">///</span><span class="c"> pass 0 to ensure the scan starts from the beginning of the</span>
		<span class="c">///</span><span class="c"> commit buffer and does not accidentally look at message body.</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;/</span><span class="c">param</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">returns</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> position just after the space in &quot;committer &quot;, so the first</span>
		<span class="c">///</span><span class="c"> character of the committer&#39;s name. If no committer header can be</span>
		<span class="c">///</span><span class="c"> located -1 is returned.</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;/</span><span class="c">returns</span><span class="c">&gt;</span>
		<b>public static int</b> <a id="0fca363abefcd214" href="../R/0fca363abefcd214.html" target="n" data-glyph="72,1" class="i method">Committer</a>(<b>byte</b>[] <span id="r70 rd" class="r70 r">b</span>, <b>int</b> <span id="r71 rd" class="r71 r">ptr</span>)
		{
			<b>int</b> <span id="r72 rd" class="r72 r">sz</span> = <span class="r70 r">b</span>.<a href="@0@mscorlib/A.html#42e9b7616956cf94" class="i property">Length</a>;
			<b>if</b> (<span class="r71 r">ptr</span> == 0)
			{
				<span class="r71 r">ptr</span> += 46;
			}
			<span class="c">// skip the &quot;tree ...&quot; line.</span>
			<b>while</b> (<span class="r71 r">ptr</span> &lt; <span class="r72 r">sz</span> &amp;&amp; <span class="r70 r">b</span>[<span class="r71 r">ptr</span>] == <span class="s">&#39;p&#39;</span>)
			{
				<span class="r71 r">ptr</span> += 48;
			}
			<span class="c">// skip this parent.</span>
			<b>if</b> (<span class="r71 r">ptr</span> &lt; <span class="r72 r">sz</span> &amp;&amp; <span class="r70 r">b</span>[<span class="r71 r">ptr</span>] == <span class="s">&#39;a&#39;</span>)
			{
				<span class="r71 r">ptr</span> = <a href="#162ee2e46b60d416" class="i method">NextLF</a>(<span class="r70 r">b</span>, <span class="r71 r">ptr</span>);
			}
			<b>return</b> <a href="#2e7e3c9c7c12e27d" class="i method">Match</a>(<span class="r70 r">b</span>, <span class="r71 r">ptr</span>, <a href="../NGit/ObjectChecker.cs.html#d4c6595dae32ff3a" class="t t">ObjectChecker</a>.<a href="../NGit/ObjectChecker.cs.html#4efd1dbb9b95bcdd" class="i field">committer</a>);
		}

		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">summary</span><span class="c">&gt;</span><span class="c">Locate the &quot;tagger &quot; header line data.</span><span class="c">&lt;/</span><span class="c">summary</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">remarks</span><span class="c">&gt;</span><span class="c">Locate the &quot;tagger &quot; header line data.</span><span class="c">&lt;/</span><span class="c">remarks</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">param</span><span class="c"> </span><span class="c">name</span><span class="c">=</span><span class="c">&quot;</span><span class="r73 r">b</span><span class="c">&quot;</span><span class="c">&gt;</span><span class="c">buffer to scan.</span><span class="c">&lt;/</span><span class="c">param</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">param</span><span class="c"> </span><span class="c">name</span><span class="c">=</span><span class="c">&quot;</span><span class="r74 r">ptr</span><span class="c">&quot;</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> position in buffer to start the scan at. Most callers should</span>
		<span class="c">///</span><span class="c"> pass 0 to ensure the scan starts from the beginning of the tag</span>
		<span class="c">///</span><span class="c"> buffer and does not accidentally look at message body.</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;/</span><span class="c">param</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">returns</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> position just after the space in &quot;tagger &quot;, so the first</span>
		<span class="c">///</span><span class="c"> character of the tagger&#39;s name. If no tagger header can be</span>
		<span class="c">///</span><span class="c"> located -1 is returned.</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;/</span><span class="c">returns</span><span class="c">&gt;</span>
		<b>public static int</b> <a id="1111bae1c8d1bece" href="../R/1111bae1c8d1bece.html" target="n" data-glyph="72,1" class="i method">Tagger</a>(<b>byte</b>[] <span id="r73 rd" class="r73 r">b</span>, <b>int</b> <span id="r74 rd" class="r74 r">ptr</span>)
		{
			<b>int</b> <span id="r75 rd" class="r75 r">sz</span> = <span class="r73 r">b</span>.<a href="@0@mscorlib/A.html#42e9b7616956cf94" class="i property">Length</a>;
			<b>if</b> (<span class="r74 r">ptr</span> == 0)
			{
				<span class="r74 r">ptr</span> += 48;
			}
			<span class="c">// skip the &quot;object ...&quot; line.</span>
			<b>while</b> (<span class="r74 r">ptr</span> &lt; <span class="r75 r">sz</span>)
			{
				<b>if</b> (<span class="r73 r">b</span>[<span class="r74 r">ptr</span>] == <span class="s">&#39;\n&#39;</span>)
				{
					<b>return</b> -1;
				}
				<b>int</b> <span id="r76 rd" class="r76 r">m</span> = <a href="#2e7e3c9c7c12e27d" class="i method">Match</a>(<span class="r73 r">b</span>, <span class="r74 r">ptr</span>, <a href="../NGit/ObjectChecker.cs.html#d4c6595dae32ff3a" class="t t">ObjectChecker</a>.<a href="../NGit/ObjectChecker.cs.html#8001e2479e5fbab7" class="i field">tagger</a>);
				<b>if</b> (<span class="r76 r">m</span> &gt;= 0)
				{
					<b>return</b> <span class="r76 r">m</span>;
				}
				<span class="r74 r">ptr</span> = <a href="#162ee2e46b60d416" class="i method">NextLF</a>(<span class="r73 r">b</span>, <span class="r74 r">ptr</span>);
			}
			<b>return</b> -1;
		}

		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">summary</span><span class="c">&gt;</span><span class="c">Locate the &quot;encoding &quot; header line.</span><span class="c">&lt;/</span><span class="c">summary</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">remarks</span><span class="c">&gt;</span><span class="c">Locate the &quot;encoding &quot; header line.</span><span class="c">&lt;/</span><span class="c">remarks</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">param</span><span class="c"> </span><span class="c">name</span><span class="c">=</span><span class="c">&quot;</span><span class="r77 r">b</span><span class="c">&quot;</span><span class="c">&gt;</span><span class="c">buffer to scan.</span><span class="c">&lt;/</span><span class="c">param</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">param</span><span class="c"> </span><span class="c">name</span><span class="c">=</span><span class="c">&quot;</span><span class="r78 r">ptr</span><span class="c">&quot;</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> position in buffer to start the scan at. Most callers should</span>
		<span class="c">///</span><span class="c"> pass 0 to ensure the scan starts from the beginning of the</span>
		<span class="c">///</span><span class="c"> buffer and does not accidentally look at the message body.</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;/</span><span class="c">param</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">returns</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> position just after the space in &quot;encoding &quot;, so the first</span>
		<span class="c">///</span><span class="c"> character of the encoding&#39;s name. If no encoding header can be</span>
		<span class="c">///</span><span class="c"> located -1 is returned (and UTF-8 should be assumed).</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;/</span><span class="c">returns</span><span class="c">&gt;</span>
		<b>public static int</b> <a id="10e7243520789f5c" href="../R/10e7243520789f5c.html" target="n" data-glyph="72,1" class="i method">Encoding</a>(<b>byte</b>[] <span id="r77 rd" class="r77 r">b</span>, <b>int</b> <span id="r78 rd" class="r78 r">ptr</span>)
		{
			<b>int</b> <span id="r79 rd" class="r79 r">sz</span> = <span class="r77 r">b</span>.<a href="@0@mscorlib/A.html#42e9b7616956cf94" class="i property">Length</a>;
			<b>while</b> (<span class="r78 r">ptr</span> &lt; <span class="r79 r">sz</span>)
			{
				<b>if</b> (<span class="r77 r">b</span>[<span class="r78 r">ptr</span>] == <span class="s">&#39;\n&#39;</span>)
				{
					<b>return</b> -1;
				}
				<b>if</b> (<span class="r77 r">b</span>[<span class="r78 r">ptr</span>] == <span class="s">&#39;e&#39;</span>)
				{
					<b>break</b>;
				}
				<span class="r78 r">ptr</span> = <a href="#162ee2e46b60d416" class="i method">NextLF</a>(<span class="r77 r">b</span>, <span class="r78 r">ptr</span>);
			}
			<b>return</b> <a href="#2e7e3c9c7c12e27d" class="i method">Match</a>(<span class="r77 r">b</span>, <span class="r78 r">ptr</span>, <a href="../NGit/ObjectChecker.cs.html#d4c6595dae32ff3a" class="t t">ObjectChecker</a>.<a href="../NGit/ObjectChecker.cs.html#073944e9c21739ff" class="i field">encoding</a>);
		}

		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">summary</span><span class="c">&gt;</span><span class="c">Parse the &quot;encoding &quot; header into a character set reference.</span><span class="c">&lt;/</span><span class="c">summary</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">remarks</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> Parse the &quot;encoding &quot; header into a character set reference.</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">p</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> Locates the &quot;encoding &quot; header (if present) by first calling</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">see</span><span class="c"> </span><span class="c">cref</span><span class="c">=</span><span class="c">&quot;</span><a href="#10e7243520789f5c" class="i method">Encoding</a>(<b>byte</b>[], <b>int</b>)<span class="c">&quot;</span><span class="c">&gt;</span><span class="c">Encoding(byte[], int)</span><span class="c">&lt;/</span><span class="c">see</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> and then returns the proper character set</span>
		<span class="c">///</span><span class="c"> to apply to this buffer to evaluate its contents as character data.</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">p</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> If no encoding header is present,</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">see</span><span class="c"> </span><span class="c">cref</span><span class="c">=</span><span class="c">&quot;</span><span class="i n">NGit</span>.<a href="../NGit/Constants.cs.html#71c965f28a6bcd51" class="t t">Constants</a>.<a href="../NGit/Constants.cs.html#cef92de5aff31da5" class="i field">CHARSET</a><span class="c">&quot;</span><span class="c">&gt;</span><span class="c">NGit.Constants.CHARSET</span><span class="c">&lt;/</span><span class="c">see</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> is assumed.</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;/</span><span class="c">remarks</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">param</span><span class="c"> </span><span class="c">name</span><span class="c">=</span><span class="c">&quot;</span><span class="r80 r">b</span><span class="c">&quot;</span><span class="c">&gt;</span><span class="c">buffer to scan.</span><span class="c">&lt;/</span><span class="c">param</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">returns</span><span class="c">&gt;</span><span class="c">the Java character set representation. Never null.</span><span class="c">&lt;/</span><span class="c">returns</span><span class="c">&gt;</span>
		<b>public static</b> <span class="i n">System</span>.<span class="i n">Text</span>.<a href="@0@mscorlib/A.html#3b6090c501893c25" class="t t">Encoding</a> <a id="f7e7b171e18d8e40" href="../R/f7e7b171e18d8e40.html" target="n" data-glyph="72,1" class="i method">ParseEncoding</a>(<b>byte</b>[] <span id="r80 rd" class="r80 r">b</span>)
		{
			<b>int</b> <span id="r81 rd" class="r81 r">enc</span> = <a href="#10e7243520789f5c" class="i method">Encoding</a>(<span class="r80 r">b</span>, 0);
			<b>if</b> (<span class="r81 r">enc</span> &lt; 0)
			{
				<b>return</b> <a href="../NGit/Constants.cs.html#71c965f28a6bcd51" class="t t">Constants</a>.<a href="../NGit/Constants.cs.html#cef92de5aff31da5" class="i field">CHARSET</a>;
			}
			<b>int</b> <span id="r82 rd" class="r82 r">lf</span> = <a href="#162ee2e46b60d416" class="i method">NextLF</a>(<span class="r80 r">b</span>, <span class="r81 r">enc</span>);
			<b>string</b> <span id="r83 rd" class="r83 r">decoded</span> = <a href="#12db5ac2c9521321" class="i method">Decode</a>(<a href="../NGit/Constants.cs.html#71c965f28a6bcd51" class="t t">Constants</a>.<a href="../NGit/Constants.cs.html#cef92de5aff31da5" class="i field">CHARSET</a>, <span class="r80 r">b</span>, <span class="r81 r">enc</span>, <span class="r82 r">lf</span> - 1);
			<b>try</b>
			{
				<b>return</b> <span class="i n">Sharpen</span>.<a href="/Sharpen/A.html#229d48bbca3d4b45" class="t t">Extensions</a>.<a href="/Sharpen/A.html#fced17ebf6f54d8b" class="i method">GetEncoding</a>(<span class="r83 r">decoded</span>);
			}
			<b>catch</b> (<a href="/Sharpen/A.html#436080fa20391f00" class="t t">IllegalCharsetNameException</a> <span id="r84 rd" class="r84 r">badName</span>)
			{
				<span class="i n">System</span>.<span class="i n">Text</span>.<a href="@0@mscorlib/A.html#3b6090c501893c25" class="t t">Encoding</a> <span id="r85 rd" class="r85 r">aliased</span> = <a href="#6418685fff380ff6" class="i method">CharsetForAlias</a>(<span class="r83 r">decoded</span>);
				<b>if</b> (<span class="r85 r">aliased</span> != <b>null</b>)
				{
					<b>return</b> <span class="r85 r">aliased</span>;
				}
				<b>throw</b>;
			}
			<b>catch</b> (<a href="/Sharpen/A.html#589b9d08c512f682" class="t t">UnsupportedCharsetException</a> <span id="r86 rd" class="r86 r">badName</span>)
			{
				<span class="i n">System</span>.<span class="i n">Text</span>.<a href="@0@mscorlib/A.html#3b6090c501893c25" class="t t">Encoding</a> <span id="r87 rd" class="r87 r">aliased</span> = <a href="#6418685fff380ff6" class="i method">CharsetForAlias</a>(<span class="r83 r">decoded</span>);
				<b>if</b> (<span class="r87 r">aliased</span> != <b>null</b>)
				{
					<b>return</b> <span class="r87 r">aliased</span>;
				}
				<b>throw</b>;
			}
		}

		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">summary</span><span class="c">&gt;</span><span class="c">Parse a name string (e.g.</span><span class="c">&lt;/</span><span class="c">summary</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">remarks</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> Parse a name string (e.g. author, committer, tagger) into a PersonIdent.</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">p</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> Leading spaces won&#39;t be trimmed from the string, i.e. will show up in the</span>
		<span class="c">///</span><span class="c"> parsed name afterwards.</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;/</span><span class="c">remarks</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">param</span><span class="c"> </span><span class="c">name</span><span class="c">=</span><span class="c">&quot;</span><span class="r88 r">in</span><span class="c">&quot;</span><span class="c">&gt;</span><span class="c">the string to parse a name from.</span><span class="c">&lt;/</span><span class="c">param</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">returns</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> the parsed identity or null in case the identity could not be</span>
		<span class="c">///</span><span class="c"> parsed.</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;/</span><span class="c">returns</span><span class="c">&gt;</span>
		<b>public static</b> <a href="../NGit/PersonIdent.cs.html#753b6d32f0a7c466" class="t t">PersonIdent</a> <a id="8cac491190ecb91c" href="../R/../../0000000000.html" target="n" data-glyph="72,1" class="i method">ParsePersonIdent</a>(<b>string</b> <span id="r88 rd" class="r88 r">@in</span>)
		{
			<b>return</b> <a href="#52ae96049b4df41c" class="i method">ParsePersonIdent</a>(<a href="../NGit/Constants.cs.html#71c965f28a6bcd51" class="t t">Constants</a>.<a href="../NGit/Constants.cs.html#c2296623c900fab2" class="i method">Encode</a>(<span class="r88 r">@in</span>), 0);
		}

		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">summary</span><span class="c">&gt;</span><span class="c">Parse a name line (e.g.</span><span class="c">&lt;/</span><span class="c">summary</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">remarks</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> Parse a name line (e.g. author, committer, tagger) into a PersonIdent.</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">p</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> When passing in a value for </span><span class="c">&lt;</span><span class="c">code</span><span class="c">&gt;</span><span class="c">nameB</span><span class="c">&lt;/</span><span class="c">code</span><span class="c">&gt;</span><span class="c"> callers should use the</span>
		<span class="c">///</span><span class="c"> return value of</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">see</span><span class="c"> </span><span class="c">cref</span><span class="c">=</span><span class="c">&quot;</span><a href="#5483a0d710def1f4" class="i method">Author</a>(<b>byte</b>[], <b>int</b>)<span class="c">&quot;</span><span class="c">&gt;</span><span class="c">Author(byte[], int)</span><span class="c">&lt;/</span><span class="c">see</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> or</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">see</span><span class="c"> </span><span class="c">cref</span><span class="c">=</span><span class="c">&quot;</span><a href="#0fca363abefcd214" class="i method">Committer</a>(<b>byte</b>[], <b>int</b>)<span class="c">&quot;</span><span class="c">&gt;</span><span class="c">Committer(byte[], int)</span><span class="c">&lt;/</span><span class="c">see</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> , as these methods provide the proper</span>
		<span class="c">///</span><span class="c"> position within the buffer.</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;/</span><span class="c">remarks</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">param</span><span class="c"> </span><span class="c">name</span><span class="c">=</span><span class="c">&quot;</span><span class="r89 r">raw</span><span class="c">&quot;</span><span class="c">&gt;</span><span class="c">the buffer to parse character data from.</span><span class="c">&lt;/</span><span class="c">param</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">param</span><span class="c"> </span><span class="c">name</span><span class="c">=</span><span class="c">&quot;</span><span class="r90 r">nameB</span><span class="c">&quot;</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> first position of the identity information. This should be the</span>
		<span class="c">///</span><span class="c"> first position after the space which delimits the header field</span>
		<span class="c">///</span><span class="c"> name (e.g. &quot;author&quot; or &quot;committer&quot;) from the rest of the</span>
		<span class="c">///</span><span class="c"> identity line.</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;/</span><span class="c">param</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">returns</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> the parsed identity or null in case the identity could not be</span>
		<span class="c">///</span><span class="c"> parsed.</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;/</span><span class="c">returns</span><span class="c">&gt;</span>
		<b>public static</b> <a href="../NGit/PersonIdent.cs.html#753b6d32f0a7c466" class="t t">PersonIdent</a> <a id="52ae96049b4df41c" href="../R/52ae96049b4df41c.html" target="n" data-glyph="72,1" class="i method">ParsePersonIdent</a>(<b>byte</b>[] <span id="r89 rd" class="r89 r">raw</span>, <b>int</b> <span id="r90 rd" class="r90 r">nameB</span>)
		{
			<span class="i n">System</span>.<span class="i n">Text</span>.<a href="@0@mscorlib/A.html#3b6090c501893c25" class="t t">Encoding</a> <span id="r91 rd" class="r91 r">cs</span> = <a href="#f7e7b171e18d8e40" class="i method">ParseEncoding</a>(<span class="r89 r">raw</span>);
			<b>int</b> <span id="r92 rd" class="r92 r">emailB</span> = <a href="#8b1df44ee0b6ff07" class="i method">NextLF</a>(<span class="r89 r">raw</span>, <span class="r90 r">nameB</span>, <span class="s">&#39;&lt;&#39;</span>);
			<b>int</b> <span id="r93 rd" class="r93 r">emailE</span> = <a href="#8b1df44ee0b6ff07" class="i method">NextLF</a>(<span class="r89 r">raw</span>, <span class="r92 r">emailB</span>, <span class="s">&#39;&gt;&#39;</span>);
			<b>if</b> (<span class="r92 r">emailB</span> &gt;= <span class="r89 r">raw</span>.<a href="@0@mscorlib/A.html#42e9b7616956cf94" class="i property">Length</a> || <span class="r89 r">raw</span>[<span class="r92 r">emailB</span>] == <span class="s">&#39;\n&#39;</span> || (<span class="r93 r">emailE</span> &gt;= <span class="r89 r">raw</span>.<a href="@0@mscorlib/A.html#42e9b7616956cf94" class="i property">Length</a> - 1 &amp;&amp; <span class="r89 r">raw</span>
				[<span class="r93 r">emailE</span> - 1] != <span class="s">&#39;&gt;&#39;</span>))
			{
				<b>return null</b>;
			}
			<b>int</b> <span id="r94 rd" class="r94 r">nameEnd</span> = <span class="r92 r">emailB</span> - 2 &gt;= <span class="r90 r">nameB</span> &amp;&amp; <span class="r89 r">raw</span>[<span class="r92 r">emailB</span> - 2] == <span class="s">&#39; &#39;</span> ? <span class="r92 r">emailB</span> - 2 : <span class="r92 r">emailB</span>
				 - 1;
			<b>string</b> <span id="r95 rd" class="r95 r">name</span> = <a href="#12db5ac2c9521321" class="i method">Decode</a>(<span class="r91 r">cs</span>, <span class="r89 r">raw</span>, <span class="r90 r">nameB</span>, <span class="r94 r">nameEnd</span>);
			<b>string</b> <span id="r96 rd" class="r96 r">email</span> = <a href="#12db5ac2c9521321" class="i method">Decode</a>(<span class="r91 r">cs</span>, <span class="r89 r">raw</span>, <span class="r92 r">emailB</span>, <span class="r93 r">emailE</span> - 1);
			<span class="c">// Start searching from end of line, as after first name-email pair,</span>
			<span class="c">// another name-email pair may occur. We will ignore all kinds of</span>
			<span class="c">// &quot;junk&quot; following the first email.</span>
			<span class="c">//</span>
			<span class="c">// We&#39;ve to use (emailE - 1) for the case that raw[email] is LF,</span>
			<span class="c">// otherwise we would run too far. &quot;-2&quot; is necessary to position</span>
			<span class="c">// before the LF in case of LF termination resp. the penultimate</span>
			<span class="c">// character if there is no trailing LF.</span>
			<b>int</b> <span id="r97 rd" class="r97 r">tzBegin</span> = <a href="#15a3cc582e541f76" class="i method">LastIndexOfTrim</a>(<span class="r89 r">raw</span>, <span class="s">&#39; &#39;</span>, <a href="#162ee2e46b60d416" class="i method">NextLF</a>(<span class="r89 r">raw</span>, <span class="r93 r">emailE</span> - 1) - 2) + 1;
			<b>if</b> (<span class="r97 r">tzBegin</span> &lt;= <span class="r93 r">emailE</span>)
			{
				<span class="c">// No time/zone, still valid</span>
				<b>return</b> <b>new</b> <a href="../NGit/PersonIdent.cs.html#f88325c4909b2558" class="t constructor">PersonIdent</a>(<span class="r95 r">name</span>, <span class="r96 r">email</span>, 0, 0);
			}
			<b>int</b> <span id="r98 rd" class="r98 r">whenBegin</span> = <a href="@0@mscorlib/A.html#a4407e67b9a5afad" class="t t">Math</a>.<a href="@0@mscorlib/A.html#80ff956e9ca8e414" class="i method">Max</a>(<span class="r93 r">emailE</span>, <a href="#15a3cc582e541f76" class="i method">LastIndexOfTrim</a>(<span class="r89 r">raw</span>, <span class="s">&#39; &#39;</span>, <span class="r97 r">tzBegin</span> - 1) + 1);
			<b>if</b> (<span class="r98 r">whenBegin</span> &gt;= <span class="r97 r">tzBegin</span> - 1)
			{
				<span class="c">// No time/zone, still valid</span>
				<b>return</b> <b>new</b> <a href="../NGit/PersonIdent.cs.html#f88325c4909b2558" class="t constructor">PersonIdent</a>(<span class="r95 r">name</span>, <span class="r96 r">email</span>, 0, 0);
			}
			<b>long</b> <span id="r99 rd" class="r99 r">when</span> = <a href="#e66132e4054e1848" class="i method">ParseLongBase10</a>(<span class="r89 r">raw</span>, <span class="r98 r">whenBegin</span>, <b>null</b>);
			<b>int</b> <span id="r100 rd" class="r100 r">tz</span> = <a href="#8738fc151f575ad0" class="i method">ParseTimeZoneOffset</a>(<span class="r89 r">raw</span>, <span class="r97 r">tzBegin</span>);
			<b>return</b> <b>new</b> <a href="../NGit/PersonIdent.cs.html#f88325c4909b2558" class="t constructor">PersonIdent</a>(<span class="r95 r">name</span>, <span class="r96 r">email</span>, <span class="r99 r">when</span> * 1000L, <span class="r100 r">tz</span>);
		}

		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">summary</span><span class="c">&gt;</span><span class="c">Parse a name data (e.g.</span><span class="c">&lt;/</span><span class="c">summary</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">remarks</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> Parse a name data (e.g. as within a reflog) into a PersonIdent.</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">p</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> When passing in a value for </span><span class="c">&lt;</span><span class="c">code</span><span class="c">&gt;</span><span class="c">nameB</span><span class="c">&lt;/</span><span class="c">code</span><span class="c">&gt;</span><span class="c"> callers should use the</span>
		<span class="c">///</span><span class="c"> return value of</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">see</span><span class="c"> </span><span class="c">cref</span><span class="c">=</span><span class="c">&quot;</span><a href="#5483a0d710def1f4" class="i method">Author</a>(<b>byte</b>[], <b>int</b>)<span class="c">&quot;</span><span class="c">&gt;</span><span class="c">Author(byte[], int)</span><span class="c">&lt;/</span><span class="c">see</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> or</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">see</span><span class="c"> </span><span class="c">cref</span><span class="c">=</span><span class="c">&quot;</span><a href="#0fca363abefcd214" class="i method">Committer</a>(<b>byte</b>[], <b>int</b>)<span class="c">&quot;</span><span class="c">&gt;</span><span class="c">Committer(byte[], int)</span><span class="c">&lt;/</span><span class="c">see</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> , as these methods provide the proper</span>
		<span class="c">///</span><span class="c"> position within the buffer.</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;/</span><span class="c">remarks</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">param</span><span class="c"> </span><span class="c">name</span><span class="c">=</span><span class="c">&quot;</span><span class="r101 r">raw</span><span class="c">&quot;</span><span class="c">&gt;</span><span class="c">the buffer to parse character data from.</span><span class="c">&lt;/</span><span class="c">param</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">param</span><span class="c"> </span><span class="c">name</span><span class="c">=</span><span class="c">&quot;</span><span class="r102 r">nameB</span><span class="c">&quot;</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> first position of the identity information. This should be the</span>
		<span class="c">///</span><span class="c"> first position after the space which delimits the header field</span>
		<span class="c">///</span><span class="c"> name (e.g. &quot;author&quot; or &quot;committer&quot;) from the rest of the</span>
		<span class="c">///</span><span class="c"> identity line.</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;/</span><span class="c">param</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">returns</span><span class="c">&gt;</span><span class="c">the parsed identity. Never null.</span><span class="c">&lt;/</span><span class="c">returns</span><span class="c">&gt;</span>
		<b>public static</b> <a href="../NGit/PersonIdent.cs.html#753b6d32f0a7c466" class="t t">PersonIdent</a> <a id="07fa08c6eae0d90e" href="../R/07fa08c6eae0d90e.html" target="n" data-glyph="72,1" class="i method">ParsePersonIdentOnly</a>(<b>byte</b>[] <span id="r101 rd" class="r101 r">raw</span>, <b>int</b> <span id="r102 rd" class="r102 r">nameB</span>)
		{
			<b>int</b> <span id="r103 rd" class="r103 r">stop</span> = <a href="#162ee2e46b60d416" class="i method">NextLF</a>(<span class="r101 r">raw</span>, <span class="r102 r">nameB</span>);
			<b>int</b> <span id="r104 rd" class="r104 r">emailB</span> = <a href="#8b1df44ee0b6ff07" class="i method">NextLF</a>(<span class="r101 r">raw</span>, <span class="r102 r">nameB</span>, <span class="s">&#39;&lt;&#39;</span>);
			<b>int</b> <span id="r105 rd" class="r105 r">emailE</span> = <a href="#8b1df44ee0b6ff07" class="i method">NextLF</a>(<span class="r101 r">raw</span>, <span class="r104 r">emailB</span>, <span class="s">&#39;&gt;&#39;</span>);
			<b>string</b> <span id="r106 rd" class="r106 r">name</span>;
			<b>string</b> <span id="r107 rd" class="r107 r">email</span>;
			<b>if</b> (<span class="r105 r">emailE</span> &lt; <span class="r103 r">stop</span>)
			{
				<span class="r107 r">email</span> = <a href="#c23f18f826e9513e" class="i method">Decode</a>(<span class="r101 r">raw</span>, <span class="r104 r">emailB</span>, <span class="r105 r">emailE</span> - 1);
			}
			<b>else</b>
			{
				<span class="r107 r">email</span> = <span class="s">&quot;invalid&quot;</span>;
			}
			<b>if</b> (<span class="r104 r">emailB</span> &lt; <span class="r103 r">stop</span>)
			{
				<span class="r106 r">name</span> = <a href="#c23f18f826e9513e" class="i method">Decode</a>(<span class="r101 r">raw</span>, <span class="r102 r">nameB</span>, <span class="r104 r">emailB</span> - 2);
			}
			<b>else</b>
			{
				<span class="r106 r">name</span> = <a href="#c23f18f826e9513e" class="i method">Decode</a>(<span class="r101 r">raw</span>, <span class="r102 r">nameB</span>, <span class="r103 r">stop</span>);
			}
			<a href="MutableInteger.cs.html#66f1edb633e848e3" class="t t">MutableInteger</a> <span id="r108 rd" class="r108 r">ptrout</span> = <b>new</b> <a href="MutableInteger.cs.html#66f1edb633e848e3" class="t constructor">MutableInteger</a>();
			<b>long</b> <span id="r109 rd" class="r109 r">when</span>;
			<b>int</b> <span id="r110 rd" class="r110 r">tz</span>;
			<b>if</b> (<span class="r105 r">emailE</span> &lt; <span class="r103 r">stop</span>)
			{
				<span class="r109 r">when</span> = <a href="#e66132e4054e1848" class="i method">ParseLongBase10</a>(<span class="r101 r">raw</span>, <span class="r105 r">emailE</span> + 1, <span class="r108 r">ptrout</span>);
				<span class="r110 r">tz</span> = <a href="#8738fc151f575ad0" class="i method">ParseTimeZoneOffset</a>(<span class="r101 r">raw</span>, <span class="r108 r">ptrout</span>.<a href="MutableInteger.cs.html#b6e5bddb557534b1" class="i field">value</a>);
			}
			<b>else</b>
			{
				<span class="r109 r">when</span> = 0;
				<span class="r110 r">tz</span> = 0;
			}
			<b>return</b> <b>new</b> <a href="../NGit/PersonIdent.cs.html#f88325c4909b2558" class="t constructor">PersonIdent</a>(<span class="r106 r">name</span>, <span class="r107 r">email</span>, <span class="r109 r">when</span> * 1000L, <span class="r110 r">tz</span>);
		}

		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">summary</span><span class="c">&gt;</span><span class="c">Locate the end of a footer line key string.</span><span class="c">&lt;/</span><span class="c">summary</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">remarks</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> Locate the end of a footer line key string.</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">p</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> If the region at</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">code</span><span class="c">&gt;</span><span class="c">raw[ptr]</span><span class="c">&lt;/</span><span class="c">code</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> matches</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">code</span><span class="c">&gt;</span><span class="c">^[A-Za-z0-9-]+:</span><span class="c">&lt;/</span><span class="c">code</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> (e.g.</span>
		<span class="c">///</span><span class="c"> &quot;Signed-off-by: A. U. Thor\n&quot;) then this method returns the position of</span>
		<span class="c">///</span><span class="c"> the first &#39;:&#39;.</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">p</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> If the region at</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">code</span><span class="c">&gt;</span><span class="c">raw[ptr]</span><span class="c">&lt;/</span><span class="c">code</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> does not match</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">code</span><span class="c">&gt;</span><span class="c">^[A-Za-z0-9-]+:</span><span class="c">&lt;/</span><span class="c">code</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> then this method returns -1.</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;/</span><span class="c">remarks</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">param</span><span class="c"> </span><span class="c">name</span><span class="c">=</span><span class="c">&quot;</span><span class="r111 r">raw</span><span class="c">&quot;</span><span class="c">&gt;</span><span class="c">buffer to scan.</span><span class="c">&lt;/</span><span class="c">param</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">param</span><span class="c"> </span><span class="c">name</span><span class="c">=</span><span class="c">&quot;</span><span class="r112 r">ptr</span><span class="c">&quot;</span><span class="c">&gt;</span><span class="c">first position within raw to consider as a footer line key.</span><span class="c">&lt;/</span><span class="c">param</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">returns</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> position of the &#39;:&#39; which terminates the footer line key if this</span>
		<span class="c">///</span><span class="c"> is otherwise a valid footer line key; otherwise -1.</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;/</span><span class="c">returns</span><span class="c">&gt;</span>
		<b>public static int</b> <a id="0ed37dee4aeafd0f" href="../R/0ed37dee4aeafd0f.html" target="n" data-glyph="72,1" class="i method">EndOfFooterLineKey</a>(<b>byte</b>[] <span id="r111 rd" class="r111 r">raw</span>, <b>int</b> <span id="r112 rd" class="r112 r">ptr</span>)
		{
			<b>try</b>
			{
				<b>for</b> (; ; )
				{
					<b>byte</b> <span id="r113 rd" class="r113 r">c</span> = <span class="r111 r">raw</span>[<span class="r112 r">ptr</span>];
					<b>if</b> (<a href="#b2b546f29e23fd15" class="i field">footerLineKeyChars</a>[<span class="r113 r">c</span>] == 0)
					{
						<b>if</b> (<span class="r113 r">c</span> == <span class="s">&#39;:&#39;</span>)
						{
							<b>return</b> <span class="r112 r">ptr</span>;
						}
						<b>return</b> -1;
					}
					<span class="r112 r">ptr</span>++;
				}
			}
			<b>catch</b> (<a href="@0@mscorlib/A.html#acba961d918b2408" class="t t">IndexOutOfRangeException</a>)
			{
				<b>return</b> -1;
			}
		}

		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">summary</span><span class="c">&gt;</span><span class="c">Decode a buffer under UTF-8, if possible.</span><span class="c">&lt;/</span><span class="c">summary</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">remarks</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> Decode a buffer under UTF-8, if possible.</span>
		<span class="c">///</span><span class="c"> If the byte stream cannot be decoded that way, the platform default is tried</span>
		<span class="c">///</span><span class="c"> and if that too fails, the fail-safe ISO-8859-1 encoding is tried.</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;/</span><span class="c">remarks</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">param</span><span class="c"> </span><span class="c">name</span><span class="c">=</span><span class="c">&quot;</span><span class="r114 r">buffer</span><span class="c">&quot;</span><span class="c">&gt;</span><span class="c">buffer to pull raw bytes from.</span><span class="c">&lt;/</span><span class="c">param</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">returns</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> a string representation of the range </span><span class="c">&lt;</span><span class="c">code</span><span class="c">&gt;</span><span class="c">[start,end)</span><span class="c">&lt;/</span><span class="c">code</span><span class="c">&gt;</span><span class="c">,</span>
		<span class="c">///</span><span class="c"> after decoding the region through the specified character set.</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;/</span><span class="c">returns</span><span class="c">&gt;</span>
		<b>public static string</b> <a id="8bffa26c659156c0" href="../R/8bffa26c659156c0.html" target="n" data-glyph="72,1" class="i method">Decode</a>(<b>byte</b>[] <span id="r114 rd" class="r114 r">buffer</span>)
		{
			<b>return</b> <a href="#c23f18f826e9513e" class="i method">Decode</a>(<span class="r114 r">buffer</span>, 0, <span class="r114 r">buffer</span>.<a href="@0@mscorlib/A.html#42e9b7616956cf94" class="i property">Length</a>);
		}

		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">summary</span><span class="c">&gt;</span><span class="c">Decode a buffer under UTF-8, if possible.</span><span class="c">&lt;/</span><span class="c">summary</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">remarks</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> Decode a buffer under UTF-8, if possible.</span>
		<span class="c">///</span><span class="c"> If the byte stream cannot be decoded that way, the platform default is</span>
		<span class="c">///</span><span class="c"> tried and if that too fails, the fail-safe ISO-8859-1 encoding is tried.</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;/</span><span class="c">remarks</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">param</span><span class="c"> </span><span class="c">name</span><span class="c">=</span><span class="c">&quot;</span><span class="r115 r">buffer</span><span class="c">&quot;</span><span class="c">&gt;</span><span class="c">buffer to pull raw bytes from.</span><span class="c">&lt;/</span><span class="c">param</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">param</span><span class="c"> </span><span class="c">name</span><span class="c">=</span><span class="c">&quot;</span><span class="r116 r">start</span><span class="c">&quot;</span><span class="c">&gt;</span><span class="c">start position in buffer</span><span class="c">&lt;/</span><span class="c">param</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">param</span><span class="c"> </span><span class="c">name</span><span class="c">=</span><span class="c">&quot;</span><span class="r117 r">end</span><span class="c">&quot;</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> one position past the last location within the buffer to take</span>
		<span class="c">///</span><span class="c"> data from.</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;/</span><span class="c">param</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">returns</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> a string representation of the range </span><span class="c">&lt;</span><span class="c">code</span><span class="c">&gt;</span><span class="c">[start,end)</span><span class="c">&lt;/</span><span class="c">code</span><span class="c">&gt;</span><span class="c">,</span>
		<span class="c">///</span><span class="c"> after decoding the region through the specified character set.</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;/</span><span class="c">returns</span><span class="c">&gt;</span>
		<b>public static string</b> <a id="c23f18f826e9513e" href="../R/c23f18f826e9513e.html" target="n" data-glyph="72,1" class="i method">Decode</a>(<b>byte</b>[] <span id="r115 rd" class="r115 r">buffer</span>, <b>int</b> <span id="r116 rd" class="r116 r">start</span>, <b>int</b> <span id="r117 rd" class="r117 r">end</span>)
		{
			<b>return</b> <a href="#12db5ac2c9521321" class="i method">Decode</a>(<a href="../NGit/Constants.cs.html#71c965f28a6bcd51" class="t t">Constants</a>.<a href="../NGit/Constants.cs.html#cef92de5aff31da5" class="i field">CHARSET</a>, <span class="r115 r">buffer</span>, <span class="r116 r">start</span>, <span class="r117 r">end</span>);
		}

		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">summary</span><span class="c">&gt;</span><span class="c">Decode a buffer under the specified character set if possible.</span><span class="c">&lt;/</span><span class="c">summary</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">remarks</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> Decode a buffer under the specified character set if possible.</span>
		<span class="c">///</span><span class="c"> If the byte stream cannot be decoded that way, the platform default is tried</span>
		<span class="c">///</span><span class="c"> and if that too fails, the fail-safe ISO-8859-1 encoding is tried.</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;/</span><span class="c">remarks</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">param</span><span class="c"> </span><span class="c">name</span><span class="c">=</span><span class="c">&quot;</span><span class="r118 r">cs</span><span class="c">&quot;</span><span class="c">&gt;</span><span class="c">character set to use when decoding the buffer.</span><span class="c">&lt;/</span><span class="c">param</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">param</span><span class="c"> </span><span class="c">name</span><span class="c">=</span><span class="c">&quot;</span><span class="r119 r">buffer</span><span class="c">&quot;</span><span class="c">&gt;</span><span class="c">buffer to pull raw bytes from.</span><span class="c">&lt;/</span><span class="c">param</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">returns</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> a string representation of the range </span><span class="c">&lt;</span><span class="c">code</span><span class="c">&gt;</span><span class="c">[start,end)</span><span class="c">&lt;/</span><span class="c">code</span><span class="c">&gt;</span><span class="c">,</span>
		<span class="c">///</span><span class="c"> after decoding the region through the specified character set.</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;/</span><span class="c">returns</span><span class="c">&gt;</span>
		<b>public static string</b> <a id="dd21ebe6fef8efc2" href="../R/dd21ebe6fef8efc2.html" target="n" data-glyph="72,1" class="i method">Decode</a>(<span class="i n">System</span>.<span class="i n">Text</span>.<a href="@0@mscorlib/A.html#3b6090c501893c25" class="t t">Encoding</a> <span id="r118 rd" class="r118 r">cs</span>, <b>byte</b>[] <span id="r119 rd" class="r119 r">buffer</span>)
		{
			<b>return</b> <a href="#12db5ac2c9521321" class="i method">Decode</a>(<span class="r118 r">cs</span>, <span class="r119 r">buffer</span>, 0, <span class="r119 r">buffer</span>.<a href="@0@mscorlib/A.html#42e9b7616956cf94" class="i property">Length</a>);
		}

		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">summary</span><span class="c">&gt;</span><span class="c">Decode a region of the buffer under the specified character set if possible.</span>
		<span class="c">///</span><span class="c"> 	</span><span class="c">&lt;/</span><span class="c">summary</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">remarks</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> Decode a region of the buffer under the specified character set if possible.</span>
		<span class="c">///</span><span class="c"> If the byte stream cannot be decoded that way, the platform default is tried</span>
		<span class="c">///</span><span class="c"> and if that too fails, the fail-safe ISO-8859-1 encoding is tried.</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;/</span><span class="c">remarks</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">param</span><span class="c"> </span><span class="c">name</span><span class="c">=</span><span class="c">&quot;</span><span class="r120 r">cs</span><span class="c">&quot;</span><span class="c">&gt;</span><span class="c">character set to use when decoding the buffer.</span><span class="c">&lt;/</span><span class="c">param</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">param</span><span class="c"> </span><span class="c">name</span><span class="c">=</span><span class="c">&quot;</span><span class="r121 r">buffer</span><span class="c">&quot;</span><span class="c">&gt;</span><span class="c">buffer to pull raw bytes from.</span><span class="c">&lt;/</span><span class="c">param</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">param</span><span class="c"> </span><span class="c">name</span><span class="c">=</span><span class="c">&quot;</span><span class="r122 r">start</span><span class="c">&quot;</span><span class="c">&gt;</span><span class="c">first position within the buffer to take data from.</span><span class="c">&lt;/</span><span class="c">param</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">param</span><span class="c"> </span><span class="c">name</span><span class="c">=</span><span class="c">&quot;</span><span class="r123 r">end</span><span class="c">&quot;</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> one position past the last location within the buffer to take</span>
		<span class="c">///</span><span class="c"> data from.</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;/</span><span class="c">param</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">returns</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> a string representation of the range </span><span class="c">&lt;</span><span class="c">code</span><span class="c">&gt;</span><span class="c">[start,end)</span><span class="c">&lt;/</span><span class="c">code</span><span class="c">&gt;</span><span class="c">,</span>
		<span class="c">///</span><span class="c"> after decoding the region through the specified character set.</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;/</span><span class="c">returns</span><span class="c">&gt;</span>
		<b>public static string</b> <a id="12db5ac2c9521321" href="../R/12db5ac2c9521321.html" target="n" data-glyph="72,1" class="i method">Decode</a>(<span class="i n">System</span>.<span class="i n">Text</span>.<a href="@0@mscorlib/A.html#3b6090c501893c25" class="t t">Encoding</a> <span id="r120 rd" class="r120 r">cs</span>, <b>byte</b>[] <span id="r121 rd" class="r121 r">buffer</span>, <b>int</b> <span id="r122 rd" class="r122 r">start</span>, <b>int</b>
			 <span id="r123 rd" class="r123 r">end</span>)
		{
			<b>try</b>
			{
				<b>return</b> <a href="#354897319bc0de1e" class="i method">DecodeNoFallback</a>(<span class="r120 r">cs</span>, <span class="r121 r">buffer</span>, <span class="r122 r">start</span>, <span class="r123 r">end</span>);
			}
			<b>catch</b> (<a href="/Sharpen/A.html#11fde9fcd52e3930" class="t t">CharacterCodingException</a>)
			{
				<span class="c">// Fall back to an ISO-8859-1 style encoding. At least all of</span>
				<span class="c">// the bytes will be present in the output.</span>
				<span class="c">//</span>
				<b>return</b> <a href="#28ebb391c16667c6" class="i method">ExtractBinaryString</a>(<span class="r121 r">buffer</span>, <span class="r122 r">start</span>, <span class="r123 r">end</span>);
			}
		}

		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">summary</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> Decode a region of the buffer under the specified character set if</span>
		<span class="c">///</span><span class="c"> possible.</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;/</span><span class="c">summary</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">remarks</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> Decode a region of the buffer under the specified character set if</span>
		<span class="c">///</span><span class="c"> possible.</span>
		<span class="c">///</span><span class="c"> If the byte stream cannot be decoded that way, the platform default is</span>
		<span class="c">///</span><span class="c"> tried and if that too fails, an exception is thrown.</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;/</span><span class="c">remarks</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">param</span><span class="c"> </span><span class="c">name</span><span class="c">=</span><span class="c">&quot;</span><span class="r124 r">cs</span><span class="c">&quot;</span><span class="c">&gt;</span><span class="c">character set to use when decoding the buffer.</span><span class="c">&lt;/</span><span class="c">param</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">param</span><span class="c"> </span><span class="c">name</span><span class="c">=</span><span class="c">&quot;</span><span class="r125 r">buffer</span><span class="c">&quot;</span><span class="c">&gt;</span><span class="c">buffer to pull raw bytes from.</span><span class="c">&lt;/</span><span class="c">param</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">param</span><span class="c"> </span><span class="c">name</span><span class="c">=</span><span class="c">&quot;</span><span class="r126 r">start</span><span class="c">&quot;</span><span class="c">&gt;</span><span class="c">first position within the buffer to take data from.</span><span class="c">&lt;/</span><span class="c">param</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">param</span><span class="c"> </span><span class="c">name</span><span class="c">=</span><span class="c">&quot;</span><span class="r127 r">end</span><span class="c">&quot;</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> one position past the last location within the buffer to take</span>
		<span class="c">///</span><span class="c"> data from.</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;/</span><span class="c">param</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">returns</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> a string representation of the range </span><span class="c">&lt;</span><span class="c">code</span><span class="c">&gt;</span><span class="c">[start,end)</span><span class="c">&lt;/</span><span class="c">code</span><span class="c">&gt;</span><span class="c">,</span>
		<span class="c">///</span><span class="c"> after decoding the region through the specified character set.</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;/</span><span class="c">returns</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">exception</span><span class="c"> </span><span class="c">cref</span><span class="c">=</span><span class="c">&quot;</span><span class="i n">Sharpen</span>.<a href="/Sharpen/A.html#11fde9fcd52e3930" class="t t">CharacterCodingException</a><span class="c">&quot;</span><span class="c">&gt;</span><span class="c">the input is not in any of the tested character sets.</span>
		<span class="c">///</span><span class="c"> 	</span><span class="c">&lt;/</span><span class="c">exception</span><span class="c">&gt;</span>
		<b>public static string</b> <a id="354897319bc0de1e" href="../R/354897319bc0de1e.html" target="n" data-glyph="72,1" class="i method">DecodeNoFallback</a>(<span class="i n">System</span>.<span class="i n">Text</span>.<a href="@0@mscorlib/A.html#3b6090c501893c25" class="t t">Encoding</a> <span id="r124 rd" class="r124 r">cs</span>, <b>byte</b>[] <span id="r125 rd" class="r125 r">buffer</span>, <b>int</b>
			 <span id="r126 rd" class="r126 r">start</span>, <b>int</b> <span id="r127 rd" class="r127 r">end</span>)
		{
			<a href="/Sharpen/A.html#acd2106f2585deaa" class="t t">ByteBuffer</a> <span id="r128 rd" class="r128 r">b</span> = <a href="/Sharpen/A.html#acd2106f2585deaa" class="t t">ByteBuffer</a>.<a href="/Sharpen/A.html#b6b67e57f05085e3" class="i method">Wrap</a>(<span class="r125 r">buffer</span>, <span class="r126 r">start</span>, <span class="r127 r">end</span> - <span class="r126 r">start</span>);
			<span class="r128 r">b</span>.<a href="/Sharpen/A.html#699ea903fbe5d68d" class="i method">Mark</a>();
			<span class="c">// Try our built-in favorite. The assumption here is that</span>
			<span class="c">// decoding will fail if the data is not actually encoded</span>
			<span class="c">// using that encoder.</span>
			<span class="c">//</span>
			<b>try</b>
			{
				<b>return</b> <a href="#b0cce0e27cd5f64f" class="i method">Decode</a>(<span class="r128 r">b</span>, <a href="../NGit/Constants.cs.html#71c965f28a6bcd51" class="t t">Constants</a>.<a href="../NGit/Constants.cs.html#cef92de5aff31da5" class="i field">CHARSET</a>);
			}
			<b>catch</b> (<a href="/Sharpen/A.html#11fde9fcd52e3930" class="t t">CharacterCodingException</a>)
			{
				<span class="r128 r">b</span>.<a href="/Sharpen/A.html#64f833959212e98a" class="i method">Reset</a>();
			}
			<b>if</b> (!<span class="r124 r">cs</span>.<a href="@0@mscorlib/A.html#5a3af98b30ba1b48" class="i method">Equals</a>(<a href="../NGit/Constants.cs.html#71c965f28a6bcd51" class="t t">Constants</a>.<a href="../NGit/Constants.cs.html#cef92de5aff31da5" class="i field">CHARSET</a>))
			{
				<span class="c">// Try the suggested encoding, it might be right since it was</span>
				<span class="c">// provided by the caller.</span>
				<span class="c">//</span>
				<b>try</b>
				{
					<b>return</b> <a href="#b0cce0e27cd5f64f" class="i method">Decode</a>(<span class="r128 r">b</span>, <span class="r124 r">cs</span>);
				}
				<b>catch</b> (<a href="/Sharpen/A.html#11fde9fcd52e3930" class="t t">CharacterCodingException</a>)
				{
					<span class="r128 r">b</span>.<a href="/Sharpen/A.html#64f833959212e98a" class="i method">Reset</a>();
				}
			}
			<span class="c">// Try the default character set. A small group of people</span>
			<span class="c">// might actually use the same (or very similar) locale.</span>
			<span class="c">//</span>
			<span class="i n">System</span>.<span class="i n">Text</span>.<a href="@0@mscorlib/A.html#3b6090c501893c25" class="t t">Encoding</a> <span id="r129 rd" class="r129 r">defcs</span> = <span class="i n">System</span>.<span class="i n">Text</span>.<a href="@0@mscorlib/A.html#3b6090c501893c25" class="t t">Encoding</a>.<a href="@0@mscorlib/A.html#1c75de327ad88c0a" class="i property">Default</a>;
			<b>if</b> (!<span class="r129 r">defcs</span>.<a href="@0@mscorlib/A.html#5a3af98b30ba1b48" class="i method">Equals</a>(<span class="r124 r">cs</span>) &amp;&amp; !<span class="r129 r">defcs</span>.<a href="@0@mscorlib/A.html#5a3af98b30ba1b48" class="i method">Equals</a>(<a href="../NGit/Constants.cs.html#71c965f28a6bcd51" class="t t">Constants</a>.<a href="../NGit/Constants.cs.html#cef92de5aff31da5" class="i field">CHARSET</a>))
			{
				<b>try</b>
				{
					<b>return</b> <a href="#b0cce0e27cd5f64f" class="i method">Decode</a>(<span class="r128 r">b</span>, <span class="r129 r">defcs</span>);
				}
				<b>catch</b> (<a href="/Sharpen/A.html#11fde9fcd52e3930" class="t t">CharacterCodingException</a>)
				{
					<span class="r128 r">b</span>.<a href="/Sharpen/A.html#64f833959212e98a" class="i method">Reset</a>();
				}
			}
			<b>throw</b> <b>new</b> <a href="/Sharpen/A.html#11fde9fcd52e3930" class="t constructor">CharacterCodingException</a>();
		}

		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">summary</span><span class="c">&gt;</span><span class="c">Decode a region of the buffer under the ISO-8859-1 encoding.</span><span class="c">&lt;/</span><span class="c">summary</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">remarks</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> Decode a region of the buffer under the ISO-8859-1 encoding.</span>
		<span class="c">///</span><span class="c"> Each byte is treated as a single character in the 8859-1 character</span>
		<span class="c">///</span><span class="c"> encoding, performing a raw binary-</span><span class="c">&amp;gt;</span><span class="c">char conversion.</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;/</span><span class="c">remarks</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">param</span><span class="c"> </span><span class="c">name</span><span class="c">=</span><span class="c">&quot;</span><span class="r130 r">buffer</span><span class="c">&quot;</span><span class="c">&gt;</span><span class="c">buffer to pull raw bytes from.</span><span class="c">&lt;/</span><span class="c">param</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">param</span><span class="c"> </span><span class="c">name</span><span class="c">=</span><span class="c">&quot;</span><span class="r131 r">start</span><span class="c">&quot;</span><span class="c">&gt;</span><span class="c">first position within the buffer to take data from.</span><span class="c">&lt;/</span><span class="c">param</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">param</span><span class="c"> </span><span class="c">name</span><span class="c">=</span><span class="c">&quot;</span><span class="r132 r">end</span><span class="c">&quot;</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> one position past the last location within the buffer to take</span>
		<span class="c">///</span><span class="c"> data from.</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;/</span><span class="c">param</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">returns</span><span class="c">&gt;</span><span class="c">a string representation of the range </span><span class="c">&lt;</span><span class="c">code</span><span class="c">&gt;</span><span class="c">[start,end)</span><span class="c">&lt;/</span><span class="c">code</span><span class="c">&gt;</span><span class="c">.</span><span class="c">&lt;/</span><span class="c">returns</span><span class="c">&gt;</span>
		<b>public static string</b> <a id="28ebb391c16667c6" href="../R/28ebb391c16667c6.html" target="n" data-glyph="72,1" class="i method">ExtractBinaryString</a>(<b>byte</b>[] <span id="r130 rd" class="r130 r">buffer</span>, <b>int</b> <span id="r131 rd" class="r131 r">start</span>, <b>int</b> <span id="r132 rd" class="r132 r">end</span>)
		{
			<a href="@0@mscorlib/A.html#adf60ee46ebd299f" class="t t">StringBuilder</a> <span id="r133 rd" class="r133 r">r</span> = <b>new</b> <a href="@0@mscorlib/A.html#ec674e2123a44860" class="t constructor">StringBuilder</a>(<span class="r132 r">end</span> - <span class="r131 r">start</span>);
			<b>for</b> (<b>int</b> <span id="r134 rd" class="r134 r">i</span> = <span class="r131 r">start</span>; <span class="r134 r">i</span> &lt; <span class="r132 r">end</span>; <span class="r134 r">i</span>++)
			{
				<span class="r133 r">r</span>.<a href="@0@mscorlib/A.html#a2e7c78d85807da5" class="i method">Append</a>((<b>char</b>)(<span class="r130 r">buffer</span>[<span class="r134 r">i</span>] &amp; <b>unchecked</b>((<b>int</b>)(0xff))));
			}
			<b>return</b> <span class="r133 r">r</span>.<a href="@0@mscorlib/A.html#5a97da49a158a3c9" class="i method">ToString</a>();
		}

		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">exception</span><span class="c"> </span><span class="c">cref</span><span class="c">=</span><span class="c">&quot;</span><span class="i n">Sharpen</span>.<a href="/Sharpen/A.html#11fde9fcd52e3930" class="t t">CharacterCodingException</a><span class="c">&quot;</span><span class="c">&gt;</span><span class="c">&lt;/</span><span class="c">exception</span><span class="c">&gt;</span>
		<b>private static string</b> <a id="b0cce0e27cd5f64f" href="../R/b0cce0e27cd5f64f.html" target="n" data-glyph="76,1" class="i method">Decode</a>(<a href="/Sharpen/A.html#acd2106f2585deaa" class="t t">ByteBuffer</a> <span id="r135 rd" class="r135 r">b</span>, <span class="i n">System</span>.<span class="i n">Text</span>.<a href="@0@mscorlib/A.html#3b6090c501893c25" class="t t">Encoding</a> <span id="r136 rd" class="r136 r">charset</span>)
		{
			<a href="/Sharpen/A.html#873801b965d6aa23" class="t t">CharsetDecoder</a> <span id="r137 rd" class="r137 r">d</span> = <span class="r136 r">charset</span>.<a href="/Sharpen/A.html#076c5c3b46fb6de7" class="i method">NewDecoder</a>();
			<span class="r137 r">d</span>.<a href="/Sharpen/A.html#87fbd0192f7ee6eb" class="i method">OnMalformedInput</a>(<a href="/Sharpen/A.html#56f607f91fb06a51" class="t t">CodingErrorAction</a>.<a href="/Sharpen/A.html#9595081479495df7" class="i field">REPORT</a>);
			<span class="r137 r">d</span>.<a href="/Sharpen/A.html#fc5cf35ebffabc1f" class="i method">OnUnmappableCharacter</a>(<a href="/Sharpen/A.html#56f607f91fb06a51" class="t t">CodingErrorAction</a>.<a href="/Sharpen/A.html#9595081479495df7" class="i field">REPORT</a>);
			<b>return</b> <span class="r137 r">d</span>.<a href="/Sharpen/A.html#de93c12513b70c65" class="i method">Decode</a>(<span class="r135 r">b</span>).<a href="@0@mscorlib/A.html#efa5e6c14683e022" class="i method">ToString</a>();
		}

		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">summary</span><span class="c">&gt;</span><span class="c">Locate the position of the commit message body.</span><span class="c">&lt;/</span><span class="c">summary</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">remarks</span><span class="c">&gt;</span><span class="c">Locate the position of the commit message body.</span><span class="c">&lt;/</span><span class="c">remarks</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">param</span><span class="c"> </span><span class="c">name</span><span class="c">=</span><span class="c">&quot;</span><span class="r138 r">b</span><span class="c">&quot;</span><span class="c">&gt;</span><span class="c">buffer to scan.</span><span class="c">&lt;/</span><span class="c">param</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">param</span><span class="c"> </span><span class="c">name</span><span class="c">=</span><span class="c">&quot;</span><span class="r139 r">ptr</span><span class="c">&quot;</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> position in buffer to start the scan at. Most callers should</span>
		<span class="c">///</span><span class="c"> pass 0 to ensure the scan starts from the beginning of the</span>
		<span class="c">///</span><span class="c"> commit buffer.</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;/</span><span class="c">param</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">returns</span><span class="c">&gt;</span><span class="c">position of the user&#39;s message buffer.</span><span class="c">&lt;/</span><span class="c">returns</span><span class="c">&gt;</span>
		<b>public static int</b> <a id="ca0e4c90f61ebf79" href="../R/ca0e4c90f61ebf79.html" target="n" data-glyph="72,1" class="i method">CommitMessage</a>(<b>byte</b>[] <span id="r138 rd" class="r138 r">b</span>, <b>int</b> <span id="r139 rd" class="r139 r">ptr</span>)
		{
			<b>int</b> <span id="r140 rd" class="r140 r">sz</span> = <span class="r138 r">b</span>.<a href="@0@mscorlib/A.html#42e9b7616956cf94" class="i property">Length</a>;
			<b>if</b> (<span class="r139 r">ptr</span> == 0)
			{
				<span class="r139 r">ptr</span> += 46;
			}
			<span class="c">// skip the &quot;tree ...&quot; line.</span>
			<b>while</b> (<span class="r139 r">ptr</span> &lt; <span class="r140 r">sz</span> &amp;&amp; <span class="r138 r">b</span>[<span class="r139 r">ptr</span>] == <span class="s">&#39;p&#39;</span>)
			{
				<span class="r139 r">ptr</span> += 48;
			}
			<span class="c">// skip this parent.</span>
			<span class="c">// Skip any remaining header lines, ignoring what their actual</span>
			<span class="c">// header line type is. This is identical to the logic for a tag.</span>
			<span class="c">//</span>
			<b>return</b> <a href="#f31a7692670d8ee2" class="i method">TagMessage</a>(<span class="r138 r">b</span>, <span class="r139 r">ptr</span>);
		}

		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">summary</span><span class="c">&gt;</span><span class="c">Locate the position of the tag message body.</span><span class="c">&lt;/</span><span class="c">summary</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">remarks</span><span class="c">&gt;</span><span class="c">Locate the position of the tag message body.</span><span class="c">&lt;/</span><span class="c">remarks</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">param</span><span class="c"> </span><span class="c">name</span><span class="c">=</span><span class="c">&quot;</span><span class="r141 r">b</span><span class="c">&quot;</span><span class="c">&gt;</span><span class="c">buffer to scan.</span><span class="c">&lt;/</span><span class="c">param</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">param</span><span class="c"> </span><span class="c">name</span><span class="c">=</span><span class="c">&quot;</span><span class="r142 r">ptr</span><span class="c">&quot;</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> position in buffer to start the scan at. Most callers should</span>
		<span class="c">///</span><span class="c"> pass 0 to ensure the scan starts from the beginning of the tag</span>
		<span class="c">///</span><span class="c"> buffer.</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;/</span><span class="c">param</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">returns</span><span class="c">&gt;</span><span class="c">position of the user&#39;s message buffer.</span><span class="c">&lt;/</span><span class="c">returns</span><span class="c">&gt;</span>
		<b>public static int</b> <a id="f31a7692670d8ee2" href="../R/f31a7692670d8ee2.html" target="n" data-glyph="72,1" class="i method">TagMessage</a>(<b>byte</b>[] <span id="r141 rd" class="r141 r">b</span>, <b>int</b> <span id="r142 rd" class="r142 r">ptr</span>)
		{
			<b>int</b> <span id="r143 rd" class="r143 r">sz</span> = <span class="r141 r">b</span>.<a href="@0@mscorlib/A.html#42e9b7616956cf94" class="i property">Length</a>;
			<b>if</b> (<span class="r142 r">ptr</span> == 0)
			{
				<span class="r142 r">ptr</span> += 48;
			}
			<span class="c">// skip the &quot;object ...&quot; line.</span>
			<b>while</b> (<span class="r142 r">ptr</span> &lt; <span class="r143 r">sz</span> &amp;&amp; <span class="r141 r">b</span>[<span class="r142 r">ptr</span>] != <span class="s">&#39;\n&#39;</span>)
			{
				<span class="r142 r">ptr</span> = <a href="#162ee2e46b60d416" class="i method">NextLF</a>(<span class="r141 r">b</span>, <span class="r142 r">ptr</span>);
			}
			<b>if</b> (<span class="r142 r">ptr</span> &lt; <span class="r143 r">sz</span> &amp;&amp; <span class="r141 r">b</span>[<span class="r142 r">ptr</span>] == <span class="s">&#39;\n&#39;</span>)
			{
				<b>return</b> <span class="r142 r">ptr</span> + 1;
			}
			<b>return</b> -1;
		}

		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">summary</span><span class="c">&gt;</span><span class="c">Locate the end of a paragraph.</span><span class="c">&lt;/</span><span class="c">summary</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">remarks</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> Locate the end of a paragraph.</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">p</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> A paragraph is ended by two consecutive LF bytes.</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;/</span><span class="c">remarks</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">param</span><span class="c"> </span><span class="c">name</span><span class="c">=</span><span class="c">&quot;</span><span class="r144 r">b</span><span class="c">&quot;</span><span class="c">&gt;</span><span class="c">buffer to scan.</span><span class="c">&lt;/</span><span class="c">param</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">param</span><span class="c"> </span><span class="c">name</span><span class="c">=</span><span class="c">&quot;</span><span class="r145 r">start</span><span class="c">&quot;</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> position in buffer to start the scan at. Most callers will</span>
		<span class="c">///</span><span class="c"> want to pass the first position of the commit message (as</span>
		<span class="c">///</span><span class="c"> found by</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">see</span><span class="c"> </span><span class="c">cref</span><span class="c">=</span><span class="c">&quot;</span><a href="#ca0e4c90f61ebf79" class="i method">CommitMessage</a>(<b>byte</b>[], <b>int</b>)<span class="c">&quot;</span><span class="c">&gt;</span><span class="c">CommitMessage(byte[], int)</span><span class="c">&lt;/</span><span class="c">see</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> .</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;/</span><span class="c">param</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">returns</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> position of the LF at the end of the paragraph;</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">code</span><span class="c">&gt;</span><span class="c">b.length</span><span class="c">&lt;/</span><span class="c">code</span><span class="c">&gt;</span><span class="c"> if no paragraph end could be located.</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;/</span><span class="c">returns</span><span class="c">&gt;</span>
		<b>public static int</b> <a id="e4f57a4f9d3c3512" href="../R/e4f57a4f9d3c3512.html" target="n" data-glyph="72,1" class="i method">EndOfParagraph</a>(<b>byte</b>[] <span id="r144 rd" class="r144 r">b</span>, <b>int</b> <span id="r145 rd" class="r145 r">start</span>)
		{
			<b>int</b> <span id="r146 rd" class="r146 r">ptr</span> = <span class="r145 r">start</span>;
			<b>int</b> <span id="r147 rd" class="r147 r">sz</span> = <span class="r144 r">b</span>.<a href="@0@mscorlib/A.html#42e9b7616956cf94" class="i property">Length</a>;
			<b>while</b> (<span class="r146 r">ptr</span> &lt; <span class="r147 r">sz</span> &amp;&amp; <span class="r144 r">b</span>[<span class="r146 r">ptr</span>] != <span class="s">&#39;\n&#39;</span>)
			{
				<span class="r146 r">ptr</span> = <a href="#162ee2e46b60d416" class="i method">NextLF</a>(<span class="r144 r">b</span>, <span class="r146 r">ptr</span>);
			}
			<b>while</b> (0 &lt; <span class="r146 r">ptr</span> &amp;&amp; <span class="r145 r">start</span> &lt; <span class="r146 r">ptr</span> &amp;&amp; <span class="r144 r">b</span>[<span class="r146 r">ptr</span> - 1] == <span class="s">&#39;\n&#39;</span>)
			{
				<span class="r146 r">ptr</span>--;
			}
			<b>return</b> <span class="r146 r">ptr</span>;
		}

		<b>private static int</b> <a id="15a3cc582e541f76" href="../R/15a3cc582e541f76.html" target="n" data-glyph="76,1" class="i method">LastIndexOfTrim</a>(<b>byte</b>[] <span id="r148 rd" class="r148 r">raw</span>, <b>char</b> <span id="r149 rd" class="r149 r">ch</span>, <b>int</b> <span id="r150 rd" class="r150 r">pos</span>)
		{
			<b>while</b> (<span class="r150 r">pos</span> &gt;= 0 &amp;&amp; <span class="r148 r">raw</span>[<span class="r150 r">pos</span>] == <span class="s">&#39; &#39;</span>)
			{
				<span class="r150 r">pos</span>--;
			}
			<b>while</b> (<span class="r150 r">pos</span> &gt;= 0 &amp;&amp; <span class="r148 r">raw</span>[<span class="r150 r">pos</span>] != <span class="r149 r">ch</span>)
			{
				<span class="r150 r">pos</span>--;
			}
			<b>return</b> <span class="r150 r">pos</span>;
		}

		<b>private static</b> <span class="i n">System</span>.<span class="i n">Text</span>.<a href="@0@mscorlib/A.html#3b6090c501893c25" class="t t">Encoding</a> <a id="6418685fff380ff6" href="../R/6418685fff380ff6.html" target="n" data-glyph="76,1" class="i method">CharsetForAlias</a>(<b>string</b> <span id="r151 rd" class="r151 r">name</span>)
		{
			<b>return</b> <a href="#ff411770f2744297" class="i field">encodingAliases</a>.<a href="/Sharpen/A.html#7e18f8a78566330c" class="i method">Get</a>(<a href="StringUtils.cs.html#8d28d856f5ddd6fb" class="t t">StringUtils</a>.<a href="StringUtils.cs.html#eae3f6b42bc7872c" class="i method">ToLowerCase</a>(<span class="r151 r">name</span>));
		}

		<b>public</b> <a id="5f6af9878eb6e0c6" href="../R/../../0000000000.html" target="n" data-glyph="72,1" class="i constructor">RawParseUtils</a>()
		{
		}
		<span class="c">// Don&#39;t create instances of a static only utility.</span>
	}
}
</pre></td></tr></table></div></body></html>
