<!DOCTYPE html>
<html><head><title>RawParseUtils.cs</title><link rel="stylesheet" href="../../styles.css"><script src="../../scripts.js"></script></head>
<body class="cB" onload="i(1057);"><div class="dH">
<table style="width: 100%">
<tr><td>File: <a id="filePath" class="blueLink" href="/#GitSharp.Core/Util/RawParseUtils.cs" target="_top">Util\RawParseUtils.cs</a><br/></td><td></td></tr>
<tr><td>Project: <a id="projectPath" class="blueLink" href="/#GitSharp.Core" target="_top">lib\GitSharp\GitSharp.Core\GitSharp.Core.csproj</a> (GitSharp.Core)</td><td></td></tr>
</table>
</div>
<div class="cz"><table class="tb" cellpadding="0" cellspacing="0"><tr><td valign="top" align="right"><pre id="ln"></pre></td><td valign="top" align="left"><pre id="code">
<span class="c">/*
 * Copyright (C) 2008, Shawn O. Pearce &lt;spearce@spearce.org&gt;
 * Copyright (C) 2008, Kevin Thompson &lt;kevin.thompson@theautomaters.com&gt;
 * Copyright (C) 2009, Henon &lt;meinrad.recheis@gmail.com&gt;
 * Copyright (C) 2009, Gil Ran &lt;gilrun@gmail.com&gt;
 * 
 *
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or
 * without modification, are permitted provided that the following
 * conditions are met:
 *
 * - Redistributions of source code must retain the above copyright
 *   notice, this list of conditions and the following disclaimer.
 *
 * - Redistributions in binary form must reproduce the above
 *   copyright notice, this list of conditions and the following
 *   disclaimer in the documentation and/or other materials provided
 *   with the distribution.
 *
 * - Neither the name of the Git Development Community nor the
 *   names of its contributors may be used to endorse or promote
 *   products derived from this software without specific prior
 *   written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND
 * CONTRIBUTORS &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */</span>

<b>using</b> <span class="i n">System</span>;
<b>using</b> <span class="i n">System</span>.<span class="i n">Text</span>;
<b>using</b> <span class="i n">GitSharp</span>.<span class="i n">Core</span>.<span class="i n">Util</span>.<span class="i n">JavaHelper</span>;

<b>namespace</b> <span class="i n">GitSharp</span>.<span class="i n">Core</span>.<span class="i n">Util</span>
{
	<b>public static class</b> <a id="9c316fb813def011" href="../R/9c316fb813def011.html" target="n" data-glyph="0,0" class="t t">RawParseUtils</a>
	{
		<b>private static readonly byte</b>[] <a id="ff6a954e6db9723a" href="../R/ff6a954e6db9723a.html" target="n" data-glyph="46,1" class="i field">footerLineKeyChars</a> = <a href="#e82a81796429ac9f" class="i method">GenerateFooterLineKeyChars</a>();
		<b>private static readonly byte</b>[] <a id="849af5115d8ac8d4" href="../R/849af5115d8ac8d4.html" target="n" data-glyph="46,1" class="i field">Base10Byte</a> = { (<b>byte</b>)<span class="s">&#39;0&#39;</span>, (<b>byte</b>)<span class="s">&#39;1&#39;</span>, (<b>byte</b>)<span class="s">&#39;2&#39;</span>, (<b>byte</b>)<span class="s">&#39;3&#39;</span>, (<b>byte</b>)<span class="s">&#39;4&#39;</span>, (<b>byte</b>)<span class="s">&#39;5&#39;</span>, (<b>byte</b>)<span class="s">&#39;6&#39;</span>, (<b>byte</b>)<span class="s">&#39;7&#39;</span>, (<b>byte</b>)<span class="s">&#39;8&#39;</span>, (<b>byte</b>)<span class="s">&#39;9&#39;</span> };

		<b>private static byte</b>[] <a id="e82a81796429ac9f" href="../R/e82a81796429ac9f.html" target="n" data-glyph="76,1" class="i method">GenerateFooterLineKeyChars</a>()
		{
			<b>var</b> <span id="r0 rd" class="r0 r">footerLineKeyChars</span> = <b>new</b> <b>byte</b>[(<b>byte</b>)<span class="s">&#39;z&#39;</span> + 1];
			<span class="r0 r">footerLineKeyChars</span>[(<b>byte</b>)<span class="s">&#39;-&#39;</span>] = 1;

			<b>for</b> (<b>char</b> <span id="r1 rd" class="r1 r">i</span> = <span class="s">&#39;0&#39;</span>; <span class="r1 r">i</span> &lt;= <span class="s">&#39;9&#39;</span>; <span class="r1 r">i</span>++)
			{
				<span class="r0 r">footerLineKeyChars</span>[<span class="r1 r">i</span>] = 1;
			}

			<b>for</b> (<b>char</b> <span id="r2 rd" class="r2 r">i</span> = <span class="s">&#39;A&#39;</span>; <span class="r2 r">i</span> &lt;= <span class="s">&#39;Z&#39;</span>; <span class="r2 r">i</span>++)
			{
				<span class="r0 r">footerLineKeyChars</span>[<span class="r2 r">i</span>] = 1;
			}

			<b>for</b> (<b>char</b> <span id="r3 rd" class="r3 r">i</span> = <span class="s">&#39;a&#39;</span>; <span class="r3 r">i</span> &lt;= <span class="s">&#39;z&#39;</span>; <span class="r3 r">i</span>++)
			{
				<span class="r0 r">footerLineKeyChars</span>[<span class="r3 r">i</span>] = 1;
			}

			<b>return</b> <span class="r0 r">footerLineKeyChars</span>;
		}

		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">summary</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> Determine if b[ptr] matches src.</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;/</span><span class="c">summary</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">param</span><span class="c"> </span><span class="c">name</span><span class="c">=</span><span class="c">&quot;</span><span class="r4 r">b</span><span class="c">&quot;</span><span class="c">&gt;</span><span class="c">the buffer to scan.</span><span class="c">&lt;/</span><span class="c">param</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">param</span><span class="c"> </span><span class="c">name</span><span class="c">=</span><span class="c">&quot;</span><span class="r5 r">ptr</span><span class="c">&quot;</span><span class="c">&gt;</span><span class="c">first position within b, this should match src[0].</span><span class="c">&lt;/</span><span class="c">param</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">param</span><span class="c"> </span><span class="c">name</span><span class="c">=</span><span class="c">&quot;</span><span class="r6 r">src</span><span class="c">&quot;</span><span class="c">&gt;</span><span class="c">the buffer to test for equality with b.</span><span class="c">&lt;/</span><span class="c">param</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">returns</span><span class="c">&gt;</span><span class="c">ptr + src.Length if b[ptr..src.Length] == src; else -1.</span><span class="c">&lt;/</span><span class="c">returns</span><span class="c">&gt;</span>
		<b>public static int</b> <a id="8d5e78f7413720c3" href="../R/8d5e78f7413720c3.html" target="n" data-glyph="72,1" class="i method">match</a>(<b>byte</b>[] <span id="r4 rd" class="r4 r">b</span>, <b>int</b> <span id="r5 rd" class="r5 r">ptr</span>, <b>byte</b>[] <span id="r6 rd" class="r6 r">src</span>)
		{
			<b>if</b> (<span class="r5 r">ptr</span> + <span class="r6 r">src</span>.<a href="@0@mscorlib/A.html#42e9b7616956cf94" class="i property">Length</a> &gt; <span class="r4 r">b</span>.<a href="@0@mscorlib/A.html#42e9b7616956cf94" class="i property">Length</a>)
			{
				<b>return</b> -1;
			}

			<b>for</b> (<b>int</b> <span id="r7 rd" class="r7 r">i</span> = 0; <span class="r7 r">i</span> &lt; <span class="r6 r">src</span>.<a href="@0@mscorlib/A.html#42e9b7616956cf94" class="i property">Length</a>; <span class="r7 r">i</span>++, <span class="r5 r">ptr</span>++)
			{
				<b>if</b> (<span class="r4 r">b</span>[<span class="r5 r">ptr</span>] != <span class="r6 r">src</span>[<span class="r7 r">i</span>])
				{
					<b>return</b> -1;
				}
			}

			<b>return</b> <span class="r5 r">ptr</span>;
		}

		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">summary</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> Format a base 10 numeric into a temporary buffer.</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">para</span><span class="c"> </span><span class="c">/&gt;</span>
		<span class="c">///</span><span class="c"> Formatting is performed backwards. The method starts at offset</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">code</span><span class="c">&gt;</span><span class="c">o-1</span><span class="c">&lt;/</span><span class="c">code</span><span class="c">&gt;</span><span class="c"> and ends at </span><span class="c">&lt;</span><span class="c">code</span><span class="c">&gt;</span><span class="c">o-1-digits</span><span class="c">&lt;/</span><span class="c">code</span><span class="c">&gt;</span><span class="c">, where</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">code</span><span class="c">&gt;</span><span class="c">digits</span><span class="c">&lt;/</span><span class="c">code</span><span class="c">&gt;</span><span class="c"> is the number of positions necessary to store the</span>
		<span class="c">///</span><span class="c"> base 10 value.</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">para</span><span class="c"> </span><span class="c">/&gt;</span>
		<span class="c">///</span><span class="c"> The argument and return values from this method make it easy to chain</span>
		<span class="c">///</span><span class="c"> writing, for example:</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">para</span><span class="c"> </span><span class="c">/&gt;</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">example</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> byte[] tmp = new byte[64];</span>
		<span class="c">///</span><span class="c"> int ptr = tmp.Length;</span>
		<span class="c">///</span><span class="c"> tmp[--ptr] = &#39;\n&#39;;</span>
		<span class="c">///</span><span class="c"> ptr = RawParseUtils.formatBase10(tmp, ptr, 32);</span>
		<span class="c">///</span><span class="c"> tmp[--ptr] = &#39; &#39;;</span>
		<span class="c">///</span><span class="c"> ptr = RawParseUtils.formatBase10(tmp, ptr, 18);</span>
		<span class="c">///</span><span class="c"> tmp[--ptr] = 0;</span>
		<span class="c">///</span><span class="c"> string str = new string(tmp, ptr, tmp.Length - ptr);</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;/</span><span class="c">example</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;/</span><span class="c">summary</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">param</span><span class="c"> </span><span class="c">name</span><span class="c">=</span><span class="c">&quot;</span><span class="r8 r">b</span><span class="c">&quot;</span><span class="c">&gt;</span><span class="c">buffer to write into.</span><span class="c">&lt;/</span><span class="c">param</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">param</span><span class="c"> </span><span class="c">name</span><span class="c">=</span><span class="c">&quot;</span><span class="r9 r">o</span><span class="c">&quot;</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> One offset past the location where writing will begin; writing</span>
		<span class="c">///</span><span class="c"> proceeds towards lower index values.</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;/</span><span class="c">param</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">param</span><span class="c"> </span><span class="c">name</span><span class="c">=</span><span class="c">&quot;</span><span class="r10 r">value</span><span class="c">&quot;</span><span class="c">&gt;</span><span class="c">the value to store.</span><span class="c">&lt;/</span><span class="c">param</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">returns</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> the new offset value </span><span class="c">&lt;</span><span class="c">code</span><span class="c">&gt;</span><span class="c">o</span><span class="c">&lt;/</span><span class="c">code</span><span class="c">&gt;</span><span class="c">. This is the position of</span>
		<span class="c">///</span><span class="c"> the last byte written. Additional writing should start at one</span>
		<span class="c">///</span><span class="c"> position earlier.</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;/</span><span class="c">returns</span><span class="c">&gt;</span>
		<b>public static int</b> <a id="addf829e37b6eea2" href="../R/addf829e37b6eea2.html" target="n" data-glyph="72,1" class="i method">formatBase10</a>(<b>byte</b>[] <span id="r8 rd" class="r8 r">b</span>, <b>int</b> <span id="r9 rd" class="r9 r">o</span>, <b>int</b> <span id="r10 rd" class="r10 r">value</span>)
		{
			<b>if</b> (<span class="r10 r">value</span> == 0)
			{
				<span class="r8 r">b</span>[--<span class="r9 r">o</span>] = (<b>byte</b>)<span class="s">&#39;0&#39;</span>;
				<b>return</b> <span class="r9 r">o</span>;
			}

			<b>bool</b> <span id="r11 rd" class="r11 r">isneg</span> = <span class="r10 r">value</span> &lt; 0;

			<b>while</b> (<span class="r10 r">value</span> != 0)
			{
				<span class="r8 r">b</span>[--<span class="r9 r">o</span>] = <a href="#849af5115d8ac8d4" class="i field">Base10Byte</a>[<span class="r10 r">value</span> % 10];
				<span class="r10 r">value</span> /= 10;
			}

			<b>if</b> (<span class="r11 r">isneg</span>)
			{
				<span class="r8 r">b</span>[--<span class="r9 r">o</span>] = (<b>byte</b>)<span class="s">&#39;-&#39;</span>;
			}

			<b>return</b> <span class="r9 r">o</span>;
		}

		<span class="c">/**</span>
         <span class="c">*</span><span class="c"> Parse a base 10 numeric from a sequence of ASCII digits into an int.</span>
         <span class="c">*</span><span class="c"> </span><span class="c">&lt;</span><span class="c">para</span><span class="c"> </span><span class="c">/&gt;</span>
         <span class="c">*</span><span class="c"> Digit sequences can begin with an optional run of spaces before the</span>
         <span class="c">*</span><span class="c"> sequence, and may start with a &#39;+&#39; or a &#39;-&#39; to indicate sign position.</span>
         <span class="c">*</span><span class="c"> Any other characters will cause the method to stop and return the current</span>
         <span class="c">*</span><span class="c"> result to the caller.</span>
         <span class="c">*</span><span class="c"> </span>
         <span class="c">*</span><span class="c"> @param b</span>
         <span class="c">*</span><span class="c">            buffer to scan.</span>
         <span class="c">*</span><span class="c"> @param ptr</span>
         <span class="c">*</span><span class="c">            position within buffer to start parsing digits at.</span>
         <span class="c">*</span><span class="c"> @param ptrResult</span>
         <span class="c">*</span><span class="c">            optional location to return the new ptr value through. If null</span>
         <span class="c">*</span><span class="c">            the ptr value will be discarded.</span>
         <span class="c">*</span><span class="c"> @return the value at this location; 0 if the location is not a valid</span>
         <span class="c">*</span><span class="c">         numeric.</span>
         <span class="c">*/</span>
		<b>public static int</b> <a id="52168a0231cef30b" href="../R/52168a0231cef30b.html" target="n" data-glyph="72,1" class="i method">parseBase10</a>(<b>byte</b>[] <span id="r12 rd" class="r12 r">b</span>, <b>int</b> <span id="r13 rd" class="r13 r">ptr</span>, <a href="MutableInteger.cs.html#5b3a0be7485d5537" class="t t">MutableInteger</a> <span id="r14 rd" class="r14 r">ptrResult</span>)
		{
			<b>int</b> <span id="r15 rd" class="r15 r">r</span> = 0;
			<b>int</b> <span id="r16 rd" class="r16 r">sign</span> = 0;
			<b>try</b>
			{
				<b>int</b> <span id="r17 rd" class="r17 r">sz</span> = <span class="r12 r">b</span>.<a href="@0@mscorlib/A.html#42e9b7616956cf94" class="i property">Length</a>;
				<b>while</b> (<span class="r13 r">ptr</span> &lt; <span class="r17 r">sz</span> &amp;&amp; <span class="r12 r">b</span>[<span class="r13 r">ptr</span>] == <span class="s">&#39; &#39;</span>)
					<span class="r13 r">ptr</span>++;
				<b>if</b> (<span class="r13 r">ptr</span> &gt;= <span class="r17 r">sz</span>)
					<b>return</b> 0;

				<b>switch</b> (<span class="r12 r">b</span>[<span class="r13 r">ptr</span>])
				{
					<b>case</b> ((<b>byte</b>)<span class="s">&#39;-&#39;</span>):
						<span class="r16 r">sign</span> = -1;
						<span class="r13 r">ptr</span>++;
						<b>break</b>;
					<b>case</b> ((<b>byte</b>)<span class="s">&#39;+&#39;</span>):
						<span class="r13 r">ptr</span>++;
						<b>break</b>;
				}

				<b>while</b> (<span class="r13 r">ptr</span> &lt; <span class="r17 r">sz</span>)
				{
					<b>byte</b> <span id="r18 rd" class="r18 r">d</span> = <span class="r12 r">b</span>[<span class="r13 r">ptr</span>];
					<b>if</b> ((<span class="r18 r">d</span> &lt; (<b>byte</b>)<span class="s">&#39;0&#39;</span>) || (<span class="r18 r">d</span> &gt; (<b>byte</b>)<span class="s">&#39;9&#39;</span>))
						<b>break</b>;
					<span class="r15 r">r</span> = <span class="r15 r">r</span> * 10 + (<span class="r18 r">d</span> - (<b>byte</b>)<span class="s">&#39;0&#39;</span>);
					<span class="r13 r">ptr</span>++;
				}
			}
			<b>catch</b> (<a href="@0@mscorlib/A.html#acba961d918b2408" class="t t">IndexOutOfRangeException</a>)
			{
				<span class="c">// Not a valid digit.</span>
			}
			<b>if</b> (<span class="r14 r">ptrResult</span> != <b>null</b>)
				<span class="r14 r">ptrResult</span>.<a href="MutableInteger.cs.html#1eabd2e28ad6a7f0" class="i field">value</a> = <span class="r13 r">ptr</span>;
			<b>return</b> <span class="r16 r">sign</span> &lt; 0 ? -<span class="r15 r">r</span> : <span class="r15 r">r</span>;
		}

		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">summary</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> Parse a base 10 numeric from a sequence of ASCII digits into a long.</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">para</span><span class="c"> </span><span class="c">/&gt;</span>
		<span class="c">///</span><span class="c"> Digit sequences can begin with an optional run of spaces before the</span>
		<span class="c">///</span><span class="c"> sequence, and may start with a &#39;+&#39; or a &#39;-&#39; to indicate sign position.</span>
		<span class="c">///</span><span class="c"> Any other characters will cause the method to stop and return the current</span>
		<span class="c">///</span><span class="c"> result to the caller.</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;/</span><span class="c">summary</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">param</span><span class="c"> </span><span class="c">name</span><span class="c">=</span><span class="c">&quot;</span><span class="r19 r">b</span><span class="c">&quot;</span><span class="c">&gt;</span><span class="c">Buffer to scan.</span><span class="c">&lt;/</span><span class="c">param</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">param</span><span class="c"> </span><span class="c">name</span><span class="c">=</span><span class="c">&quot;</span><span class="r20 r">ptr</span><span class="c">&quot;</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> Position within buffer to start parsing digits at.</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;/</span><span class="c">param</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">param</span><span class="c"> </span><span class="c">name</span><span class="c">=</span><span class="c">&quot;</span><span class="r21 r">ptrResult</span><span class="c">&quot;</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> Optional location to return the new ptr value through. If null</span>
		<span class="c">///</span><span class="c"> the ptr value will be discarded.</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;/</span><span class="c">param</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">returns</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> The value at this location; 0 if the location is not a valid</span>
		<span class="c">///</span><span class="c"> numeric.</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;/</span><span class="c">returns</span><span class="c">&gt;</span>
		<b>public static long</b> <a id="d90f20e32b61eae7" href="../R/d90f20e32b61eae7.html" target="n" data-glyph="72,1" class="i method">parseLongBase10</a>(<b>byte</b>[] <span id="r19 rd" class="r19 r">b</span>, <b>int</b> <span id="r20 rd" class="r20 r">ptr</span>, <a href="MutableInteger.cs.html#5b3a0be7485d5537" class="t t">MutableInteger</a> <span id="r21 rd" class="r21 r">ptrResult</span>)
		{
			<b>long</b> <span id="r22 rd" class="r22 r">r</span> = 0;
			<b>int</b> <span id="r23 rd" class="r23 r">sign</span> = 0;
			<b>try</b>
			{
				<b>int</b> <span id="r24 rd" class="r24 r">sz</span> = <span class="r19 r">b</span>.<a href="@0@mscorlib/A.html#42e9b7616956cf94" class="i property">Length</a>;
				<b>while</b> (<span class="r20 r">ptr</span> &lt; <span class="r24 r">sz</span> &amp;&amp; <span class="r19 r">b</span>[<span class="r20 r">ptr</span>] == <span class="s">&#39; &#39;</span>)
					<span class="r20 r">ptr</span>++;
				<b>if</b> (<span class="r20 r">ptr</span> &gt;= <span class="r24 r">sz</span>)
					<b>return</b> 0;

				<b>switch</b> (<span class="r19 r">b</span>[<span class="r20 r">ptr</span>])
				{
					<b>case</b> (<b>byte</b>)<span class="s">&#39;-&#39;</span>:
						<span class="r23 r">sign</span> = -1;
						<span class="r20 r">ptr</span>++;
						<b>break</b>;
					<b>case</b> (<b>byte</b>)<span class="s">&#39;+&#39;</span>:
						<span class="r20 r">ptr</span>++;
						<b>break</b>;
				}

				<b>while</b> (<span class="r20 r">ptr</span> &lt; <span class="r24 r">sz</span>)
				{
					<b>int</b> <span id="r25 rd" class="r25 r">v</span> = <span class="r19 r">b</span>[<span class="r20 r">ptr</span>] - (<b>byte</b>)<span class="s">&#39;0&#39;</span>;
					<b>if</b> (<span class="r25 r">v</span> &lt; 0)
						<b>break</b>;
					<span class="r22 r">r</span> = (<span class="r22 r">r</span> * 10) + <span class="r25 r">v</span>;
					<span class="r20 r">ptr</span>++;
				}
			}
			<b>catch</b> (<a href="@0@mscorlib/A.html#acba961d918b2408" class="t t">IndexOutOfRangeException</a>)
			{
				<span class="c">// Not a valid digit.</span>
			}
			<b>if</b> (<span class="r21 r">ptrResult</span> != <b>null</b>)
				<span class="r21 r">ptrResult</span>.<a href="MutableInteger.cs.html#1eabd2e28ad6a7f0" class="i field">value</a> = <span class="r20 r">ptr</span>;
			<b>return</b> <span class="r23 r">sign</span> &lt; 0 ? -<span class="r22 r">r</span> : <span class="r22 r">r</span>;
		}

		<span class="c">///</span><span class="c">	</span><span class="c">&lt;</span><span class="c">summary</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> Parse 4 character base 16 (hex) formatted string to unsigned integer.</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">para</span><span class="c"> </span><span class="c">/&gt;</span>
		<span class="c">///</span><span class="c"> The number is read in network byte order, that is, most significant</span>
		<span class="c">///</span><span class="c"> nibble first.</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;/</span><span class="c">summary</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">param</span><span class="c"> </span><span class="c">name</span><span class="c">=</span><span class="c">&quot;</span><span class="r26 r">bs</span><span class="c">&quot;</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> buffer to parse digits from; positions </span><span class="c">&lt;</span><span class="c">code</span><span class="c">&gt;</span><span class="c">[p, p+4]</span><span class="c">&lt;/</span><span class="c">code</span><span class="c">&gt;</span><span class="c"> will</span>
		<span class="c">///</span><span class="c"> be parsed.</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;/</span><span class="c">param</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">param</span><span class="c"> </span><span class="c">name</span><span class="c">=</span><span class="c">&quot;</span><span class="r27 r">p</span><span class="c">&quot;</span><span class="c">&gt;</span><span class="c">First position within the buffer to parse.</span><span class="c">&lt;/</span><span class="c">param</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c">	</span><span class="c">&lt;</span><span class="c">returns</span><span class="c">&gt;</span><span class="c">The integer value.</span><span class="c">&lt;/</span><span class="c">returns</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">exception</span><span class="c"> </span><span class="c">cref</span><span class="c">=</span><span class="c">&quot;</span><a href="@0@mscorlib/A.html#acba961d918b2408" class="t t">IndexOutOfRangeException</a><span class="c">&quot;</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> If the string is not hex formatted.</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;/</span><span class="c">exception</span><span class="c">&gt;</span>
		<b>public static int</b> <a id="79305506b576c10b" href="../R/79305506b576c10b.html" target="n" data-glyph="72,1" class="i method">parseHexInt16</a>(<b>byte</b>[] <span id="r26 rd" class="r26 r">bs</span>, <b>int</b> <span id="r27 rd" class="r27 r">p</span>)
		{
			<b>try</b> 
			{
                <b>string</b> <span id="r28 rd" class="r28 r">hex</span> = <a href="JavaHelper/Charset.cs.html#deb6aa96e25fd4d7" class="t t">Charset</a>.<a href="JavaHelper/Charset.cs.html#053612684daba28e" class="i method">forName</a>(<span class="s">&quot;US-ASCII&quot;</span>).<a href="@0@mscorlib/A.html#233647d04fbec0c0" class="i method">GetString</a>(<span class="r26 r">bs</span>, <span class="r27 r">p</span>, 4);
				
				<span class="r28 r">hex</span> = <span class="r28 r">hex</span>.<a href="@0@mscorlib/A.html#882fa7998d6ca35a" class="i method">Substring</a>(<span class="r27 r">p</span>);
				<b>return</b> <a href="@0@mscorlib/A.html#fb226f61047a07ff" class="t t">UInt16</a>.<a href="@0@mscorlib/A.html#48ae02de4b0bfb48" class="i method">Parse</a>(<span class="r28 r">hex</span>,<span class="i n">System</span>.<span class="i n">Globalization</span>.<a href="@0@mscorlib/A.html#4523c5163ff35e41" class="t t">NumberStyles</a>.<a href="@0@mscorlib/A.html#be3c49bf351faf37" class="i field">AllowHexSpecifier</a>);
			}
			<b>catch</b> (<a href="@0@mscorlib/A.html#f092fb2b893a0162" class="t t">Exception</a> <span id="r29 rd" class="r29 r">e</span>)
			{
				<b>throw</b> <b>new</b> <a href="@0@mscorlib/A.html#ddff447b6be340bc" class="t constructor">IndexOutOfRangeException</a>(<span class="s">&quot;Exception Parsing Hex&quot;</span>,<span class="r29 r">e</span>);
			}
		}

		<span class="c">///</span><span class="c">	</span><span class="c">&lt;</span><span class="c">summary</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> Parse 8 character base 16 (hex) formatted string to unsigned integer.</span>
		<span class="c">///</span><span class="c">	</span><span class="c">&lt;</span><span class="c">para</span><span class="c"> </span><span class="c">/&gt;</span>
		<span class="c">///</span><span class="c">	The number is read in network byte order, that is, most significant</span>
		<span class="c">///</span><span class="c">	nibble first.</span>
		<span class="c">///</span><span class="c">	</span><span class="c">&lt;/</span><span class="c">summary</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c">	</span><span class="c">&lt;</span><span class="c">param</span><span class="c"> </span><span class="c">name</span><span class="c">=</span><span class="c">&quot;</span><span class="r30 r">bs</span><span class="c">&quot;</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> Buffer to parse digits from; positions </span><span class="c">&lt;</span><span class="c">code</span><span class="c">&gt;</span><span class="c">[p, p+8]</span><span class="c">&lt;/</span><span class="c">code</span><span class="c">&gt;</span><span class="c"> will</span>
		<span class="c">///</span><span class="c"> be parsed.</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;/</span><span class="c">param</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c">	</span><span class="c">&lt;</span><span class="c">param</span><span class="c"> </span><span class="c">name</span><span class="c">=</span><span class="c">&quot;</span><span class="r31 r">p</span><span class="c">&quot;</span><span class="c">&gt;</span><span class="c">First position within the buffer to parse.</span><span class="c">&lt;/</span><span class="c">param</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c">	</span><span class="c">&lt;</span><span class="c">returns</span><span class="c">&gt;</span><span class="c"> the integer value.</span><span class="c">&lt;/</span><span class="c">returns</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c">	</span><span class="c">&lt;</span><span class="c">exception</span><span class="c"> </span><span class="c">cref</span><span class="c">=</span><span class="c">&quot;</span><a href="@0@mscorlib/A.html#acba961d918b2408" class="t t">IndexOutOfRangeException</a><span class="c">&quot;</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c">	if the string is not hex formatted.</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;/</span><span class="c">exception</span><span class="c">&gt;</span>
		<b>public static int</b> <a id="2af82d1ecd6084ea" href="../R/2af82d1ecd6084ea.html" target="n" data-glyph="72,1" class="i method">parseHexInt32</a>(<b>byte</b>[] <span id="r30 rd" class="r30 r">bs</span>, <b>int</b> <span id="r31 rd" class="r31 r">p</span>)
		{
			<b>try</b> 
			{
                <b>string</b> <span id="r32 rd" class="r32 r">hex</span> = <a href="JavaHelper/Charset.cs.html#deb6aa96e25fd4d7" class="t t">Charset</a>.<a href="JavaHelper/Charset.cs.html#053612684daba28e" class="i method">forName</a>(<span class="s">&quot;US-ASCII&quot;</span>).<a href="@0@mscorlib/A.html#233647d04fbec0c0" class="i method">GetString</a>(<span class="r30 r">bs</span>, <span class="r31 r">p</span>, 8);
                <span class="c">//string hex = Encoding.ASCII.GetString(bs).Substring(p, 8);</span>
				
				<b>return</b> (<b>int</b>)<a href="@0@mscorlib/A.html#0cd3c987eff5ef85" class="t t">UInt32</a>.<a href="@0@mscorlib/A.html#ea59918d8764be7d" class="i method">Parse</a>(<span class="r32 r">hex</span>,<span class="i n">System</span>.<span class="i n">Globalization</span>.<a href="@0@mscorlib/A.html#4523c5163ff35e41" class="t t">NumberStyles</a>.<a href="@0@mscorlib/A.html#be3c49bf351faf37" class="i field">AllowHexSpecifier</a>);
			}
			<b>catch</b> (<a href="@0@mscorlib/A.html#f092fb2b893a0162" class="t t">Exception</a> <span id="r33 rd" class="r33 r">e</span>)
			{
				<b>throw</b> <b>new</b> <a href="@0@mscorlib/A.html#ddff447b6be340bc" class="t constructor">IndexOutOfRangeException</a>(<span class="s">&quot;Exception Parsing Hex&quot;</span>,<span class="r33 r">e</span>);
			}
		}

		<span class="c">///</span><span class="c">	</span><span class="c">&lt;</span><span class="c">summary</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> Parse a single hex digit to its numeric value (0-15).</span>
		<span class="c">///</span><span class="c">	</span><span class="c">&lt;/</span><span class="c">summary</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c">	</span><span class="c">&lt;</span><span class="c">param</span><span class="c"> </span><span class="c">name</span><span class="c">=</span><span class="c">&quot;</span><span class="r34 r">digit</span><span class="c">&quot;</span><span class="c">&gt;</span><span class="c">Hex character to parse.</span><span class="c">&lt;/</span><span class="c">param</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c">	</span><span class="c">&lt;</span><span class="c">returns</span><span class="c">&gt;</span><span class="c">Numeric value, in the range 0-15.</span><span class="c">&lt;/</span><span class="c">returns</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c">	</span><span class="c">&lt;</span><span class="c">exception</span><span class="c"> </span><span class="c">cref</span><span class="c">=</span><span class="c">&quot;</span><a href="@0@mscorlib/A.html#acba961d918b2408" class="t t">IndexOutOfRangeException</a><span class="c">&quot;</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c">	If the input digit is not a valid hex digit.</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;/</span><span class="c">exception</span><span class="c">&gt;</span>
		<b>public static int</b> <a id="690b6d0129841f47" href="../R/690b6d0129841f47.html" target="n" data-glyph="72,1" class="i method">parseHexInt4</a>(<b>byte</b> <span id="r34 rd" class="r34 r">digit</span>)
		{
			<b>try</b> 
			{
				<b>char</b> <span id="r35 rd" class="r35 r">c</span> = (<b>char</b>)<span class="r34 r">digit</span>;
				<a href="@0@mscorlib/A.html#fb226f61047a07ff" class="t t">UInt16</a> <span id="r36 rd" class="r36 r">result</span> = <a href="@0@mscorlib/A.html#fb226f61047a07ff" class="t t">UInt16</a>.<a href="@0@mscorlib/A.html#48ae02de4b0bfb48" class="i method">Parse</a>(<span class="r35 r">c</span>.<a href="@0@mscorlib/A.html#8da116b4ffb677f2" class="i method">ToString</a>(),<span class="i n">System</span>.<span class="i n">Globalization</span>.<a href="@0@mscorlib/A.html#4523c5163ff35e41" class="t t">NumberStyles</a>.<a href="@0@mscorlib/A.html#be3c49bf351faf37" class="i field">AllowHexSpecifier</a>);
				
				<b>if</b> (<span class="r36 r">result</span> &gt; 15)
					<b>throw</b> <b>new</b> <a href="@0@mscorlib/A.html#26e953f3636ea6c0" class="t constructor">OverflowException</a>();
				
				<b>return</b> (<b>int</b>)<span class="r36 r">result</span>;
			}
			<b>catch</b> (<a href="@0@mscorlib/A.html#f092fb2b893a0162" class="t t">Exception</a> <span id="r37 rd" class="r37 r">e</span>)
			{
				<b>throw</b> <b>new</b> <a href="@0@mscorlib/A.html#ddff447b6be340bc" class="t constructor">IndexOutOfRangeException</a>(<span class="s">&quot;Exception Parsing Hex&quot;</span>,<span class="r37 r">e</span>);
			}
		}

		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">summary</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> Parse a Git style timezone string.</span>
		<span class="c">///</span><span class="c">	</span><span class="c">&lt;</span><span class="c">para</span><span class="c"> </span><span class="c">/&gt;</span>
		<span class="c">///</span><span class="c">	The sequence &quot;-0315&quot; will be parsed as the numeric value -195, as the</span>
		<span class="c">///</span><span class="c">	lower two positions count minutes, not 100ths of an hour.</span>
		<span class="c">///</span><span class="c">	</span><span class="c">&lt;/</span><span class="c">summary</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c">	</span><span class="c">&lt;</span><span class="c">param</span><span class="c"> </span><span class="c">name</span><span class="c">=</span><span class="c">&quot;</span><span class="r38 r">b</span><span class="c">&quot;</span><span class="c">&gt;</span><span class="c">Buffer to scan.</span><span class="c">&lt;/</span><span class="c">param</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c">	</span><span class="c">&lt;</span><span class="c">param</span><span class="c"> </span><span class="c">name</span><span class="c">=</span><span class="c">&quot;</span><span class="r39 r">ptr</span><span class="c">&quot;</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c">	Position within buffer to start parsing digits at. </span><span class="c">&lt;/</span><span class="c">param</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c">	</span><span class="c">&lt;</span><span class="c">returns</span><span class="c">&gt;</span><span class="c"> the timezone at this location, expressed in minutes. </span><span class="c">&lt;/</span><span class="c">returns</span><span class="c">&gt;</span>
		<b>public static int</b> <a id="e71b001731a86398" href="../R/e71b001731a86398.html" target="n" data-glyph="72,1" class="i method">parseTimeZoneOffset</a>(<b>byte</b>[] <span id="r38 rd" class="r38 r">b</span>, <b>int</b> <span id="r39 rd" class="r39 r">ptr</span>)
		{
			<b>int</b> <span id="r40 rd" class="r40 r">v</span> = <a href="#52168a0231cef30b" class="i method">parseBase10</a>(<span class="r38 r">b</span>, <span class="r39 r">ptr</span>, <b>null</b>);
			<b>int</b> <span id="r41 rd" class="r41 r">tzMins</span> = <span class="r40 r">v</span> % 100;
			<b>int</b> <span id="r42 rd" class="r42 r">tzHours</span> = <span class="r40 r">v</span> / 100;
			<b>return</b> <span class="r42 r">tzHours</span> * 60 + <span class="r41 r">tzMins</span>;
		}

		<b>public static int</b> <a id="8cef6e8f2f0cd26a" href="../R/8cef6e8f2f0cd26a.html" target="n" data-glyph="72,1" class="i method">next</a>(<b>byte</b>[] <span id="r43 rd" class="r43 r">b</span>, <b>int</b> <span id="r44 rd" class="r44 r">ptr</span>, <b>byte</b> <span id="r45 rd" class="r45 r">chrA</span>)
		{
			<b>int</b> <span id="r46 rd" class="r46 r">sz</span> = <span class="r43 r">b</span>.<a href="@0@mscorlib/A.html#42e9b7616956cf94" class="i property">Length</a>;
			<b>while</b> (<span class="r44 r">ptr</span> &lt; <span class="r46 r">sz</span>)
			{
				<b>if</b> (<span class="r43 r">b</span>[<span class="r44 r">ptr</span>++] == <span class="r45 r">chrA</span>)
					<b>return</b> <span class="r44 r">ptr</span>;
			}
			<b>return</b> <span class="r44 r">ptr</span>;
		}

		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">summary</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> Locate the first position after LF.</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;/</span><span class="c">summary</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">param</span><span class="c"> </span><span class="c">name</span><span class="c">=</span><span class="c">&quot;</span><span class="r47 r">b</span><span class="c">&quot;</span><span class="c">&gt;</span><span class="c">buffer to scan.</span><span class="c">&lt;/</span><span class="c">param</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">param</span><span class="c"> </span><span class="c">name</span><span class="c">=</span><span class="c">&quot;</span><span class="r48 r">ptr</span><span class="c">&quot;</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> position within buffer to start looking for LF at.</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;/</span><span class="c">param</span><span class="c">&gt;</span>
		<span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">returns</span><span class="c">&gt;</span><span class="c">New position just after LF.</span><span class="c">&lt;/</span><span class="c">returns</span><span class="c">&gt;</span>
		<b>public static int</b> <a id="0989702123852d37" href="../R/0989702123852d37.html" target="n" data-glyph="72,1" class="i method">nextLF</a>(<b>byte</b>[] <span id="r47 rd" class="r47 r">b</span>, <b>int</b> <span id="r48 rd" class="r48 r">ptr</span>)
		{
			<b>return</b> <a href="#8cef6e8f2f0cd26a" class="i method">next</a>(<span class="r47 r">b</span>, <span class="r48 r">ptr</span>, (<b>byte</b>)<span class="s">&#39;\n&#39;</span>);
		}

		<span class="c">/**</span>
         <span class="c">*</span><span class="c"> Locate the first position After either the given character or LF.</span>
         <span class="c">*</span><span class="c"> </span><span class="c">&lt;</span><span class="c">para</span><span class="c"> </span><span class="c">/&gt;</span>
         <span class="c">*</span><span class="c"> This method stops on the first match it finds from either chrA or &#39;\n&#39;.</span>
         <span class="c">*</span><span class="c"> </span>
         <span class="c">*</span><span class="c"> @param b</span>
         <span class="c">*</span><span class="c">            buffer to scan.</span>
         <span class="c">*</span><span class="c"> @param ptr</span>
         <span class="c">*</span><span class="c">            position within buffer to start looking for chrA or LF at.</span>
         <span class="c">*</span><span class="c"> @param chrA</span>
         <span class="c">*</span><span class="c">            character to find.</span>
         <span class="c">*</span><span class="c"> @return new position just After the first chrA or LF to be found.</span>
         <span class="c">*/</span>
		<b>public static int</b> <a id="bfac7916e9a2bc6d" href="../R/bfac7916e9a2bc6d.html" target="n" data-glyph="72,1" class="i method">nextLF</a>(<b>byte</b>[] <span id="r49 rd" class="r49 r">b</span>, <b>int</b> <span id="r50 rd" class="r50 r">ptr</span>, <b>byte</b> <span id="r51 rd" class="r51 r">chrA</span>)
		{
			<b>int</b> <span id="r52 rd" class="r52 r">sz</span> = <span class="r49 r">b</span>.<a href="@0@mscorlib/A.html#42e9b7616956cf94" class="i property">Length</a>;
			<b>while</b> (<span class="r50 r">ptr</span> &lt; <span class="r52 r">sz</span>)
			{
				<b>byte</b> <span id="r53 rd" class="r53 r">c</span> = <span class="r49 r">b</span>[<span class="r50 r">ptr</span>++];
				<b>if</b> (<span class="r53 r">c</span> == <span class="r51 r">chrA</span> || <span class="r53 r">c</span> == (<b>byte</b>)<span class="s">&#39;\n&#39;</span>)
					<b>return</b> <span class="r50 r">ptr</span>;
			}
			<b>return</b> <span class="r50 r">ptr</span>;
		}


		<span class="c">/**</span>
         <span class="c">*</span><span class="c"> Locate the first position before a given character.</span>
         <span class="c">*</span>
         <span class="c">*</span><span class="c"> @param b</span>
         <span class="c">*</span><span class="c">            buffer to scan.</span>
         <span class="c">*</span><span class="c"> @param ptr</span>
         <span class="c">*</span><span class="c">            position within buffer to start looking for chrA at.</span>
         <span class="c">*</span><span class="c"> @param chrA</span>
         <span class="c">*</span><span class="c">            character to find.</span>
         <span class="c">*</span><span class="c"> @return new position just before chrA, -1 for not found</span>
         <span class="c">*/</span>
		<b>public static int</b> <a id="6b2fd11d0d0a534c" href="../R/6b2fd11d0d0a534c.html" target="n" data-glyph="72,1" class="i method">prev</a>(<b>byte</b>[] <span id="r54 rd" class="r54 r">b</span>, <b>int</b> <span id="r55 rd" class="r55 r">ptr</span>, <b>char</b> <span id="r56 rd" class="r56 r">chrA</span>)
		{
			<b>if</b> (<span class="r55 r">ptr</span> == <span class="r54 r">b</span>.<a href="@0@mscorlib/A.html#42e9b7616956cf94" class="i property">Length</a>)
				--<span class="r55 r">ptr</span>;
			<b>while</b> (<span class="r55 r">ptr</span> &gt;= 0)
			{
				<b>if</b> (<span class="r54 r">b</span>[<span class="r55 r">ptr</span>--] == <span class="r56 r">chrA</span>)
					<b>return</b> <span class="r55 r">ptr</span>;
			}
			<b>return</b> <span class="r55 r">ptr</span>;
		}

		<span class="c">/**</span>
         <span class="c">*</span><span class="c"> Locate the first position before the previous LF.</span>
         <span class="c">*</span><span class="c"> </span><span class="c">&lt;</span><span class="c">para</span><span class="c"> </span><span class="c">/&gt;</span>
         <span class="c">*</span><span class="c"> This method stops on the first &#39;\n&#39; it finds.</span>
         <span class="c">*</span>
         <span class="c">*</span><span class="c"> @param b</span>
         <span class="c">*</span><span class="c">            buffer to scan.</span>
         <span class="c">*</span><span class="c"> @param ptr</span>
         <span class="c">*</span><span class="c">            position within buffer to start looking for LF at.</span>
         <span class="c">*</span><span class="c"> @return new position just before the first LF found, -1 for not found</span>
         <span class="c">*/</span>
		<b>public static int</b> <a id="2ed17ff1cf24d1e6" href="../R/2ed17ff1cf24d1e6.html" target="n" data-glyph="72,1" class="i method">prevLF</a>(<b>byte</b>[] <span id="r57 rd" class="r57 r">b</span>, <b>int</b> <span id="r58 rd" class="r58 r">ptr</span>)
		{
			<b>return</b> <a href="#6b2fd11d0d0a534c" class="i method">prev</a>(<span class="r57 r">b</span>, <span class="r58 r">ptr</span>, <span class="s">&#39;\n&#39;</span>);
		}

		<span class="c">/**</span>
         <span class="c">*</span><span class="c"> Locate the previous position before either the given character or LF.</span>
         <span class="c">*</span><span class="c"> </span><span class="c">&lt;</span><span class="c">para</span><span class="c"> </span><span class="c">/&gt;</span>
         <span class="c">*</span><span class="c"> This method stops on the first match it finds from either chrA or &#39;\n&#39;.</span>
         <span class="c">*</span>
         <span class="c">*</span><span class="c"> @param b</span>
         <span class="c">*</span><span class="c">            buffer to scan.</span>
         <span class="c">*</span><span class="c"> @param ptr</span>
         <span class="c">*</span><span class="c">            position within buffer to start looking for chrA or LF at.</span>
         <span class="c">*</span><span class="c"> @param chrA</span>
         <span class="c">*</span><span class="c">            character to find.</span>
         <span class="c">*</span><span class="c"> @return new position just before the first chrA or LF to be found, -1 for</span>
         <span class="c">*</span><span class="c">         not found</span>
         <span class="c">*/</span>
		<b>public static int</b> <a id="81d74d0e77593935" href="../R/../../0000000000.html" target="n" data-glyph="72,1" class="i method">prevLF</a>(<b>byte</b>[] <span id="r59 rd" class="r59 r">b</span>, <b>int</b> <span id="r60 rd" class="r60 r">ptr</span>, <b>char</b> <span id="r61 rd" class="r61 r">chrA</span>)
		{
			<b>if</b> (<span class="r60 r">ptr</span> == <span class="r59 r">b</span>.<a href="@0@mscorlib/A.html#42e9b7616956cf94" class="i property">Length</a>)
				--<span class="r60 r">ptr</span>;
			<b>while</b> (<span class="r60 r">ptr</span> &gt;= 0)
			{
				<b>byte</b> <span id="r62 rd" class="r62 r">c</span> = <span class="r59 r">b</span>[<span class="r60 r">ptr</span>--];
				<b>if</b> (<span class="r62 r">c</span> == (<b>byte</b>)<span class="r61 r">chrA</span> || <span class="r62 r">c</span> == (<b>byte</b>)<span class="s">&#39;\n&#39;</span>)
					<b>return</b> <span class="r60 r">ptr</span>;
			}
			<b>return</b> <span class="r60 r">ptr</span>;
		}

		<span class="c">/**</span>
         <span class="c">*</span><span class="c"> Index the region between </span><span class="c">&lt;</span><span class="c">code</span><span class="c">&gt;</span><span class="c">[ptr, end)</span><span class="c">&lt;/</span><span class="c">code</span><span class="c">&gt;</span><span class="c"> to find line starts.</span>
         <span class="c">*</span><span class="c"> </span><span class="c">&lt;</span><span class="c">para</span><span class="c"> </span><span class="c">/&gt;</span>
         <span class="c">*</span><span class="c"> The returned list is 1 indexed. Index 0 contains</span>
         <span class="c">*</span><span class="c"> {@link Integer#MIN_VALUE} to pad the list out.</span>
         <span class="c">*</span><span class="c"> </span><span class="c">&lt;</span><span class="c">para</span><span class="c"> </span><span class="c">/&gt;</span>
         <span class="c">*</span><span class="c"> Using a 1 indexed list means that line numbers can be directly accessed</span>
         <span class="c">*</span><span class="c"> from the list, so </span><span class="c">&lt;</span><span class="c">code</span><span class="c">&gt;</span><span class="c">list.get(1)</span><span class="c">&lt;/</span><span class="c">code</span><span class="c">&gt;</span><span class="c"> (aka get line 1) returns</span>
         <span class="c">*</span><span class="c"> </span><span class="c">&lt;</span><span class="c">code</span><span class="c">&gt;</span><span class="c">ptr</span><span class="c">&lt;/</span><span class="c">code</span><span class="c">&gt;</span><span class="c">.</span>
         <span class="c">*</span><span class="c"> </span><span class="c">&lt;</span><span class="c">para</span><span class="c"> </span><span class="c">/&gt;</span>
         <span class="c">*</span><span class="c"> The last element (index </span><span class="c">&lt;</span><span class="c">code</span><span class="c">&gt;</span><span class="c">map.size()-1</span><span class="c">&lt;/</span><span class="c">code</span><span class="c">&gt;</span><span class="c">) always contains</span>
         <span class="c">*</span><span class="c"> </span><span class="c">&lt;</span><span class="c">code</span><span class="c">&gt;</span><span class="c">end</span><span class="c">&lt;/</span><span class="c">code</span><span class="c">&gt;</span><span class="c">.</span>
         <span class="c">*</span>
         <span class="c">*</span><span class="c"> @param buf</span>
         <span class="c">*</span><span class="c">            buffer to scan.</span>
         <span class="c">*</span><span class="c"> @param ptr</span>
         <span class="c">*</span><span class="c">            position within the buffer corresponding to the first byte of</span>
         <span class="c">*</span><span class="c">            line 1.</span>
         <span class="c">*</span><span class="c"> @param end</span>
         <span class="c">*</span><span class="c">            1 past the end of the content within </span><span class="c">&lt;</span><span class="c">code</span><span class="c">&gt;</span><span class="c">buf</span><span class="c">&lt;/</span><span class="c">code</span><span class="c">&gt;</span><span class="c">.</span>
         <span class="c">*</span><span class="c"> @return a line map indexing the start position of each line.</span>
         <span class="c">*/</span>
		<b>public static</b> <a href="IntList.cs.html#f9d5bef295988f23" class="t t">IntList</a> <a id="8fb5d3ffee2a7ab6" href="../R/8fb5d3ffee2a7ab6.html" target="n" data-glyph="72,1" class="i method">lineMap</a>(<b>byte</b>[] <span id="r63 rd" class="r63 r">buf</span>, <b>int</b> <span id="r64 rd" class="r64 r">ptr</span>, <b>int</b> <span id="r65 rd" class="r65 r">end</span>)
		{
			<span class="c">// Experimentally derived from multiple source repositories</span>
			<span class="c">// the average number of bytes/line is 36. Its a rough guess</span>
			<span class="c">// to initially size our map close to the target.</span>
			<span class="c">//</span>
			<a href="IntList.cs.html#f9d5bef295988f23" class="t t">IntList</a> <span id="r66 rd" class="r66 r">map</span> = <b>new</b> <a href="IntList.cs.html#1685f2aa383f44f5" class="t constructor">IntList</a>((<span class="r65 r">end</span> - <span class="r64 r">ptr</span>) / 36);
			<span class="r66 r">map</span>.<a href="IntList.cs.html#1c88dd9cf3497cba" class="i method">fillTo</a>(1, <b>int</b>.<a href="@0@mscorlib/A.html#e3cfc4661f06e948" class="i field">MinValue</a>);
			<b>for</b> (; <span class="r64 r">ptr</span> &lt; <span class="r65 r">end</span>; <span class="r64 r">ptr</span> = <a href="#0989702123852d37" class="i method">nextLF</a>(<span class="r63 r">buf</span>, <span class="r64 r">ptr</span>))
				<span class="r66 r">map</span>.<a href="IntList.cs.html#b970d7de65575f4f" class="i method">add</a>(<span class="r64 r">ptr</span>);
			<span class="r66 r">map</span>.<a href="IntList.cs.html#b970d7de65575f4f" class="i method">add</a>(<span class="r65 r">end</span>);
			<b>return</b> <span class="r66 r">map</span>;
		}

		<span class="c">/**</span>
         <span class="c">*</span><span class="c"> Locate the &quot;author &quot; header line data.</span>
         <span class="c">*</span><span class="c"> </span>
         <span class="c">*</span><span class="c"> @param b</span>
         <span class="c">*</span><span class="c">            buffer to scan.</span>
         <span class="c">*</span><span class="c"> @param ptr</span>
         <span class="c">*</span><span class="c">            position in buffer to start the scan at. Most callers should</span>
         <span class="c">*</span><span class="c">            pass 0 to ensure the scan starts from the beginning of the</span>
         <span class="c">*</span><span class="c">            commit buffer and does not accidentally look at message body.</span>
         <span class="c">*</span><span class="c"> @return position just After the space in &quot;author &quot;, so the first</span>
         <span class="c">*</span><span class="c">         character of the author&#39;s name. If no author header can be</span>
         <span class="c">*</span><span class="c">         located -1 is returned.</span>
         <span class="c">*/</span>
		<b>public static int</b> <a id="fbdac19a7c5d36af" href="../R/fbdac19a7c5d36af.html" target="n" data-glyph="72,1" class="i method">author</a>(<b>byte</b>[] <span id="r67 rd" class="r67 r">b</span>, <b>int</b> <span id="r68 rd" class="r68 r">ptr</span>)
		{
			<b>int</b> <span id="r69 rd" class="r69 r">sz</span> = <span class="r67 r">b</span>.<a href="@0@mscorlib/A.html#42e9b7616956cf94" class="i property">Length</a>;
			<b>if</b> (<span class="r68 r">ptr</span> == 0)
				<span class="r68 r">ptr</span> += 46; <span class="c">// skip the &quot;tree ...&quot; line.</span>
			<b>while</b> (<span class="r68 r">ptr</span> &lt; <span class="r69 r">sz</span> &amp;&amp; <span class="r67 r">b</span>[<span class="r68 r">ptr</span>] == (<b>byte</b>)<span class="s">&#39;p&#39;</span>)
				<span class="r68 r">ptr</span> += 48; <span class="c">// skip this parent.</span>
			<b>return</b> <a href="#8d5e78f7413720c3" class="i method">match</a>(<span class="r67 r">b</span>, <span class="r68 r">ptr</span>, <a href="../ObjectChecker.cs.html#366626676af05377" class="t t">ObjectChecker</a>.<a href="../ObjectChecker.cs.html#811b139ca84924c7" class="i field">author</a>);
		}

		<span class="c">/**</span>
         <span class="c">*</span><span class="c"> Locate the &quot;committer &quot; header line data.</span>
         <span class="c">*</span><span class="c"> </span>
         <span class="c">*</span><span class="c"> @param b</span>
         <span class="c">*</span><span class="c">            buffer to scan.</span>
         <span class="c">*</span><span class="c"> @param ptr</span>
         <span class="c">*</span><span class="c">            position in buffer to start the scan at. Most callers should</span>
         <span class="c">*</span><span class="c">            pass 0 to ensure the scan starts from the beginning of the</span>
         <span class="c">*</span><span class="c">            commit buffer and does not accidentally look at message body.</span>
         <span class="c">*</span><span class="c"> @return position just After the space in &quot;committer &quot;, so the first</span>
         <span class="c">*</span><span class="c">         character of the committer&#39;s name. If no committer header can be</span>
         <span class="c">*</span><span class="c">         located -1 is returned.</span>
         <span class="c">*/</span>
		<b>public static int</b> <a id="dbb599477c0115b4" href="../R/dbb599477c0115b4.html" target="n" data-glyph="72,1" class="i method">committer</a>(<b>byte</b>[] <span id="r70 rd" class="r70 r">b</span>, <b>int</b> <span id="r71 rd" class="r71 r">ptr</span>)
		{
			<b>int</b> <span id="r72 rd" class="r72 r">sz</span> = <span class="r70 r">b</span>.<a href="@0@mscorlib/A.html#42e9b7616956cf94" class="i property">Length</a>;
			<b>if</b> (<span class="r71 r">ptr</span> == 0)
				<span class="r71 r">ptr</span> += 46; <span class="c">// skip the &quot;tree ...&quot; line.</span>
			<b>while</b> (<span class="r71 r">ptr</span> &lt; <span class="r72 r">sz</span> &amp;&amp; <span class="r70 r">b</span>[<span class="r71 r">ptr</span>] == (<b>byte</b>)<span class="s">&#39;p&#39;</span>)
				<span class="r71 r">ptr</span> += 48; <span class="c">// skip this parent.</span>
			<b>if</b> (<span class="r71 r">ptr</span> &lt; <span class="r72 r">sz</span> &amp;&amp; <span class="r70 r">b</span>[<span class="r71 r">ptr</span>] == (<b>byte</b>)<span class="s">&#39;a&#39;</span>)
				<span class="r71 r">ptr</span> = <a href="#0989702123852d37" class="i method">nextLF</a>(<span class="r70 r">b</span>, <span class="r71 r">ptr</span>);
			<b>return</b> <a href="#8d5e78f7413720c3" class="i method">match</a>(<span class="r70 r">b</span>, <span class="r71 r">ptr</span>, <a href="../ObjectChecker.cs.html#366626676af05377" class="t t">ObjectChecker</a>.<a href="../ObjectChecker.cs.html#e9a2cd4af428d1af" class="i field">committer</a>);
		}

		<span class="c">/**</span>
         <span class="c">*</span><span class="c"> Locate the &quot;tagger &quot; header line data.</span>
         <span class="c">*</span>
         <span class="c">*</span><span class="c"> @param b</span>
         <span class="c">*</span><span class="c">            buffer to scan.</span>
         <span class="c">*</span><span class="c"> @param ptr</span>
         <span class="c">*</span><span class="c">            position in buffer to start the scan at. Most callers should</span>
         <span class="c">*</span><span class="c">            pass 0 to ensure the scan starts from the beginning of the tag</span>
         <span class="c">*</span><span class="c">            buffer and does not accidentally look at message body.</span>
         <span class="c">*</span><span class="c"> @return position just After the space in &quot;tagger &quot;, so the first</span>
         <span class="c">*</span><span class="c">         character of the tagger&#39;s name. If no tagger header can be</span>
         <span class="c">*</span><span class="c">         located -1 is returned.</span>
         <span class="c">*/</span>
		<b>public static int</b> <a id="bba663a08014cc77" href="../R/bba663a08014cc77.html" target="n" data-glyph="72,1" class="i method">tagger</a>(<b>byte</b>[] <span id="r73 rd" class="r73 r">b</span>, <b>int</b> <span id="r74 rd" class="r74 r">ptr</span>)
		{
			<b>int</b> <span id="r75 rd" class="r75 r">sz</span> = <span class="r73 r">b</span>.<a href="@0@mscorlib/A.html#42e9b7616956cf94" class="i property">Length</a>;
			<b>if</b> (<span class="r74 r">ptr</span> == 0)
				<span class="r74 r">ptr</span> += 48; <span class="c">// skip the &quot;object ...&quot; line.</span>
			<b>while</b> (<span class="r74 r">ptr</span> &lt; <span class="r75 r">sz</span>)
			{
				<b>if</b> (<span class="r73 r">b</span>[<span class="r74 r">ptr</span>] == (<b>byte</b>)<span class="s">&#39;\n&#39;</span>)
					<b>return</b> -1;
				<b>int</b> <span id="r76 rd" class="r76 r">m</span> = <a href="#8d5e78f7413720c3" class="i method">match</a>(<span class="r73 r">b</span>, <span class="r74 r">ptr</span>, <a href="../ObjectChecker.cs.html#366626676af05377" class="t t">ObjectChecker</a>.<a href="../ObjectChecker.cs.html#3fea91523f8e1772" class="i field">tagger</a>);
				<b>if</b> (<span class="r76 r">m</span> &gt;= 0)
					<b>return</b> <span class="r76 r">m</span>;
				<span class="r74 r">ptr</span> = <a href="#0989702123852d37" class="i method">nextLF</a>(<span class="r73 r">b</span>, <span class="r74 r">ptr</span>);
			}
			<b>return</b> -1;
		}

		<span class="c">/**</span>
         <span class="c">*</span><span class="c"> Locate the &quot;encoding &quot; header line.</span>
         <span class="c">*</span><span class="c"> </span>
         <span class="c">*</span><span class="c"> @param b</span>
         <span class="c">*</span><span class="c">            buffer to scan.</span>
         <span class="c">*</span><span class="c"> @param ptr</span>
         <span class="c">*</span><span class="c">            position in buffer to start the scan at. Most callers should</span>
         <span class="c">*</span><span class="c">            pass 0 to ensure the scan starts from the beginning of the</span>
         <span class="c">*</span><span class="c">            buffer and does not accidentally look at the message body.</span>
         <span class="c">*</span><span class="c"> @return position just After the space in &quot;encoding &quot;, so the first</span>
         <span class="c">*</span><span class="c">         character of the encoding&#39;s name. If no encoding header can be</span>
         <span class="c">*</span><span class="c">         located -1 is returned (and UTF-8 should be assumed).</span>
         <span class="c">*/</span>
		<b>public static int</b> <a id="4b6b1a854b0d11c6" href="../R/4b6b1a854b0d11c6.html" target="n" data-glyph="72,1" class="i method">encoding</a>(<b>byte</b>[] <span id="r77 rd" class="r77 r">b</span>, <b>int</b> <span id="r78 rd" class="r78 r">ptr</span>)
		{
			<b>int</b> <span id="r79 rd" class="r79 r">sz</span> = <span class="r77 r">b</span>.<a href="@0@mscorlib/A.html#42e9b7616956cf94" class="i property">Length</a>;
			<b>while</b> (<span class="r78 r">ptr</span> &lt; <span class="r79 r">sz</span>)
			{
				<b>if</b> (<span class="r77 r">b</span>[<span class="r78 r">ptr</span>] == <span class="s">&#39;\n&#39;</span>)
					<b>return</b> -1;
				<b>if</b> (<span class="r77 r">b</span>[<span class="r78 r">ptr</span>] == <span class="s">&#39;e&#39;</span>)
					<b>break</b>;
				<span class="r78 r">ptr</span> = <a href="#0989702123852d37" class="i method">nextLF</a>(<span class="r77 r">b</span>, <span class="r78 r">ptr</span>);
			}
			<b>return</b> <a href="#8d5e78f7413720c3" class="i method">match</a>(<span class="r77 r">b</span>, <span class="r78 r">ptr</span>, <a href="../ObjectChecker.cs.html#366626676af05377" class="t t">ObjectChecker</a>.<a href="../ObjectChecker.cs.html#14cda0f1557b37a1" class="i field">encoding</a>);
		}

		<span class="c">/**</span>
         <span class="c">*</span><span class="c"> Parse the &quot;encoding &quot; header into a character set reference.</span>
         <span class="c">*</span><span class="c"> </span><span class="c">&lt;</span><span class="c">para</span><span class="c"> </span><span class="c">/&gt;</span>
         <span class="c">*</span><span class="c"> Locates the &quot;encoding &quot; header (if present) by first calling</span>
         <span class="c">*</span><span class="c"> {@link #encoding(byte[], int)} and then returns the proper character set</span>
         <span class="c">*</span><span class="c"> to Apply to this buffer to evaluate its contents as character data.</span>
         <span class="c">*</span><span class="c"> </span><span class="c">&lt;</span><span class="c">para</span><span class="c"> </span><span class="c">/&gt;</span>
         <span class="c">*</span><span class="c"> If no encoding header is present, {@link Constants#CHARSET} is assumed.</span>
         <span class="c">*</span><span class="c"> </span>
         <span class="c">*</span><span class="c"> @param b</span>
         <span class="c">*</span><span class="c">            buffer to scan.</span>
         <span class="c">*</span><span class="c"> @return the Java character set representation. Never null.</span>
         <span class="c">*/</span>
		<b>public static</b> <a href="@0@mscorlib/A.html#3b6090c501893c25" class="t t">Encoding</a> <a id="41ecea02b254c57c" href="../R/41ecea02b254c57c.html" target="n" data-glyph="72,1" class="i method">parseEncoding</a>(<b>byte</b>[] <span id="r80 rd" class="r80 r">b</span>)
		{
			<b>int</b> <span id="r81 rd" class="r81 r">enc</span> = <a href="#4b6b1a854b0d11c6" class="i method">encoding</a>(<span class="r80 r">b</span>, 0);
			<b>if</b> (<span class="r81 r">enc</span> &lt; 0)
			{
			    <b>return</b> <a href="../Constants.cs.html#4c9cf80bf668e5fb" class="t t">Constants</a>.<a href="../Constants.cs.html#b2fcdc67ec48e578" class="i field">CHARSET</a>;
			}

			<b>int</b> <span id="r82 rd" class="r82 r">lf</span> = <a href="#0989702123852d37" class="i method">nextLF</a>(<span class="r80 r">b</span>, <span class="r81 r">enc</span>);
			<b>string</b> <span id="r83 rd" class="r83 r">encodingName</span> = <a href="#ceca22962c12c579" class="i method">decode</a>(<a href="../Constants.cs.html#4c9cf80bf668e5fb" class="t t">Constants</a>.<a href="../Constants.cs.html#b2fcdc67ec48e578" class="i field">CHARSET</a>, <span class="r80 r">b</span>, <span class="r81 r">enc</span>, <span class="r82 r">lf</span> - 1);

			<b>return</b> <a href="JavaHelper/Charset.cs.html#deb6aa96e25fd4d7" class="t t">Charset</a>.<a href="JavaHelper/Charset.cs.html#053612684daba28e" class="i method">forName</a>(<span class="r83 r">encodingName</span>);
		}

		<span class="c">/**</span>
         <span class="c">*</span><span class="c"> Parse a name line (e.g. author, committer, tagger) into a PersonIdent.</span>
         <span class="c">*</span><span class="c"> </span><span class="c">&lt;</span><span class="c">para</span><span class="c"> </span><span class="c">/&gt;</span>
         <span class="c">*</span><span class="c"> When passing in a value for </span><span class="c">&lt;</span><span class="c">code</span><span class="c">&gt;</span><span class="c">nameB</span><span class="c">&lt;/</span><span class="c">code</span><span class="c">&gt;</span><span class="c"> callers should use the</span>
         <span class="c">*</span><span class="c"> return value of {@link #author(byte[], int)} or</span>
         <span class="c">*</span><span class="c"> {@link #committer(byte[], int)}, as these methods provide the proper</span>
         <span class="c">*</span><span class="c"> position within the buffer.</span>
         <span class="c">*</span><span class="c"> </span>
         <span class="c">*</span><span class="c"> @param raw</span>
         <span class="c">*</span><span class="c">            the buffer to parse character data from.</span>
         <span class="c">*</span><span class="c"> @param nameB</span>
         <span class="c">*</span><span class="c">            first position of the identity information. This should be the</span>
         <span class="c">*</span><span class="c">            first position After the space which delimits the header field</span>
         <span class="c">*</span><span class="c">            name (e.g. &quot;author&quot; or &quot;committer&quot;) from the rest of the</span>
         <span class="c">*</span><span class="c">            identity line.</span>
         <span class="c">*</span><span class="c"> @return the parsed identity. Never null.</span>
         <span class="c">*/</span>
		<b>public static</b> <a href="../PersonIdent.cs.html#317a34072618d9ff" class="t t">PersonIdent</a> <a id="09ea491fc7519e78" href="../R/09ea491fc7519e78.html" target="n" data-glyph="72,1" class="i method">parsePersonIdent</a>(<b>byte</b>[] <span id="r84 rd" class="r84 r">raw</span>, <b>int</b> <span id="r85 rd" class="r85 r">nameB</span>)
		{
			<a href="@0@mscorlib/A.html#3b6090c501893c25" class="t t">Encoding</a> <span id="r86 rd" class="r86 r">cs</span> = <a href="#41ecea02b254c57c" class="i method">parseEncoding</a>(<span class="r84 r">raw</span>);
			<b>int</b> <span id="r87 rd" class="r87 r">emailB</span> = <a href="#bfac7916e9a2bc6d" class="i method">nextLF</a>(<span class="r84 r">raw</span>, <span class="r85 r">nameB</span>, (<b>byte</b>)<span class="s">&#39;&lt;&#39;</span>);
			<b>int</b> <span id="r88 rd" class="r88 r">emailE</span> = <a href="#bfac7916e9a2bc6d" class="i method">nextLF</a>(<span class="r84 r">raw</span>, <span class="r87 r">emailB</span>, (<b>byte</b>)<span class="s">&#39;&gt;&#39;</span>);

			<b>string</b> <span id="r89 rd" class="r89 r">name</span> = <a href="#ceca22962c12c579" class="i method">decode</a>(<span class="r86 r">cs</span>, <span class="r84 r">raw</span>, <span class="r85 r">nameB</span>, <span class="r87 r">emailB</span> - 2);
			<b>string</b> <span id="r90 rd" class="r90 r">email</span> = <a href="#ceca22962c12c579" class="i method">decode</a>(<span class="r86 r">cs</span>, <span class="r84 r">raw</span>, <span class="r87 r">emailB</span>, <span class="r88 r">emailE</span> - 1);

			<a href="MutableInteger.cs.html#5b3a0be7485d5537" class="k">var</a> <span id="r91 rd" class="r91 r">ptrout</span> = <b>new</b> <a href="MutableInteger.cs.html#5b3a0be7485d5537" class="t constructor">MutableInteger</a>();
			<b>long</b> <span id="r92 rd" class="r92 r">when</span> = <a href="#d90f20e32b61eae7" class="i method">parseLongBase10</a>(<span class="r84 r">raw</span>, <span class="r88 r">emailE</span> + 1, <span class="r91 r">ptrout</span>);
			<b>int</b> <span id="r93 rd" class="r93 r">tz</span> = <a href="#e71b001731a86398" class="i method">parseTimeZoneOffset</a>(<span class="r84 r">raw</span>, <span class="r91 r">ptrout</span>.<a href="MutableInteger.cs.html#1eabd2e28ad6a7f0" class="i field">value</a>);

			<b>return</b> <b>new</b> <a href="../PersonIdent.cs.html#d0c5792010f8df1b" class="t constructor">PersonIdent</a>(<span class="r89 r">name</span>, <span class="r90 r">email</span>, <span class="r92 r">when</span> * 1000, <span class="r93 r">tz</span>);
		}


		<span class="c">/**</span>
         <span class="c">*</span><span class="c"> Parse a name data (e.g. as within a reflog) into a PersonIdent.</span>
         <span class="c">*</span><span class="c"> </span><span class="c">&lt;</span><span class="c">para</span><span class="c"> </span><span class="c">/&gt;</span>
         <span class="c">*</span><span class="c"> When passing in a value for </span><span class="c">&lt;</span><span class="c">code</span><span class="c">&gt;</span><span class="c">nameB</span><span class="c">&lt;/</span><span class="c">code</span><span class="c">&gt;</span><span class="c"> callers should use the</span>
         <span class="c">*</span><span class="c"> return value of {@link #author(byte[], int)} or</span>
         <span class="c">*</span><span class="c"> {@link #committer(byte[], int)}, as these methods provide the proper</span>
         <span class="c">*</span><span class="c"> position within the buffer.</span>
         <span class="c">*</span>
         <span class="c">*</span><span class="c"> @param raw</span>
         <span class="c">*</span><span class="c">            the buffer to parse character data from.</span>
         <span class="c">*</span><span class="c"> @param nameB</span>
         <span class="c">*</span><span class="c">            first position of the identity information. This should be the</span>
         <span class="c">*</span><span class="c">            first position After the space which delimits the header field</span>
         <span class="c">*</span><span class="c">            name (e.g. &quot;author&quot; or &quot;committer&quot;) from the rest of the</span>
         <span class="c">*</span><span class="c">            identity line.</span>
         <span class="c">*</span><span class="c"> @return the parsed identity. Never null.</span>
         <span class="c">*/</span>
		<b>public static</b> <a href="../PersonIdent.cs.html#317a34072618d9ff" class="t t">PersonIdent</a> <a id="9d31c5c527d1ba66" href="../R/9d31c5c527d1ba66.html" target="n" data-glyph="72,1" class="i method">parsePersonIdentOnly</a>(<b>byte</b>[] <span id="r94 rd" class="r94 r">raw</span>, <b>int</b> <span id="r95 rd" class="r95 r">nameB</span>)
		{
			<b>int</b> <span id="r96 rd" class="r96 r">stop</span> = <a href="#0989702123852d37" class="i method">nextLF</a>(<span class="r94 r">raw</span>, <span class="r95 r">nameB</span>);
			<b>int</b> <span id="r97 rd" class="r97 r">emailB</span> = <a href="#bfac7916e9a2bc6d" class="i method">nextLF</a>(<span class="r94 r">raw</span>, <span class="r95 r">nameB</span>, (<b>byte</b>)<span class="s">&#39;&lt;&#39;</span>);
			<b>int</b> <span id="r98 rd" class="r98 r">emailE</span> = <a href="#bfac7916e9a2bc6d" class="i method">nextLF</a>(<span class="r94 r">raw</span>, <span class="r97 r">emailB</span>, (<b>byte</b>)<span class="s">&#39;&gt;&#39;</span>);
			<b>string</b> <span id="r99 rd" class="r99 r">name</span>;
			<b>string</b> <span id="r100 rd" class="r100 r">email</span>;
			<b>if</b> (<span class="r98 r">emailE</span> &lt; <span class="r96 r">stop</span>)
			{
				<span class="r100 r">email</span> = <a href="#1b6eaa7d1442116c" class="i method">decode</a>(<span class="r94 r">raw</span>, <span class="r97 r">emailB</span>, <span class="r98 r">emailE</span> - 1);
			}
			<b>else</b>
			{
				<span class="r100 r">email</span> = <span class="s">&quot;invalid&quot;</span>;
			}
			<b>if</b> (<span class="r97 r">emailB</span> &lt; <span class="r96 r">stop</span>)
				<span class="r99 r">name</span> = <a href="#1b6eaa7d1442116c" class="i method">decode</a>(<span class="r94 r">raw</span>, <span class="r95 r">nameB</span>, <span class="r97 r">emailB</span> - 2);
			<b>else</b>
				<span class="r99 r">name</span> = <a href="#1b6eaa7d1442116c" class="i method">decode</a>(<span class="r94 r">raw</span>, <span class="r95 r">nameB</span>, <span class="r96 r">stop</span>);

			<a href="MutableInteger.cs.html#5b3a0be7485d5537" class="t t">MutableInteger</a> <span id="r101 rd" class="r101 r">ptrout</span> = <b>new</b> <a href="MutableInteger.cs.html#5b3a0be7485d5537" class="t constructor">MutableInteger</a>();
			<b>long</b> <span id="r102 rd" class="r102 r">when</span>;
			<b>int</b> <span id="r103 rd" class="r103 r">tz</span>;
			<b>if</b> (<span class="r98 r">emailE</span> &lt; <span class="r96 r">stop</span>)
			{
				<span class="r102 r">when</span> = <a href="#d90f20e32b61eae7" class="i method">parseLongBase10</a>(<span class="r94 r">raw</span>, <span class="r98 r">emailE</span> + 1, <span class="r101 r">ptrout</span>);
				<span class="r103 r">tz</span> = <a href="#e71b001731a86398" class="i method">parseTimeZoneOffset</a>(<span class="r94 r">raw</span>, <span class="r101 r">ptrout</span>.<a href="MutableInteger.cs.html#1eabd2e28ad6a7f0" class="i field">value</a>);
			}
			<b>else</b>
			{
				<span class="r102 r">when</span> = 0;
				<span class="r103 r">tz</span> = 0;
			}
			<b>return</b> <b>new</b> <a href="../PersonIdent.cs.html#d0c5792010f8df1b" class="t constructor">PersonIdent</a>(<span class="r99 r">name</span>, <span class="r100 r">email</span>, <span class="r102 r">when</span> * 1000, <span class="r103 r">tz</span>);
		}

		<span class="c">/**</span>
         <span class="c">*</span><span class="c"> Locate the end of a footer line key string.</span>
         <span class="c">*</span><span class="c"> </span><span class="c">&lt;</span><span class="c">para</span><span class="c"> </span><span class="c">/&gt;</span>
         <span class="c">*</span><span class="c"> If the region at {@code raw[ptr]} matches {@code ^[A-Za-z0-9-]+:} (e.g.</span>
         <span class="c">*</span><span class="c"> &quot;Signed-off-by: A. U. Thor\n&quot;) then this method returns the position of</span>
         <span class="c">*</span><span class="c"> the first &#39;:&#39;.</span>
         <span class="c">*</span><span class="c"> </span><span class="c">&lt;</span><span class="c">para</span><span class="c"> </span><span class="c">/&gt;</span>
         <span class="c">*</span><span class="c"> If the region at {@code raw[ptr]} does not match {@code ^[A-Za-z0-9-]+:}</span>
         <span class="c">*</span><span class="c"> then this method returns -1.</span>
         <span class="c">*</span>
         <span class="c">*</span><span class="c"> @param raw</span>
         <span class="c">*</span><span class="c">            buffer to scan.</span>
         <span class="c">*</span><span class="c"> @param ptr</span>
         <span class="c">*</span><span class="c">            first position within raw to consider as a footer line key.</span>
         <span class="c">*</span><span class="c"> @return position of the &#39;:&#39; which terminates the footer line key if this</span>
         <span class="c">*</span><span class="c">         is otherwise a valid footer line key; otherwise -1.</span>
         <span class="c">*/</span>
		<b>public static int</b> <a id="63a455ae2bafe9fe" href="../R/63a455ae2bafe9fe.html" target="n" data-glyph="72,1" class="i method">endOfFooterLineKey</a>(<b>byte</b>[] <span id="r104 rd" class="r104 r">raw</span>, <b>int</b> <span id="r105 rd" class="r105 r">ptr</span>)
		{
			<b>try</b>
			{
				<b>for</b> (; ; )
				{
					<b>byte</b> <span id="r106 rd" class="r106 r">c</span> = <span class="r104 r">raw</span>[<span class="r105 r">ptr</span>];
					<b>if</b> (<a href="#ff6a954e6db9723a" class="i field">footerLineKeyChars</a>[<span class="r106 r">c</span>] == 0)
					{
						<b>if</b> (<span class="r106 r">c</span> == (<b>byte</b>)<span class="s">&#39;:&#39;</span>)
							<b>return</b> <span class="r105 r">ptr</span>;
						<b>return</b> -1;
					}
					<span class="r105 r">ptr</span>++;
				}
			}
			<b>catch</b> (<a href="@0@mscorlib/A.html#acba961d918b2408" class="t t">IndexOutOfRangeException</a>)
			{
				<b>return</b> -1;
			}
		}

		<b>private static string</b> <a id="519470d745db329f" href="../R/519470d745db329f.html" target="n" data-glyph="76,1" class="i method">decode</a>(<b>byte</b>[] <span id="r107 rd" class="r107 r">b</span>, <a href="@0@mscorlib/A.html#3b6090c501893c25" class="t t">Encoding</a> <span id="r108 rd" class="r108 r">charset</span>)
		{
			<b>return</b> <span class="r108 r">charset</span>.<a href="@0@mscorlib/A.html#7310c9cccfaecd17" class="i method">GetString</a>(<span class="r107 r">b</span>);
		}

		<span class="c">/**</span>
         <span class="c">*</span><span class="c"> Decode a buffer under UTF-8, if possible.</span>
         <span class="c">*</span>
         <span class="c">*</span><span class="c"> If the byte stream cannot be decoded that way, the platform default is tried</span>
         <span class="c">*</span><span class="c"> and if that too fails, the fail-safe ISO-8859-1 encoding is tried.</span>
         <span class="c">*</span><span class="c"> </span>
         <span class="c">*</span><span class="c"> @param buffer</span>
         <span class="c">*</span><span class="c">            buffer to pull raw bytes from.</span>
         <span class="c">*</span><span class="c"> @return a string representation of the range </span><span class="c">&lt;</span><span class="c">code</span><span class="c">&gt;</span><span class="c">[start,end)</span><span class="c">&lt;/</span><span class="c">code</span><span class="c">&gt;</span><span class="c">,</span>
         <span class="c">*</span><span class="c">         After decoding the region through the specified character set.</span>
         <span class="c">*/</span>
		<b>public static string</b> <a id="7b0958d23f8e00a2" href="../R/7b0958d23f8e00a2.html" target="n" data-glyph="72,1" class="i method">decode</a>(<b>byte</b>[] <span id="r109 rd" class="r109 r">buffer</span>)
		{
			<b>return</b> <a href="#1b6eaa7d1442116c" class="i method">decode</a>(<span class="r109 r">buffer</span>, 0, <span class="r109 r">buffer</span>.<a href="@0@mscorlib/A.html#42e9b7616956cf94" class="i property">Length</a>);
		}

		<span class="c">/**</span>
         <span class="c">*</span><span class="c"> Decode a buffer under UTF-8, if possible.</span>
         <span class="c">*</span>
         <span class="c">*</span><span class="c"> If the byte stream cannot be decoded that way, the platform default is</span>
         <span class="c">*</span><span class="c"> tried and if that too fails, the fail-safe ISO-8859-1 encoding is tried.</span>
         <span class="c">*</span>
         <span class="c">*</span><span class="c"> @param buffer</span>
         <span class="c">*</span><span class="c">            buffer to pull raw bytes from.</span>
         <span class="c">*</span><span class="c"> @param start</span>
         <span class="c">*</span><span class="c">            start position in buffer</span>
         <span class="c">*</span><span class="c"> @param end</span>
         <span class="c">*</span><span class="c">            one position past the last location within the buffer to take</span>
         <span class="c">*</span><span class="c">            data from.</span>
         <span class="c">*</span><span class="c"> @return a string representation of the range </span><span class="c">&lt;</span><span class="c">code</span><span class="c">&gt;</span><span class="c">[start,end)</span><span class="c">&lt;/</span><span class="c">code</span><span class="c">&gt;</span><span class="c">,</span>
         <span class="c">*</span><span class="c">         After decoding the region through the specified character set.</span>
         <span class="c">*/</span>
		<b>public static string</b> <a id="1b6eaa7d1442116c" href="../R/1b6eaa7d1442116c.html" target="n" data-glyph="72,1" class="i method">decode</a>(<b>byte</b>[] <span id="r110 rd" class="r110 r">buffer</span>, <b>int</b> <span id="r111 rd" class="r111 r">start</span>, <b>int</b> <span id="r112 rd" class="r112 r">end</span>)
		{
			<b>return</b> <a href="#ceca22962c12c579" class="i method">decode</a>(<a href="../Constants.cs.html#4c9cf80bf668e5fb" class="t t">Constants</a>.<a href="../Constants.cs.html#b2fcdc67ec48e578" class="i field">CHARSET</a>, <span class="r110 r">buffer</span>, <span class="r111 r">start</span>, <span class="r112 r">end</span>);
		}

		<span class="c">/**</span>
         <span class="c">*</span><span class="c"> Decode a buffer under the specified character set if possible.</span>
         <span class="c">*</span>
         <span class="c">*</span><span class="c"> If the byte stream cannot be decoded that way, the platform default is tried</span>
         <span class="c">*</span><span class="c"> and if that too fails, the fail-safe ISO-8859-1 encoding is tried.</span>
         <span class="c">*</span><span class="c"> </span>
         <span class="c">*</span><span class="c"> @param cs</span>
         <span class="c">*</span><span class="c">            character set to use when decoding the buffer.</span>
         <span class="c">*</span><span class="c"> @param buffer</span>
         <span class="c">*</span><span class="c">            buffer to pull raw bytes from.</span>
         <span class="c">*</span><span class="c"> @return a string representation of the range </span><span class="c">&lt;</span><span class="c">code</span><span class="c">&gt;</span><span class="c">[start,end)</span><span class="c">&lt;/</span><span class="c">code</span><span class="c">&gt;</span><span class="c">,</span>
         <span class="c">*</span><span class="c">         After decoding the region through the specified character set.</span>
         <span class="c">*/</span>
		<b>public static string</b> <a id="e4aa041c71df1ed5" href="../R/e4aa041c71df1ed5.html" target="n" data-glyph="72,1" class="i method">decode</a>(<a href="@0@mscorlib/A.html#3b6090c501893c25" class="t t">Encoding</a> <span id="r113 rd" class="r113 r">cs</span>, <b>byte</b>[] <span id="r114 rd" class="r114 r">buffer</span>)
		{
			<b>return</b> <a href="#ceca22962c12c579" class="i method">decode</a>(<span class="r113 r">cs</span>, <span class="r114 r">buffer</span>, 0, <span class="r114 r">buffer</span>.<a href="@0@mscorlib/A.html#42e9b7616956cf94" class="i property">Length</a>);
		}

		<span class="c">/**</span>
         <span class="c">*</span><span class="c"> Decode a region of the buffer under the specified character set if possible.</span>
         <span class="c">*</span>
         <span class="c">*</span><span class="c"> If the byte stream cannot be decoded that way, the platform default is tried</span>
         <span class="c">*</span><span class="c"> and if that too fails, the fail-safe ISO-8859-1 encoding is tried.</span>
         <span class="c">*</span><span class="c"> </span>
         <span class="c">*</span><span class="c"> @param cs</span>
         <span class="c">*</span><span class="c">            character set to use when decoding the buffer.</span>
         <span class="c">*</span><span class="c"> @param buffer</span>
         <span class="c">*</span><span class="c">            buffer to pull raw bytes from.</span>
         <span class="c">*</span><span class="c"> @param start</span>
         <span class="c">*</span><span class="c">            first position within the buffer to take data from.</span>
         <span class="c">*</span><span class="c"> @param end</span>
         <span class="c">*</span><span class="c">            one position past the last location within the buffer to take</span>
         <span class="c">*</span><span class="c">            data from.</span>
         <span class="c">*</span><span class="c"> @return a string representation of the range </span><span class="c">&lt;</span><span class="c">code</span><span class="c">&gt;</span><span class="c">[start,end)</span><span class="c">&lt;/</span><span class="c">code</span><span class="c">&gt;</span><span class="c">,</span>
         <span class="c">*</span><span class="c">         After decoding the region through the specified character set.</span>
         <span class="c">*/</span>
		<b>public static string</b> <a id="ceca22962c12c579" href="../R/ceca22962c12c579.html" target="n" data-glyph="72,1" class="i method">decode</a>(<a href="@0@mscorlib/A.html#3b6090c501893c25" class="t t">Encoding</a> <span id="r115 rd" class="r115 r">cs</span>, <b>byte</b>[] <span id="r116 rd" class="r116 r">buffer</span>, <b>int</b> <span id="r117 rd" class="r117 r">start</span>, <b>int</b> <span id="r118 rd" class="r118 r">end</span>)
		{
			<b>try</b>
			{
				<b>return</b> <a href="#0c7b4f3a022915f3" class="i method">decodeNoFallback</a>(<span class="r115 r">cs</span>, <span class="r116 r">buffer</span>, <span class="r117 r">start</span>, <span class="r118 r">end</span>);
			}
			<b>catch</b> (<a href="@0@mscorlib/A.html#10667fd97ad67501" class="t t">DecoderFallbackException</a>)
			{
				<span class="c">// Fall back to an ISO-8859-1 style encoding. At least all of</span>
				<span class="c">// the bytes will be present in the output.</span>
				<span class="c">//</span>
				<b>return</b> <a href="#fa380493c1cdf53a" class="i method">extractBinaryString</a>(<span class="r116 r">buffer</span>, <span class="r117 r">start</span>, <span class="r118 r">end</span>);
			}
		}

		<span class="c">/**</span>
         <span class="c">*</span><span class="c"> Decode a region of the buffer under the specified character set if</span>
         <span class="c">*</span><span class="c"> possible.</span>
         <span class="c">*</span>
         <span class="c">*</span><span class="c"> If the byte stream cannot be decoded that way, the platform default is</span>
         <span class="c">*</span><span class="c"> tried and if that too fails, an exception is thrown.</span>
         <span class="c">*</span>
         <span class="c">*</span><span class="c"> @param cs</span>
         <span class="c">*</span><span class="c">            character set to use when decoding the buffer.</span>
         <span class="c">*</span><span class="c"> @param buffer</span>
         <span class="c">*</span><span class="c">            buffer to pull raw bytes from.</span>
         <span class="c">*</span><span class="c"> @param start</span>
         <span class="c">*</span><span class="c">            first position within the buffer to take data from.</span>
         <span class="c">*</span><span class="c"> @param end</span>
         <span class="c">*</span><span class="c">            one position past the last location within the buffer to take</span>
         <span class="c">*</span><span class="c">            data from.</span>
         <span class="c">*</span><span class="c"> @return a string representation of the range </span><span class="c">&lt;</span><span class="c">code</span><span class="c">&gt;</span><span class="c">[start,end)</span><span class="c">&lt;/</span><span class="c">code</span><span class="c">&gt;</span><span class="c">,</span>
         <span class="c">*</span><span class="c">         After decoding the region through the specified character set.</span>
         <span class="c">*</span><span class="c"> @throws CharacterCodingException</span>
         <span class="c">*</span><span class="c">             the input is not in any of the tested character sets.</span>
         <span class="c">*/</span>
		<b>public static string</b> <a id="0c7b4f3a022915f3" href="../R/0c7b4f3a022915f3.html" target="n" data-glyph="72,1" class="i method">decodeNoFallback</a>(<a href="@0@mscorlib/A.html#3b6090c501893c25" class="t t">Encoding</a> <span id="r119 rd" class="r119 r">cs</span>, <b>byte</b>[] <span id="r120 rd" class="r120 r">buffer</span>, <b>int</b> <span id="r121 rd" class="r121 r">start</span>, <b>int</b> <span id="r122 rd" class="r122 r">end</span>)
		{
			<span class="c">// ByteBuffer b = ByteBuffer.wrap(buffer, start, end - start);</span>
			<span class="c">//b.mark();</span>
			<b>byte</b>[] <span id="r123 rd" class="r123 r">b</span> = <b>new</b> <b>byte</b>[<span class="r122 r">end</span> - <span class="r121 r">start</span>];
			<b>for</b> (<b>int</b> <span id="r124 rd" class="r124 r">i</span> = 0; <span class="r124 r">i</span> &lt; <span class="r122 r">end</span> - <span class="r121 r">start</span>; <span class="r124 r">i</span>++)
				<span class="r123 r">b</span>[<span class="r124 r">i</span>] = <span class="r120 r">buffer</span>[<span class="r121 r">start</span> + <span class="r124 r">i</span>];


              <span class="c">// Try our built-in favorite. The assumption here is that</span>
                 <span class="c">// decoding will fail if the data is not actually encoded</span>
                 <span class="c">// using that encoder.</span>
                 <span class="c">//</span>
                 <b>try</b> {
                         <b>return</b> <a href="#519470d745db329f" class="i method">decode</a>(<span class="r123 r">b</span>, <a href="../Constants.cs.html#4c9cf80bf668e5fb" class="t t">Constants</a>.<a href="../Constants.cs.html#b2fcdc67ec48e578" class="i field">CHARSET</a>);
                 } <b>catch</b> (<a href="@0@mscorlib/A.html#10667fd97ad67501" class="t t">DecoderFallbackException</a>) {
                         <span class="c">//b.reset();</span>
                 }

                 <b>if</b> (!<span class="r119 r">cs</span>.<a href="@0@mscorlib/A.html#5a3af98b30ba1b48" class="i method">Equals</a>(<a href="../Constants.cs.html#4c9cf80bf668e5fb" class="t t">Constants</a>.<a href="../Constants.cs.html#b2fcdc67ec48e578" class="i field">CHARSET</a>)) {
                         <span class="c">// Try the suggested encoding, it might be right since it was</span>
                         <span class="c">// provided by the caller.</span>
                         <span class="c">//</span>
                         <b>try</b> {
                                 <b>return</b> <a href="#519470d745db329f" class="i method">decode</a>(<span class="r123 r">b</span>, <span class="r119 r">cs</span>);
                         } <b>catch</b> (<a href="@0@mscorlib/A.html#10667fd97ad67501" class="t t">DecoderFallbackException</a>) {
                                 <span class="c">//b.reset();</span>
                         }
                 }

                 <span class="c">// Try the default character set. A small group of people</span>
                 <span class="c">// might actually use the same (or very similar) locale.</span>
                 <span class="c">//</span>
                 <a href="@0@mscorlib/A.html#3b6090c501893c25" class="t t">Encoding</a> <span id="r125 rd" class="r125 r">defcs</span> = <a href="@0@mscorlib/A.html#3b6090c501893c25" class="t t">Encoding</a>.<a href="@0@mscorlib/A.html#1c75de327ad88c0a" class="i property">Default</a>;
                 <b>if</b> (!<span class="r125 r">defcs</span>.<a href="@0@mscorlib/A.html#5a3af98b30ba1b48" class="i method">Equals</a>(<span class="r119 r">cs</span>) &amp;&amp; !<span class="r125 r">defcs</span>.<a href="@0@mscorlib/A.html#5a3af98b30ba1b48" class="i method">Equals</a>(<a href="../Constants.cs.html#4c9cf80bf668e5fb" class="t t">Constants</a>.<a href="../Constants.cs.html#b2fcdc67ec48e578" class="i field">CHARSET</a>)) {
                         <b>try</b> {
                                 <b>return</b> <a href="#519470d745db329f" class="i method">decode</a>(<span class="r123 r">b</span>, <span class="r125 r">defcs</span>);
                         }
                         <b>catch</b> (<a href="@0@mscorlib/A.html#10667fd97ad67501" class="t t">DecoderFallbackException</a>)
                         {
                                 <span class="c">//b.reset();</span>
                         }
                 }

                 <b>throw</b> <b>new</b> <a href="@0@mscorlib/A.html#85b6eb0b015eac24" class="t constructor">DecoderFallbackException</a>(<b>string</b>.<a href="@0@mscorlib/A.html#9d5604d4425b216f" class="i method">Format</a>(<span class="s">&quot;Unable to decode provided buffer using encoder &#39;{0}&#39;.&quot;</span>, <span class="r119 r">cs</span>.<a href="@0@mscorlib/A.html#00987bab2ca262fa" class="i property">WebName</a>) );
		}

		<span class="c">/**</span>
         <span class="c">*</span><span class="c"> Decode a region of the buffer under the ISO-8859-1 encoding.</span>
         <span class="c">*</span>
         <span class="c">*</span><span class="c"> Each byte is treated as a single character in the 8859-1 character</span>
         <span class="c">*</span><span class="c"> encoding, performing a raw binary-&gt;char conversion.</span>
         <span class="c">*</span>
         <span class="c">*</span><span class="c"> @param buffer</span>
         <span class="c">*</span><span class="c">            buffer to pull raw bytes from.</span>
         <span class="c">*</span><span class="c"> @param start</span>
         <span class="c">*</span><span class="c">            first position within the buffer to take data from.</span>
         <span class="c">*</span><span class="c"> @param end</span>
         <span class="c">*</span><span class="c">            one position past the last location within the buffer to take</span>
         <span class="c">*</span><span class="c">            data from.</span>
         <span class="c">*</span><span class="c"> @return a string representation of the range </span><span class="c">&lt;</span><span class="c">code</span><span class="c">&gt;</span><span class="c">[start,end)</span><span class="c">&lt;/</span><span class="c">code</span><span class="c">&gt;</span><span class="c">.</span>
         <span class="c">*/</span>
		<b>public static string</b> <a id="fa380493c1cdf53a" href="../R/fa380493c1cdf53a.html" target="n" data-glyph="72,1" class="i method">extractBinaryString</a>(<b>byte</b>[] <span id="r126 rd" class="r126 r">buffer</span>, <b>int</b> <span id="r127 rd" class="r127 r">start</span>, <b>int</b> <span id="r128 rd" class="r128 r">end</span>)
		{
			<a href="@0@mscorlib/A.html#adf60ee46ebd299f" class="t t">StringBuilder</a> <span id="r129 rd" class="r129 r">r</span> = <b>new</b> <a href="@0@mscorlib/A.html#ec674e2123a44860" class="t constructor">StringBuilder</a>(<span class="r128 r">end</span> - <span class="r127 r">start</span>);
			<b>for</b> (<b>int</b> <span id="r130 rd" class="r130 r">i</span> = <span class="r127 r">start</span>; <span class="r130 r">i</span> &lt; <span class="r128 r">end</span>; <span class="r130 r">i</span>++)
				<span class="r129 r">r</span>.<a href="@0@mscorlib/A.html#a2e7c78d85807da5" class="i method">Append</a>((<b>char</b>)(<span class="r126 r">buffer</span>[<span class="r130 r">i</span>] &amp; 0xff));
			<b>return</b> <span class="r129 r">r</span>.<a href="@0@mscorlib/A.html#5a97da49a158a3c9" class="i method">ToString</a>();
		}

		<span class="c">/**</span>
        <span class="c">*</span><span class="c"> Locate the position of the commit message body.</span>
        <span class="c">*</span><span class="c"> </span>
        <span class="c">*</span><span class="c"> @param b</span>
        <span class="c">*</span><span class="c">            buffer to scan.</span>
        <span class="c">*</span><span class="c"> @param ptr</span>
        <span class="c">*</span><span class="c">            position in buffer to start the scan at. Most callers should</span>
        <span class="c">*</span><span class="c">            pass 0 to ensure the scan starts from the beginning of the</span>
        <span class="c">*</span><span class="c">            commit buffer.</span>
        <span class="c">*</span><span class="c"> @return position of the user&#39;s message buffer.</span>
        <span class="c">*/</span>
		<b>public static int</b> <a id="0b70e677c66bd7a9" href="../R/0b70e677c66bd7a9.html" target="n" data-glyph="72,1" class="i method">commitMessage</a>(<b>byte</b>[] <span id="r131 rd" class="r131 r">b</span>, <b>int</b> <span id="r132 rd" class="r132 r">ptr</span>)
		{
			<b>int</b> <span id="r133 rd" class="r133 r">sz</span> = <span class="r131 r">b</span>.<a href="@0@mscorlib/A.html#42e9b7616956cf94" class="i property">Length</a>;
			<b>if</b> (<span class="r132 r">ptr</span> == 0)
				<span class="r132 r">ptr</span> += 46; <span class="c">// skip the &quot;tree ...&quot; line.</span>
			<b>while</b> (<span class="r132 r">ptr</span> &lt; <span class="r133 r">sz</span> &amp;&amp; <span class="r131 r">b</span>[<span class="r132 r">ptr</span>] == (<b>byte</b>)<span class="s">&#39;p&#39;</span>)
				<span class="r132 r">ptr</span> += 48; <span class="c">// skip this parent.</span>

			<span class="c">// Skip any remaining header lines, ignoring what their actual</span>
			<span class="c">// header line type is. This is identical to the logic for a tag.</span>
			<span class="c">//</span>
			<b>return</b> <a href="#45e10a9b00144d19" class="i method">tagMessage</a>(<span class="r131 r">b</span>, <span class="r132 r">ptr</span>);
		}

		<span class="c">/**</span>
         <span class="c">*</span><span class="c"> Locate the position of the tag message body.</span>
         <span class="c">*</span>
         <span class="c">*</span><span class="c"> @param b</span>
         <span class="c">*</span><span class="c">            buffer to scan.</span>
         <span class="c">*</span><span class="c"> @param ptr</span>
         <span class="c">*</span><span class="c">            position in buffer to start the scan at. Most callers should</span>
         <span class="c">*</span><span class="c">            pass 0 to ensure the scan starts from the beginning of the tag</span>
         <span class="c">*</span><span class="c">            buffer.</span>
         <span class="c">*</span><span class="c"> @return position of the user&#39;s message buffer.</span>
         <span class="c">*/</span>
		<b>public static int</b> <a id="45e10a9b00144d19" href="../R/45e10a9b00144d19.html" target="n" data-glyph="72,1" class="i method">tagMessage</a>(<b>byte</b>[] <span id="r134 rd" class="r134 r">b</span>, <b>int</b> <span id="r135 rd" class="r135 r">ptr</span>)
		{
			<b>int</b> <span id="r136 rd" class="r136 r">sz</span> = <span class="r134 r">b</span>.<a href="@0@mscorlib/A.html#42e9b7616956cf94" class="i property">Length</a>;
			<b>if</b> (<span class="r135 r">ptr</span> == 0)
				<span class="r135 r">ptr</span> += 48; <span class="c">// skip the &quot;object ...&quot; line.</span>
			<b>while</b> (<span class="r135 r">ptr</span> &lt; <span class="r136 r">sz</span> &amp;&amp; <span class="r134 r">b</span>[<span class="r135 r">ptr</span>] != (<b>byte</b>)<span class="s">&#39;\n&#39;</span>)
				<span class="r135 r">ptr</span> = <a href="#0989702123852d37" class="i method">nextLF</a>(<span class="r134 r">b</span>, <span class="r135 r">ptr</span>);
			<b>if</b> (<span class="r135 r">ptr</span> &lt; <span class="r136 r">sz</span> &amp;&amp; <span class="r134 r">b</span>[<span class="r135 r">ptr</span>] == (<b>byte</b>)<span class="s">&#39;\n&#39;</span>)
				<b>return</b> <span class="r135 r">ptr</span> + 1;
			<b>return</b> -1;
		}

		<span class="c">/**</span>
         <span class="c">*</span><span class="c"> Locate the end of a paragraph.</span>
         <span class="c">*</span><span class="c"> </span><span class="c">&lt;</span><span class="c">para</span><span class="c"> </span><span class="c">/&gt;</span>
         <span class="c">*</span><span class="c"> A paragraph is ended by two consecutive LF bytes.</span>
         <span class="c">*</span><span class="c"> </span>
         <span class="c">*</span><span class="c"> @param b</span>
         <span class="c">*</span><span class="c">            buffer to scan.</span>
         <span class="c">*</span><span class="c"> @param start</span>
         <span class="c">*</span><span class="c">            position in buffer to start the scan at. Most callers will</span>
         <span class="c">*</span><span class="c">            want to pass the first position of the commit message (as</span>
         <span class="c">*</span><span class="c">            found by {@link #commitMessage(byte[], int)}.</span>
         <span class="c">*</span><span class="c"> @return position of the LF at the end of the paragraph;</span>
         <span class="c">*</span><span class="c">         </span><span class="c">&lt;</span><span class="c">code</span><span class="c">&gt;</span><span class="c">b.Length</span><span class="c">&lt;/</span><span class="c">code</span><span class="c">&gt;</span><span class="c"> if no paragraph end could be located.</span>
         <span class="c">*/</span>
		<b>public static int</b> <a id="8228ff8c8c83c95f" href="../R/8228ff8c8c83c95f.html" target="n" data-glyph="72,1" class="i method">endOfParagraph</a>(<b>byte</b>[] <span id="r137 rd" class="r137 r">b</span>, <b>int</b> <span id="r138 rd" class="r138 r">start</span>)
		{
			<b>int</b> <span id="r139 rd" class="r139 r">ptr</span> = <span class="r138 r">start</span>;
			<b>int</b> <span id="r140 rd" class="r140 r">sz</span> = <span class="r137 r">b</span>.<a href="@0@mscorlib/A.html#42e9b7616956cf94" class="i property">Length</a>;

			<b>while</b> (<span class="r139 r">ptr</span> &lt; <span class="r140 r">sz</span> &amp;&amp; <span class="r137 r">b</span>[<span class="r139 r">ptr</span>] != (<b>byte</b>)<span class="s">&#39;\n&#39;</span>)
			{
				<span class="r139 r">ptr</span> = <a href="#0989702123852d37" class="i method">nextLF</a>(<span class="r137 r">b</span>, <span class="r139 r">ptr</span>);
			}

			<b>while</b> (0 &lt; <span class="r139 r">ptr</span> &amp;&amp; <span class="r138 r">start</span> &lt; <span class="r139 r">ptr</span> &amp;&amp; <span class="r137 r">b</span>[<span class="r139 r">ptr</span> - 1] == (<b>byte</b>)<span class="s">&#39;\n&#39;</span>)
			{
				<span class="r139 r">ptr</span>--;
			}

			<b>return</b> <span class="r139 r">ptr</span>;
		}

	}
}</pre></td></tr></table></div></body></html>
