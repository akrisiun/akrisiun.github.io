<!DOCTYPE html>
<html><head><title>jquery-ui-1.8.18.js</title><link rel="stylesheet" href="../../styles.css"><script src="../../scripts.js"></script></head>
<body class="cB" onload="ix(11802);"><div class="dH">
<table style="width: 100%">
<tr><td>File: <a id="filePath" class="blueLink" href="/#GitAspx/d:/Sanitex/webstack/git-dot-aspx/GitAspx/Scripts/jquery-ui-1.8.18.js" target="_top">d:\Sanitex\webstack\git-dot-aspx\GitAspx\Scripts\jquery-ui-1.8.18.js</a><br/></td></tr>
</table>
</div>
<div class="cz"><table class="tb" cellpadding="0" cellspacing="0"><tr><td valign="top" align="right"><pre id="ln"></pre></td><td valign="top" align="left"><pre id="code">
/*!
 * jQuery UI 1.8.18
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI
 */
(function( $, undefined ) {

// prevent duplicate loading
// this is only a problem because we proxy existing functions
// and we don&#39;t want to double proxy them
$.ui = $.ui || {};
if ( $.ui.version ) {
	return;
}

$.extend( $.ui, {
	version: &quot;1.8.18&quot;,

	keyCode: {
		ALT: 18,
		BACKSPACE: 8,
		CAPS_LOCK: 20,
		COMMA: 188,
		COMMAND: 91,
		COMMAND_LEFT: 91, // COMMAND
		COMMAND_RIGHT: 93,
		CONTROL: 17,
		DELETE: 46,
		DOWN: 40,
		END: 35,
		ENTER: 13,
		ESCAPE: 27,
		HOME: 36,
		INSERT: 45,
		LEFT: 37,
		MENU: 93, // COMMAND_RIGHT
		NUMPAD_ADD: 107,
		NUMPAD_DECIMAL: 110,
		NUMPAD_DIVIDE: 111,
		NUMPAD_ENTER: 108,
		NUMPAD_MULTIPLY: 106,
		NUMPAD_SUBTRACT: 109,
		PAGE_DOWN: 34,
		PAGE_UP: 33,
		PERIOD: 190,
		RIGHT: 39,
		SHIFT: 16,
		SPACE: 32,
		TAB: 9,
		UP: 38,
		WINDOWS: 91 // COMMAND
	}
});

// plugins
$.fn.extend({
	propAttr: $.fn.prop || $.fn.attr,

	_focus: $.fn.focus,
	focus: function( delay, fn ) {
		return typeof delay === &quot;number&quot; ?
			this.each(function() {
				var elem = this;
				setTimeout(function() {
					$( elem ).focus();
					if ( fn ) {
						fn.call( elem );
					}
				}, delay );
			}) :
			this._focus.apply( this, arguments );
	},

	scrollParent: function() {
		var scrollParent;
		if (($.browser.msie <span class="xer">&amp;</span><span class="xer">&amp;</span> (/(static|relative)/).test(this.css(&#39;position&#39;))) || (/absolute/).test(this.css(&#39;position&#39;))) {
			scrollParent = this.parents().filter(function() {
				return (/(relative|absolute|fixed)/).test($.curCSS(this,&#39;position&#39;,1)) <span class="xer">&amp;</span><span class="xer">&amp;</span> (/(auto|scroll)/).test($.curCSS(this,&#39;overflow&#39;,1)+$.curCSS(this,&#39;overflow-y&#39;,1)+$.curCSS(this,&#39;overflow-x&#39;,1));
			}).eq(0);
		} else {
			scrollParent = this.parents().filter(function() {
				return (/(auto|scroll)/).test($.curCSS(this,&#39;overflow&#39;,1)+$.curCSS(this,&#39;overflow-y&#39;,1)+$.curCSS(this,&#39;overflow-x&#39;,1));
			}).eq(0);
		}

		return (/fixed/).test(this.css(&#39;position&#39;)) || !scrollParent.length ? $(document) : scrollParent;
	},

	zIndex: function( zIndex ) {
		if ( zIndex !== undefined ) {
			return this.css( &quot;zIndex&quot;, zIndex );
		}

		if ( this.length ) {
			var elem = $( this[ 0 ] ), position, value;
			while ( elem.length <span class="xer">&amp;</span><span class="xer">&amp;</span> elem[ 0 ] !== document ) {
				// Ignore z-index if position is set to a value where z-index is ignored by the browser
				// This makes behavior of this function consistent across browsers
				// WebKit always returns auto if the element is positioned
				position = elem.css( &quot;position&quot; );
				if ( position === &quot;absolute&quot; || position === &quot;relative&quot; || position === &quot;fixed&quot; ) {
					// IE returns 0 when zIndex is not specified
					// other browsers return a string
					// we ignore the case of nested elements with an explicit value of 0
					// <span class="xd">&lt;</span><span class="xn">div </span><span class="xan">style</span><span class="xd">=</span>&quot;<span class="xav">z-index: -10;</span>&quot;<span class="xd">&gt;</span><span class="xd">&lt;</span><span class="xn">div </span><span class="xan">style</span><span class="xd">=</span>&quot;<span class="xav">z-index: 0;</span>&quot;<span class="xd">&gt;</span><span class="xd">&lt;/</span><span class="xn">div</span><span class="xd">&gt;</span><span class="xd">&lt;/</span><span class="xn">div</span><span class="xd">&gt;</span>
					value = parseInt( elem.css( &quot;zIndex&quot; ), 10 );
					if ( !isNaN( value ) <span class="xer">&amp;</span><span class="xer">&amp;</span> value !== 0 ) {
						return value;
					}
				}
				elem = elem.parent();
			}
		}

		return 0;
	},

	disableSelection: function() {
		return this.bind( ( $.support.selectstart ? &quot;selectstart&quot; : &quot;mousedown&quot; ) +
			&quot;.ui-disableSelection&quot;, function( event ) {
				event.preventDefault();
			});
	},

	enableSelection: function() {
		return this.unbind( &quot;.ui-disableSelection&quot; );
	}
});

$.each( [ &quot;Width&quot;, &quot;Height&quot; ], function( i, name ) {
	var side = name === &quot;Width&quot; ? [ &quot;Left&quot;, &quot;Right&quot; ] : [ &quot;Top&quot;, &quot;Bottom&quot; ],
		type = name.toLowerCase(),
		orig = {
			innerWidth: $.fn.innerWidth,
			innerHeight: $.fn.innerHeight,
			outerWidth: $.fn.outerWidth,
			outerHeight: $.fn.outerHeight
		};

	function reduce( elem, size, border, margin ) {
		$.each( side, function() {
			size -= parseFloat( $.curCSS( elem, &quot;padding&quot; + this, true) ) || 0;
			if ( border ) {
				size -= parseFloat( $.curCSS( elem, &quot;border&quot; + this + &quot;Width&quot;, true) ) || 0;
			}
			if ( margin ) {
				size -= parseFloat( $.curCSS( elem, &quot;margin&quot; + this, true) ) || 0;
			}
		});
		return size;
	}

	$.fn[ &quot;inner&quot; + name ] = function( size ) {
		if ( size === undefined ) {
			return orig[ &quot;inner&quot; + name ].call( this );
		}

		return this.each(function() {
			$( this ).css( type, reduce( this, size ) + &quot;px&quot; );
		});
	};

	$.fn[ &quot;outer&quot; + name] = function( size, margin ) {
		if ( typeof size !== &quot;number&quot; ) {
			return orig[ &quot;outer&quot; + name ].call( this, size );
		}

		return this.each(function() {
			$( this).css( type, reduce( this, size, true, margin ) + &quot;px&quot; );
		});
	};
});

// selectors
function focusable( element, isTabIndexNotNaN ) {
	var nodeName = element.nodeName.toLowerCase();
	if ( &quot;area&quot; === nodeName ) {
		var map = element.parentNode,
			mapName = map.name,
			img;
		if ( !element.href || !mapName || map.nodeName.toLowerCase() !== &quot;map&quot; ) {
			return false;
		}
		img = $( &quot;img[usemap=#&quot; + mapName + &quot;]&quot; )[0];
		return !!img <span class="xer">&amp;</span><span class="xer">&amp;</span> visible( img );
	}
	return ( /input|select|textarea|button|object/.test( nodeName )
		? !element.disabled
		: &quot;a&quot; == nodeName
			? element.href || isTabIndexNotNaN
			: isTabIndexNotNaN)
		// the element and all of its ancestors must be visible
		<span class="xer">&amp;</span><span class="xer">&amp;</span> visible( element );
}

function visible( element ) {
	return !$( element ).parents().andSelf().filter(function() {
		return $.curCSS( this, &quot;visibility&quot; ) === &quot;hidden&quot; ||
			$.expr.filters.hidden( this );
	}).length;
}

$.extend( $.expr[ &quot;:&quot; ], {
	data: function( elem, i, match ) {
		return !!$.data( elem, match[ 3 ] );
	},

	focusable: function( element ) {
		return focusable( element, !isNaN( $.attr( element, &quot;tabindex&quot; ) ) );
	},

	tabbable: function( element ) {
		var tabIndex = $.attr( element, &quot;tabindex&quot; ),
			isTabIndexNaN = isNaN( tabIndex );
		return ( isTabIndexNaN || tabIndex &gt;= 0 ) <span class="xer">&amp;</span><span class="xer">&amp;</span> focusable( element, !isTabIndexNaN );
	}
});

// support
$(function() {
	var body = document.body,
		div = body.appendChild( div = document.createElement( &quot;div&quot; ) );

	// access offsetHeight before setting the style to prevent a layout bug
	// in IE 9 which causes the elemnt to continue to take up space even
	// after it is removed from the DOM (#8026)
	div.offsetHeight;

	$.extend( div.style, {
		minHeight: &quot;100px&quot;,
		height: &quot;auto&quot;,
		padding: 0,
		borderWidth: 0
	});

	$.support.minHeight = div.offsetHeight === 100;
	$.support.selectstart = &quot;onselectstart&quot; in div;

	// set display to none to avoid a layout bug in IE
	// http://dev.jquery.com/ticket/4014
	body.removeChild( div ).style.display = &quot;none&quot;;
});





// deprecated
$.extend( $.ui, {
	// $.ui.plugin is deprecated.  Use the proxy pattern instead.
	plugin: {
		add: function( module, option, set ) {
			var proto = $.ui[ module ].prototype;
			for ( var i in set ) {
				proto.plugins[ i ] = proto.plugins[ i ] || [];
				proto.plugins[ i ].push( [ option, set[ i ] ] );
			}
		},
		call: function( instance, name, args ) {
			var set = instance.plugins[ name ];
			if ( !set || !instance.element[ 0 ].parentNode ) {
				return;
			}
	
			for ( var i = 0; i <span class="xd">&lt; </span><span class="xn">set.length</span><span class="xd">; i++ ) {
				if ( instance.options[ set[ i ][ 0 ] ] ) {
					set[ i ][ 1 ].apply( instance.element, args );
				}
			}
		}
	},
	
	// will be deprecated when we switch to jQuery 1.4 - use jQuery.contains()
	contains: function( a, b ) {
		return document.compareDocumentPosition ?
			a.compareDocumentPosition( b ) &amp; 16 :
			a !== b &amp;&amp; a.contains( b );
	},
	
	// only used by resizable
	hasScroll: function( el, a ) {
	
		//If overflow is hidden, the element might have extra content, but the user wants to hide it
		if ( $( el ).css( &quot;overflow&quot; ) === &quot;hidden&quot;) {
			return false;
		}
	
		var scroll = ( a &amp;&amp; a === &quot;left&quot; ) ? &quot;scrollLeft&quot; : &quot;scrollTop&quot;,
			has = false;
	
		if ( el[ scroll ] &gt;</span> 0 ) {
			return true;
		}
	
		// TODO: determine which cases actually cause this to happen
		// if the element doesn&#39;t have the scroll set, see if it&#39;s possible to
		// set the scroll
		el[ scroll ] = 1;
		has = ( el[ scroll ] &gt; 0 );
		el[ scroll ] = 0;
		return has;
	},
	
	// these are odd functions, fix the API or move into individual plugins
	isOverAxis: function( x, reference, size ) {
		//Determines when x coordinate is over &quot;b&quot; element axis
		return ( x &gt; reference ) <span class="xer">&amp;</span><span class="xer">&amp;</span> ( x <span class="xd">&lt; </span><span class="xd">( reference + size ) );
	},
	isOver: function( y, x, top, left, height, width ) {
		//Determines when x, y coordinates is over &quot;b&quot; element
		return $.ui.isOverAxis( y, top, height ) &amp;&amp; $.ui.isOverAxis( x, left, width );
	}
});

})( jQuery );
/*!
 * jQuery UI Widget 1.8.18
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Widget
 */
(function( $, undefined ) {

// jQuery 1.4+
if ( $.cleanData ) {
	var _cleanData = $.cleanData;
	$.cleanData = function( elems ) {
		for ( var i = 0, elem; (elem = elems[i]) != null; i++ ) {
			try {
				$( elem ).triggerHandler( &quot;remove&quot; );
			// http://bugs.jquery.com/ticket/8235
			} catch( e ) {}
		}
		_cleanData( elems );
	};
} else {
	var _remove = $.fn.remove;
	$.fn.remove = function( selector, keepData ) {
		return this.each(function() {
			if ( !keepData ) {
				if ( !selector || $.filter( selector, [ this ] ).length ) {
					$( &quot;*&quot;, this ).add( [ this ] ).each(function() {
						try {
							$( this ).triggerHandler( &quot;remove&quot; );
						// http://bugs.jquery.com/ticket/8235
						} catch( e ) {}
					});
				}
			}
			return _remove.call( $(this), selector, keepData );
		});
	};
}

$.widget = function( name, base, prototype ) {
	var namespace = name.split( &quot;.&quot; )[ 0 ],
		fullName;
	name = name.split( &quot;.&quot; )[ 1 ];
	fullName = namespace + &quot;-&quot; + name;

	if ( !prototype ) {
		prototype = base;
		base = $.Widget;
	}

	// create selector for plugin
	$.expr[ &quot;:&quot; ][ fullName ] = function( elem ) {
		return !!$.data( elem, name );
	};

	$[ namespace ] = $[ namespace ] || {};
	$[ namespace ][ name ] = function( options, element ) {
		// allow instantiation without initializing for simple inheritance
		if ( arguments.length ) {
			this._createWidget( options, element );
		}
	};

	var basePrototype = new base();
	// we need to make the options hash a property directly on the new instance
	// otherwise we&#39;ll modify the options hash on the prototype that we&#39;re
	// inheriting from
//	$.each( basePrototype, function( key, val ) {
//		if ( $.isPlainObject(val) ) {
//			basePrototype[ key ] = $.extend( {}, val );
//		}
//	});
	basePrototype.options = $.extend( true, {}, basePrototype.options );
	$[ namespace ][ name ].prototype = $.extend( true, basePrototype, {
		namespace: namespace,
		widgetName: name,
		widgetEventPrefix: $[ namespace ][ name ].prototype.widgetEventPrefix || name,
		widgetBaseClass: fullName
	}, prototype );

	$.widget.bridge( name, $[ namespace ][ name ] );
};

$.widget.bridge = function( name, object ) {
	$.fn[ name ] = function( options ) {
		var isMethodCall = typeof options === &quot;string&quot;,
			args = Array.prototype.slice.call( arguments, 1 ),
			returnValue = this;

		// allow multiple hashes to be passed on init
		options = !isMethodCall &amp;&amp; args.length ?
			$.extend.apply( null, [ true, options ].concat(args) ) :
			options;

		// prevent calls to internal methods
		if ( isMethodCall &amp;&amp; options.charAt( 0 ) === &quot;_&quot; ) {
			return returnValue;
		}

		if ( isMethodCall ) {
			this.each(function() {
				var instance = $.data( this, name ),
					methodValue = instance &amp;&amp; $.isFunction( instance[options] ) ?
						instance[ options ].apply( instance, args ) :
						instance;
				// TODO: add this back in 1.9 and use $.error() (see #5972)
//				if ( !instance ) {
//					throw &quot;cannot call methods on &quot; + name + &quot; prior to initialization; &quot; +
//						&quot;attempted to call method &#39;&quot; + options + &quot;&#39;&quot;;
//				}
//				if ( !$.isFunction( instance[options] ) ) {
//					throw &quot;no such method &#39;&quot; + options + &quot;&#39; for &quot; + name + &quot; widget instance&quot;;
//				}
//				var methodValue = instance[ options ].apply( instance, args );
				if ( methodValue !== instance &amp;&amp; methodValue !== undefined ) {
					returnValue = methodValue;
					return false;
				}
			});
		} else {
			this.each(function() {
				var instance = $.data( this, name );
				if ( instance ) {
					instance.option( options || {} )._init();
				} else {
					$.data( this, name, new object( options, this ) );
				}
			});
		}

		return returnValue;
	};
};

$.Widget = function( options, element ) {
	// allow instantiation without initializing for simple inheritance
	if ( arguments.length ) {
		this._createWidget( options, element );
	}
};

$.Widget.prototype = {
	widgetName: &quot;widget&quot;,
	widgetEventPrefix: &quot;&quot;,
	options: {
		disabled: false
	},
	_createWidget: function( options, element ) {
		// $.widget.bridge stores the plugin instance, but we do it anyway
		// so that it&#39;s stored even before the _create function runs
		$.data( element, this.widgetName, this );
		this.element = $( element );
		this.options = $.extend( true, {},
			this.options,
			this._getCreateOptions(),
			options );

		var self = this;
		this.element.bind( &quot;remove.&quot; + this.widgetName, function() {
			self.destroy();
		});

		this._create();
		this._trigger( &quot;create&quot; );
		this._init();
	},
	_getCreateOptions: function() {
		return $.metadata &amp;&amp; $.metadata.get( this.element[0] )[ this.widgetName ];
	},
	_create: function() {},
	_init: function() {},

	destroy: function() {
		this.element
			.unbind( &quot;.&quot; + this.widgetName )
			.removeData( this.widgetName );
		this.widget()
			.unbind( &quot;.&quot; + this.widgetName )
			.removeAttr( &quot;aria-disabled&quot; )
			.removeClass(
				this.widgetBaseClass + &quot;-disabled &quot; +
				&quot;ui-state-disabled&quot; );
	},

	widget: function() {
		return this.element;
	},

	option: function( key, value ) {
		var options = key;

		if ( arguments.length === 0 ) {
			// don&#39;t return a reference to the internal hash
			return $.extend( {}, this.options );
		}

		if  (typeof key === &quot;string&quot; ) {
			if ( value === undefined ) {
				return this.options[ key ];
			}
			options = {};
			options[ key ] = value;
		}

		this._setOptions( options );

		return this;
	},
	_setOptions: function( options ) {
		var self = this;
		$.each( options, function( key, value ) {
			self._setOption( key, value );
		});

		return this;
	},
	_setOption: function( key, value ) {
		this.options[ key ] = value;

		if ( key === &quot;disabled&quot; ) {
			this.widget()
				[ value ? &quot;addClass&quot; : &quot;removeClass&quot;](
					this.widgetBaseClass + &quot;-disabled&quot; + &quot; &quot; +
					&quot;ui-state-disabled&quot; )
				.attr( &quot;aria-disabled&quot;, value );
		}

		return this;
	},

	enable: function() {
		return this._setOption( &quot;disabled&quot;, false );
	},
	disable: function() {
		return this._setOption( &quot;disabled&quot;, true );
	},

	_trigger: function( type, event, data ) {
		var prop, orig,
			callback = this.options[ type ];

		data = data || {};
		event = $.Event( event );
		event.type = ( type === this.widgetEventPrefix ?
			type :
			this.widgetEventPrefix + type ).toLowerCase();
		// the original event may come from any element
		// so we need to reset the target on the new event
		event.target = this.element[ 0 ];

		// copy original event properties over to the new event
		orig = event.originalEvent;
		if ( orig ) {
			for ( prop in orig ) {
				if ( !( prop in event ) ) {
					event[ prop ] = orig[ prop ];
				}
			}
		}

		this.element.trigger( event, data );

		return !( $.isFunction(callback) &amp;&amp;
			callback.call( this.element[0], event, data ) === false ||
			event.isDefaultPrevented() );
	}
};

})( jQuery );
/*!
 * jQuery UI Mouse 1.8.18
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Mouse
 *
 * Depends:
 *	jquery.ui.widget.js
 */
(function( $, undefined ) {

var mouseHandled = false;
$( document ).mouseup( function( e ) {
	mouseHandled = false;
});

$.widget(&quot;ui.mouse&quot;, {
	options: {
		cancel: &#39;:input,option&#39;,
		distance: 1,
		delay: 0
	},
	_mouseInit: function() {
		var self = this;

		this.element
			.bind(&#39;mousedown.&#39;+this.widgetName, function(event) {
				return self._mouseDown(event);
			})
			.bind(&#39;click.&#39;+this.widgetName, function(event) {
				if (true === $.data(event.target, self.widgetName + &#39;.preventClickEvent&#39;)) {
				    $.removeData(event.target, self.widgetName + &#39;.preventClickEvent&#39;);
					event.stopImmediatePropagation();
					return false;
				}
			});

		this.started = false;
	},

	// TODO: make sure destroying one instance of mouse doesn&#39;t mess with
	// other instances of mouse
	_mouseDestroy: function() {
		this.element.unbind(&#39;.&#39;+this.widgetName);
	},

	_mouseDown: function(event) {
		// don&#39;t let more than one widget handle mouseStart
		if( mouseHandled ) { return };

		// we may have missed mouseup (out of window)
		(this._mouseStarted &amp;&amp; this._mouseUp(event));

		this._mouseDownEvent = event;

		var self = this,
			btnIsLeft = (event.which == 1),
			// event.target.nodeName works around a bug in IE 8 with
			// disabled inputs (#7620)
			elIsCancel = (typeof this.options.cancel == &quot;string&quot; &amp;&amp; event.target.nodeName ? $(event.target).closest(this.options.cancel).length : false);
		if (!btnIsLeft || elIsCancel || !this._mouseCapture(event)) {
			return true;
		}

		this.mouseDelayMet = !this.options.delay;
		if (!this.mouseDelayMet) {
			this._mouseDelayTimer = setTimeout(function() {
				self.mouseDelayMet = true;
			}, this.options.delay);
		}

		if (this._mouseDistanceMet(event) &amp;&amp; this._mouseDelayMet(event)) {
			this._mouseStarted = (this._mouseStart(event) !== false);
			if (!this._mouseStarted) {
				event.preventDefault();
				return true;
			}
		}

		// Click event may never have fired (Gecko &amp; Opera)
		if (true === $.data(event.target, this.widgetName + &#39;.preventClickEvent&#39;)) {
			$.removeData(event.target, this.widgetName + &#39;.preventClickEvent&#39;);
		}

		// these delegates are required to keep context
		this._mouseMoveDelegate = function(event) {
			return self._mouseMove(event);
		};
		this._mouseUpDelegate = function(event) {
			return self._mouseUp(event);
		};
		$(document)
			.bind(&#39;mousemove.&#39;+this.widgetName, this._mouseMoveDelegate)
			.bind(&#39;mouseup.&#39;+this.widgetName, this._mouseUpDelegate);

		event.preventDefault();
		
		mouseHandled = true;
		return true;
	},

	_mouseMove: function(event) {
		// IE mouseup check - mouseup happened when mouse was out of window
		if ($.browser.msie &amp;&amp; !(document.documentMode &gt;</span>= 9) <span class="xer">&amp;</span><span class="xer">&amp;</span> !event.button) {
			return this._mouseUp(event);
		}

		if (this._mouseStarted) {
			this._mouseDrag(event);
			return event.preventDefault();
		}

		if (this._mouseDistanceMet(event) <span class="xer">&amp;</span><span class="xer">&amp;</span> this._mouseDelayMet(event)) {
			this._mouseStarted =
				(this._mouseStart(this._mouseDownEvent, event) !== false);
			(this._mouseStarted ? this._mouseDrag(event) : this._mouseUp(event));
		}

		return !this._mouseStarted;
	},

	_mouseUp: function(event) {
		$(document)
			.unbind(&#39;mousemove.&#39;+this.widgetName, this._mouseMoveDelegate)
			.unbind(&#39;mouseup.&#39;+this.widgetName, this._mouseUpDelegate);

		if (this._mouseStarted) {
			this._mouseStarted = false;

			if (event.target == this._mouseDownEvent.target) {
			    $.data(event.target, this.widgetName + &#39;.preventClickEvent&#39;, true);
			}

			this._mouseStop(event);
		}

		return false;
	},

	_mouseDistanceMet: function(event) {
		return (Math.max(
				Math.abs(this._mouseDownEvent.pageX - event.pageX),
				Math.abs(this._mouseDownEvent.pageY - event.pageY)
			) &gt;= this.options.distance
		);
	},

	_mouseDelayMet: function(event) {
		return this.mouseDelayMet;
	},

	// These are placeholder methods, to be overriden by extending plugin
	_mouseStart: function(event) {},
	_mouseDrag: function(event) {},
	_mouseStop: function(event) {},
	_mouseCapture: function(event) { return true; }
});

})(jQuery);
/*
 * jQuery UI Position 1.8.18
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Position
 */
(function( $, undefined ) {

$.ui = $.ui || {};

var horizontalPositions = /left|center|right/,
	verticalPositions = /top|center|bottom/,
	center = &quot;center&quot;,
	support = {},
	_position = $.fn.position,
	_offset = $.fn.offset;

$.fn.position = function( options ) {
	if ( !options || !options.of ) {
		return _position.apply( this, arguments );
	}

	// make a copy, we don&#39;t want to modify arguments
	options = $.extend( {}, options );

	var target = $( options.of ),
		targetElem = target[0],
		collision = ( options.collision || &quot;flip&quot; ).split( &quot; &quot; ),
		offset = options.offset ? options.offset.split( &quot; &quot; ) : [ 0, 0 ],
		targetWidth,
		targetHeight,
		basePosition;

	if ( targetElem.nodeType === 9 ) {
		targetWidth = target.width();
		targetHeight = target.height();
		basePosition = { top: 0, left: 0 };
	// TODO: use $.isWindow() in 1.9
	} else if ( targetElem.setTimeout ) {
		targetWidth = target.width();
		targetHeight = target.height();
		basePosition = { top: target.scrollTop(), left: target.scrollLeft() };
	} else if ( targetElem.preventDefault ) {
		// force left top to allow flipping
		options.at = &quot;left top&quot;;
		targetWidth = targetHeight = 0;
		basePosition = { top: options.of.pageY, left: options.of.pageX };
	} else {
		targetWidth = target.outerWidth();
		targetHeight = target.outerHeight();
		basePosition = target.offset();
	}

	// force my and at to have valid horizontal and veritcal positions
	// if a value is missing or invalid, it will be converted to center 
	$.each( [ &quot;my&quot;, &quot;at&quot; ], function() {
		var pos = ( options[this] || &quot;&quot; ).split( &quot; &quot; );
		if ( pos.length === 1) {
			pos = horizontalPositions.test( pos[0] ) ?
				pos.concat( [center] ) :
				verticalPositions.test( pos[0] ) ?
					[ center ].concat( pos ) :
					[ center, center ];
		}
		pos[ 0 ] = horizontalPositions.test( pos[0] ) ? pos[ 0 ] : center;
		pos[ 1 ] = verticalPositions.test( pos[1] ) ? pos[ 1 ] : center;
		options[ this ] = pos;
	});

	// normalize collision option
	if ( collision.length === 1 ) {
		collision[ 1 ] = collision[ 0 ];
	}

	// normalize offset option
	offset[ 0 ] = parseInt( offset[0], 10 ) || 0;
	if ( offset.length === 1 ) {
		offset[ 1 ] = offset[ 0 ];
	}
	offset[ 1 ] = parseInt( offset[1], 10 ) || 0;

	if ( options.at[0] === &quot;right&quot; ) {
		basePosition.left += targetWidth;
	} else if ( options.at[0] === center ) {
		basePosition.left += targetWidth / 2;
	}

	if ( options.at[1] === &quot;bottom&quot; ) {
		basePosition.top += targetHeight;
	} else if ( options.at[1] === center ) {
		basePosition.top += targetHeight / 2;
	}

	basePosition.left += offset[ 0 ];
	basePosition.top += offset[ 1 ];

	return this.each(function() {
		var elem = $( this ),
			elemWidth = elem.outerWidth(),
			elemHeight = elem.outerHeight(),
			marginLeft = parseInt( $.curCSS( this, &quot;marginLeft&quot;, true ) ) || 0,
			marginTop = parseInt( $.curCSS( this, &quot;marginTop&quot;, true ) ) || 0,
			collisionWidth = elemWidth + marginLeft +
				( parseInt( $.curCSS( this, &quot;marginRight&quot;, true ) ) || 0 ),
			collisionHeight = elemHeight + marginTop +
				( parseInt( $.curCSS( this, &quot;marginBottom&quot;, true ) ) || 0 ),
			position = $.extend( {}, basePosition ),
			collisionPosition;

		if ( options.my[0] === &quot;right&quot; ) {
			position.left -= elemWidth;
		} else if ( options.my[0] === center ) {
			position.left -= elemWidth / 2;
		}

		if ( options.my[1] === &quot;bottom&quot; ) {
			position.top -= elemHeight;
		} else if ( options.my[1] === center ) {
			position.top -= elemHeight / 2;
		}

		// prevent fractions if jQuery version doesn&#39;t support them (see #5280)
		if ( !support.fractions ) {
			position.left = Math.round( position.left );
			position.top = Math.round( position.top );
		}

		collisionPosition = {
			left: position.left - marginLeft,
			top: position.top - marginTop
		};

		$.each( [ &quot;left&quot;, &quot;top&quot; ], function( i, dir ) {
			if ( $.ui.position[ collision[i] ] ) {
				$.ui.position[ collision[i] ][ dir ]( position, {
					targetWidth: targetWidth,
					targetHeight: targetHeight,
					elemWidth: elemWidth,
					elemHeight: elemHeight,
					collisionPosition: collisionPosition,
					collisionWidth: collisionWidth,
					collisionHeight: collisionHeight,
					offset: offset,
					my: options.my,
					at: options.at
				});
			}
		});

		if ( $.fn.bgiframe ) {
			elem.bgiframe();
		}
		elem.offset( $.extend( position, { using: options.using } ) );
	});
};

$.ui.position = {
	fit: {
		left: function( position, data ) {
			var win = $( window ),
				over = data.collisionPosition.left + data.collisionWidth - win.width() - win.scrollLeft();
			position.left = over &gt; 0 ? position.left - over : Math.max( position.left - data.collisionPosition.left, position.left );
		},
		top: function( position, data ) {
			var win = $( window ),
				over = data.collisionPosition.top + data.collisionHeight - win.height() - win.scrollTop();
			position.top = over &gt; 0 ? position.top - over : Math.max( position.top - data.collisionPosition.top, position.top );
		}
	},

	flip: {
		left: function( position, data ) {
			if ( data.at[0] === center ) {
				return;
			}
			var win = $( window ),
				over = data.collisionPosition.left + data.collisionWidth - win.width() - win.scrollLeft(),
				myOffset = data.my[ 0 ] === &quot;left&quot; ?
					-data.elemWidth :
					data.my[ 0 ] === &quot;right&quot; ?
						data.elemWidth :
						0,
				atOffset = data.at[ 0 ] === &quot;left&quot; ?
					data.targetWidth :
					-data.targetWidth,
				offset = -2 * data.offset[ 0 ];
			position.left += data.collisionPosition.left <span class="xd">&lt; </span><span class="xn">0 </span><span class="xd">?
				myOffset + atOffset + offset :
				over &gt;</span> 0 ?
					myOffset + atOffset + offset :
					0;
		},
		top: function( position, data ) {
			if ( data.at[1] === center ) {
				return;
			}
			var win = $( window ),
				over = data.collisionPosition.top + data.collisionHeight - win.height() - win.scrollTop(),
				myOffset = data.my[ 1 ] === &quot;top&quot; ?
					-data.elemHeight :
					data.my[ 1 ] === &quot;bottom&quot; ?
						data.elemHeight :
						0,
				atOffset = data.at[ 1 ] === &quot;top&quot; ?
					data.targetHeight :
					-data.targetHeight,
				offset = -2 * data.offset[ 1 ];
			position.top += data.collisionPosition.top <span class="xd">&lt; </span><span class="xn">0 </span><span class="xd">?
				myOffset + atOffset + offset :
				over &gt;</span> 0 ?
					myOffset + atOffset + offset :
					0;
		}
	}
};

// offset setter from jQuery 1.4
if ( !$.offset.setOffset ) {
	$.offset.setOffset = function( elem, options ) {
		// set position first, in-case top/left are set even on static elem
		if ( /static/.test( $.curCSS( elem, &quot;position&quot; ) ) ) {
			elem.style.position = &quot;relative&quot;;
		}
		var curElem   = $( elem ),
			curOffset = curElem.offset(),
			curTop    = parseInt( $.curCSS( elem, &quot;top&quot;,  true ), 10 ) || 0,
			curLeft   = parseInt( $.curCSS( elem, &quot;left&quot;, true ), 10)  || 0,
			props     = {
				top:  (options.top  - curOffset.top)  + curTop,
				left: (options.left - curOffset.left) + curLeft
			};
		
		if ( &#39;using&#39; in options ) {
			options.using.call( elem, props );
		} else {
			curElem.css( props );
		}
	};

	$.fn.offset = function( options ) {
		var elem = this[ 0 ];
		if ( !elem || !elem.ownerDocument ) { return null; }
		if ( options ) { 
			return this.each(function() {
				$.offset.setOffset( this, options );
			});
		}
		return _offset.call( this );
	};
}

// fraction support test (older versions of jQuery don&#39;t support fractions)
(function () {
	var body = document.getElementsByTagName( &quot;body&quot; )[ 0 ], 
		div = document.createElement( &quot;div&quot; ),
		testElement, testElementParent, testElementStyle, offset, offsetTotal;

	//Create a &quot;fake body&quot; for testing based on method used in jQuery.support
	testElement = document.createElement( body ? &quot;div&quot; : &quot;body&quot; );
	testElementStyle = {
		visibility: &quot;hidden&quot;,
		width: 0,
		height: 0,
		border: 0,
		margin: 0,
		background: &quot;none&quot;
	};
	if ( body ) {
		$.extend( testElementStyle, {
			position: &quot;absolute&quot;,
			left: &quot;-1000px&quot;,
			top: &quot;-1000px&quot;
		});
	}
	for ( var i in testElementStyle ) {
		testElement.style[ i ] = testElementStyle[ i ];
	}
	testElement.appendChild( div );
	testElementParent = body || document.documentElement;
	testElementParent.insertBefore( testElement, testElementParent.firstChild );

	div.style.cssText = &quot;position: absolute; left: 10.7432222px; top: 10.432325px; height: 30px; width: 201px;&quot;;

	offset = $( div ).offset( function( _, offset ) {
		return offset;
	}).offset();

	testElement.innerHTML = &quot;&quot;;
	testElementParent.removeChild( testElement );

	offsetTotal = offset.top + offset.left + ( body ? 2000 : 0 );
	support.fractions = offsetTotal &gt; 21 <span class="xer">&amp;</span><span class="xer">&amp;</span> offsetTotal <span class="xd">&lt; </span><span class="xn">22</span><span class="xd">;
})();

}( jQuery ));
/*
 * jQuery UI Draggable 1.8.18
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Draggables
 *
 * Depends:
 *	jquery.ui.core.js
 *	jquery.ui.mouse.js
 *	jquery.ui.widget.js
 */
(function( $, undefined ) {

$.widget(&quot;ui.draggable&quot;, $.ui.mouse, {
	widgetEventPrefix: &quot;drag&quot;,
	options: {
		addClasses: true,
		appendTo: &quot;parent&quot;,
		axis: false,
		connectToSortable: false,
		containment: false,
		cursor: &quot;auto&quot;,
		cursorAt: false,
		grid: false,
		handle: false,
		helper: &quot;original&quot;,
		iframeFix: false,
		opacity: false,
		refreshPositions: false,
		revert: false,
		revertDuration: 500,
		scope: &quot;default&quot;,
		scroll: true,
		scrollSensitivity: 20,
		scrollSpeed: 20,
		snap: false,
		snapMode: &quot;both&quot;,
		snapTolerance: 20,
		stack: false,
		zIndex: false
	},
	_create: function() {

		if (this.options.helper == &#39;original&#39; &amp;&amp; !(/^(?:r|a|f)/).test(this.element.css(&quot;position&quot;)))
			this.element[0].style.position = &#39;relative&#39;;

		(this.options.addClasses &amp;&amp; this.element.addClass(&quot;ui-draggable&quot;));
		(this.options.disabled &amp;&amp; this.element.addClass(&quot;ui-draggable-disabled&quot;));

		this._mouseInit();

	},

	destroy: function() {
		if(!this.element.data(&#39;draggable&#39;)) return;
		this.element
			.removeData(&quot;draggable&quot;)
			.unbind(&quot;.draggable&quot;)
			.removeClass(&quot;ui-draggable&quot;
				+ &quot; ui-draggable-dragging&quot;
				+ &quot; ui-draggable-disabled&quot;);
		this._mouseDestroy();

		return this;
	},

	_mouseCapture: function(event) {

		var o = this.options;

		// among others, prevent a drag on a resizable-handle
		if (this.helper || o.disabled || $(event.target).is(&#39;.ui-resizable-handle&#39;))
			return false;

		//Quit if we&#39;re not on a valid handle
		this.handle = this._getHandle(event);
		if (!this.handle)
			return false;
		
		if ( o.iframeFix ) {
			$(o.iframeFix === true ? &quot;iframe&quot; : o.iframeFix).each(function() {
				$(&#39;</span><span class="xd">&lt;</span><span class="xn">div </span><span class="xan">class</span><span class="xd">=</span>&quot;<span class="xav">ui-draggable-iframeFix</span>&quot; <span class="xan">style</span><span class="xd">=</span>&quot;<span class="xav">background: #fff;</span>&quot;<span class="xd">&gt;</span><span class="xd">&lt;/</span><span class="xn">div</span><span class="xd">&gt;</span>&#39;)
				.css({
					width: this.offsetWidth+&quot;px&quot;, height: this.offsetHeight+&quot;px&quot;,
					position: &quot;absolute&quot;, opacity: &quot;0.001&quot;, zIndex: 1000
				})
				.css($(this).offset())
				.appendTo(&quot;body&quot;);
			});
		}

		return true;

	},

	_mouseStart: function(event) {

		var o = this.options;

		//Create and append the visible helper
		this.helper = this._createHelper(event);

		//Cache the helper size
		this._cacheHelperProportions();

		//If ddmanager is used for droppables, set the global draggable
		if($.ui.ddmanager)
			$.ui.ddmanager.current = this;

		/*
		 * - Position generation -
		 * This block generates everything position related - it&#39;s the core of draggables.
		 */

		//Cache the margins of the original element
		this._cacheMargins();

		//Store the helper&#39;s css position
		this.cssPosition = this.helper.css(&quot;position&quot;);
		this.scrollParent = this.helper.scrollParent();

		//The element&#39;s absolute position on the page minus margins
		this.offset = this.positionAbs = this.element.offset();
		this.offset = {
			top: this.offset.top - this.margins.top,
			left: this.offset.left - this.margins.left
		};

		$.extend(this.offset, {
			click: { //Where the click happened, relative to the element
				left: event.pageX - this.offset.left,
				top: event.pageY - this.offset.top
			},
			parent: this._getParentOffset(),
			relative: this._getRelativeOffset() //This is a relative to absolute position minus the actual position calculation - only used for relative positioned helper
		});

		//Generate the original position
		this.originalPosition = this.position = this._generatePosition(event);
		this.originalPageX = event.pageX;
		this.originalPageY = event.pageY;

		//Adjust the mouse offset relative to the helper if &#39;cursorAt&#39; is supplied
		(o.cursorAt <span class="xer">&amp;</span><span class="xer">&amp;</span> this._adjustOffsetFromHelper(o.cursorAt));

		//Set a containment if given in the options
		if(o.containment)
			this._setContainment();

		//Trigger event + callbacks
		if(this._trigger(&quot;start&quot;, event) === false) {
			this._clear();
			return false;
		}

		//Recache the helper size
		this._cacheHelperProportions();

		//Prepare the droppable offsets
		if ($.ui.ddmanager <span class="xer">&amp;</span><span class="xer">&amp;</span> !o.dropBehaviour)
			$.ui.ddmanager.prepareOffsets(this, event);

		this.helper.addClass(&quot;ui-draggable-dragging&quot;);
		this._mouseDrag(event, true); //Execute the drag once - this causes the helper not to be visible before getting its correct position
		
		//If the ddmanager is used for droppables, inform the manager that dragging has started (see #5003)
		if ( $.ui.ddmanager ) $.ui.ddmanager.dragStart(this, event);
		
		return true;
	},

	_mouseDrag: function(event, noPropagation) {

		//Compute the helpers position
		this.position = this._generatePosition(event);
		this.positionAbs = this._convertPositionTo(&quot;absolute&quot;);

		//Call plugins and callbacks and use the resulting position if something is returned
		if (!noPropagation) {
			var ui = this._uiHash();
			if(this._trigger(&#39;drag&#39;, event, ui) === false) {
				this._mouseUp({});
				return false;
			}
			this.position = ui.position;
		}

		if(!this.options.axis || this.options.axis != &quot;y&quot;) this.helper[0].style.left = this.position.left+&#39;px&#39;;
		if(!this.options.axis || this.options.axis != &quot;x&quot;) this.helper[0].style.top = this.position.top+&#39;px&#39;;
		if($.ui.ddmanager) $.ui.ddmanager.drag(this, event);

		return false;
	},

	_mouseStop: function(event) {

		//If we are using droppables, inform the manager about the drop
		var dropped = false;
		if ($.ui.ddmanager <span class="xer">&amp;</span><span class="xer">&amp;</span> !this.options.dropBehaviour)
			dropped = $.ui.ddmanager.drop(this, event);

		//if a drop comes from outside (a sortable)
		if(this.dropped) {
			dropped = this.dropped;
			this.dropped = false;
		}
		
		//if the original element is removed, don&#39;t bother to continue if helper is set to &quot;original&quot;
		if((!this.element[0] || !this.element[0].parentNode) <span class="xer">&amp;</span><span class="xer">&amp;</span> this.options.helper == &quot;original&quot;)
			return false;

		if((this.options.revert == &quot;invalid&quot; <span class="xer">&amp;</span><span class="xer">&amp;</span> !dropped) || (this.options.revert == &quot;valid&quot; <span class="xer">&amp;</span><span class="xer">&amp;</span> dropped) || this.options.revert === true || ($.isFunction(this.options.revert) <span class="xer">&amp;</span><span class="xer">&amp;</span> this.options.revert.call(this.element, dropped))) {
			var self = this;
			$(this.helper).animate(this.originalPosition, parseInt(this.options.revertDuration, 10), function() {
				if(self._trigger(&quot;stop&quot;, event) !== false) {
					self._clear();
				}
			});
		} else {
			if(this._trigger(&quot;stop&quot;, event) !== false) {
				this._clear();
			}
		}

		return false;
	},
	
	_mouseUp: function(event) {
		if (this.options.iframeFix === true) {
			$(&quot;div.ui-draggable-iframeFix&quot;).each(function() { 
				this.parentNode.removeChild(this); 
			}); //Remove frame helpers
		}
		
		//If the ddmanager is used for droppables, inform the manager that dragging has stopped (see #5003)
		if( $.ui.ddmanager ) $.ui.ddmanager.dragStop(this, event);
		
		return $.ui.mouse.prototype._mouseUp.call(this, event);
	},
	
	cancel: function() {
		
		if(this.helper.is(&quot;.ui-draggable-dragging&quot;)) {
			this._mouseUp({});
		} else {
			this._clear();
		}
		
		return this;
		
	},

	_getHandle: function(event) {

		var handle = !this.options.handle || !$(this.options.handle, this.element).length ? true : false;
		$(this.options.handle, this.element)
			.find(&quot;*&quot;)
			.andSelf()
			.each(function() {
				if(this == event.target) handle = true;
			});

		return handle;

	},

	_createHelper: function(event) {

		var o = this.options;
		var helper = $.isFunction(o.helper) ? $(o.helper.apply(this.element[0], [event])) : (o.helper == &#39;clone&#39; ? this.element.clone().removeAttr(&#39;id&#39;) : this.element);

		if(!helper.parents(&#39;body&#39;).length)
			helper.appendTo((o.appendTo == &#39;parent&#39; ? this.element[0].parentNode : o.appendTo));

		if(helper[0] != this.element[0] <span class="xer">&amp;</span><span class="xer">&amp;</span> !(/(fixed|absolute)/).test(helper.css(&quot;position&quot;)))
			helper.css(&quot;position&quot;, &quot;absolute&quot;);

		return helper;

	},

	_adjustOffsetFromHelper: function(obj) {
		if (typeof obj == &#39;string&#39;) {
			obj = obj.split(&#39; &#39;);
		}
		if ($.isArray(obj)) {
			obj = {left: +obj[0], top: +obj[1] || 0};
		}
		if (&#39;left&#39; in obj) {
			this.offset.click.left = obj.left + this.margins.left;
		}
		if (&#39;right&#39; in obj) {
			this.offset.click.left = this.helperProportions.width - obj.right + this.margins.left;
		}
		if (&#39;top&#39; in obj) {
			this.offset.click.top = obj.top + this.margins.top;
		}
		if (&#39;bottom&#39; in obj) {
			this.offset.click.top = this.helperProportions.height - obj.bottom + this.margins.top;
		}
	},

	_getParentOffset: function() {

		//Get the offsetParent and cache its position
		this.offsetParent = this.helper.offsetParent();
		var po = this.offsetParent.offset();

		// This is a special case where we need to modify a offset calculated on start, since the following happened:
		// 1. The position of the helper is absolute, so it&#39;s position is calculated based on the next positioned parent
		// 2. The actual offset parent is a child of the scroll parent, and the scroll parent isn&#39;t the document, which means that
		//    the scroll is included in the initial calculation of the offset of the parent, and never recalculated upon drag
		if(this.cssPosition == &#39;absolute&#39; <span class="xer">&amp;</span><span class="xer">&amp;</span> this.scrollParent[0] != document <span class="xer">&amp;</span><span class="xer">&amp;</span> $.ui.contains(this.scrollParent[0], this.offsetParent[0])) {
			po.left += this.scrollParent.scrollLeft();
			po.top += this.scrollParent.scrollTop();
		}

		if((this.offsetParent[0] == document.body) //This needs to be actually done for all browsers, since pageX/pageY includes this information
		|| (this.offsetParent[0].tagName <span class="xer">&amp;</span><span class="xer">&amp;</span> this.offsetParent[0].tagName.toLowerCase() == &#39;html&#39; <span class="xer">&amp;</span><span class="xer">&amp;</span> $.browser.msie)) //Ugly IE fix
			po = { top: 0, left: 0 };

		return {
			top: po.top + (parseInt(this.offsetParent.css(&quot;borderTopWidth&quot;),10) || 0),
			left: po.left + (parseInt(this.offsetParent.css(&quot;borderLeftWidth&quot;),10) || 0)
		};

	},

	_getRelativeOffset: function() {

		if(this.cssPosition == &quot;relative&quot;) {
			var p = this.element.position();
			return {
				top: p.top - (parseInt(this.helper.css(&quot;top&quot;),10) || 0) + this.scrollParent.scrollTop(),
				left: p.left - (parseInt(this.helper.css(&quot;left&quot;),10) || 0) + this.scrollParent.scrollLeft()
			};
		} else {
			return { top: 0, left: 0 };
		}

	},

	_cacheMargins: function() {
		this.margins = {
			left: (parseInt(this.element.css(&quot;marginLeft&quot;),10) || 0),
			top: (parseInt(this.element.css(&quot;marginTop&quot;),10) || 0),
			right: (parseInt(this.element.css(&quot;marginRight&quot;),10) || 0),
			bottom: (parseInt(this.element.css(&quot;marginBottom&quot;),10) || 0)
		};
	},

	_cacheHelperProportions: function() {
		this.helperProportions = {
			width: this.helper.outerWidth(),
			height: this.helper.outerHeight()
		};
	},

	_setContainment: function() {

		var o = this.options;
		if(o.containment == &#39;parent&#39;) o.containment = this.helper[0].parentNode;
		if(o.containment == &#39;document&#39; || o.containment == &#39;window&#39;) this.containment = [
			o.containment == &#39;document&#39; ? 0 : $(window).scrollLeft() - this.offset.relative.left - this.offset.parent.left,
			o.containment == &#39;document&#39; ? 0 : $(window).scrollTop() - this.offset.relative.top - this.offset.parent.top,
			(o.containment == &#39;document&#39; ? 0 : $(window).scrollLeft()) + $(o.containment == &#39;document&#39; ? document : window).width() - this.helperProportions.width - this.margins.left,
			(o.containment == &#39;document&#39; ? 0 : $(window).scrollTop()) + ($(o.containment == &#39;document&#39; ? document : window).height() || document.body.parentNode.scrollHeight) - this.helperProportions.height - this.margins.top
		];

		if(!(/^(document|window|parent)$/).test(o.containment) <span class="xer">&amp;</span><span class="xer">&amp;</span> o.containment.constructor != Array) {
		        var c = $(o.containment);
			var ce = c[0]; if(!ce) return;
			var co = c.offset();
			var over = ($(ce).css(&quot;overflow&quot;) != &#39;hidden&#39;);

			this.containment = [
				(parseInt($(ce).css(&quot;borderLeftWidth&quot;),10) || 0) + (parseInt($(ce).css(&quot;paddingLeft&quot;),10) || 0),
				(parseInt($(ce).css(&quot;borderTopWidth&quot;),10) || 0) + (parseInt($(ce).css(&quot;paddingTop&quot;),10) || 0),
				(over ? Math.max(ce.scrollWidth,ce.offsetWidth) : ce.offsetWidth) - (parseInt($(ce).css(&quot;borderLeftWidth&quot;),10) || 0) - (parseInt($(ce).css(&quot;paddingRight&quot;),10) || 0) - this.helperProportions.width - this.margins.left - this.margins.right,
				(over ? Math.max(ce.scrollHeight,ce.offsetHeight) : ce.offsetHeight) - (parseInt($(ce).css(&quot;borderTopWidth&quot;),10) || 0) - (parseInt($(ce).css(&quot;paddingBottom&quot;),10) || 0) - this.helperProportions.height - this.margins.top  - this.margins.bottom
			];
			this.relative_container = c;

		} else if(o.containment.constructor == Array) {
			this.containment = o.containment;
		}

	},

	_convertPositionTo: function(d, pos) {

		if(!pos) pos = this.position;
		var mod = d == &quot;absolute&quot; ? 1 : -1;
		var o = this.options, scroll = this.cssPosition == &#39;absolute&#39; <span class="xer">&amp;</span><span class="xer">&amp;</span> !(this.scrollParent[0] != document <span class="xer">&amp;</span><span class="xer">&amp;</span> $.ui.contains(this.scrollParent[0], this.offsetParent[0])) ? this.offsetParent : this.scrollParent, scrollIsRootNode = (/(html|body)/i).test(scroll[0].tagName);

		return {
			top: (
				pos.top																	// The absolute mouse position
				+ this.offset.relative.top * mod										// Only for relative positioned nodes: Relative offset from element to offset parent
				+ this.offset.parent.top * mod											// The offsetParent&#39;s offset without borders (offset + border)
				- ($.browser.safari <span class="xer">&amp;</span><span class="xer">&amp;</span> $.browser.version <span class="xd">&lt; </span><span class="xn">526 </span><span class="xan">&amp;&amp; </span><span class="xan">this.cssPosition </span><span class="xd">=</span><span class="xav">=</span> &#39;<span class="xav">fixed</span>&#39; <span class="xd">? 0 : ( this.cssPosition == &#39;fixed&#39; ? -this.scrollParent.scrollTop() : ( scrollIsRootNode ? 0 : scroll.scrollTop() ) ) * mod)
			),
			left: (
				pos.left																// The absolute mouse position
				+ this.offset.relative.left * mod										// Only for relative positioned nodes: Relative offset from element to offset parent
				+ this.offset.parent.left * mod											// The offsetParent&#39;s offset without borders (offset + border)
				- ($.browser.safari &amp;&amp; $.browser.version </span><span class="xd">&lt; </span><span class="xn">526 </span><span class="xan">&amp;&amp; </span><span class="xan">this.cssPosition </span><span class="xd">=</span><span class="xav">=</span> &#39;<span class="xav">fixed</span>&#39; <span class="xd">? 0 : ( this.cssPosition == &#39;fixed&#39; ? -this.scrollParent.scrollLeft() : scrollIsRootNode ? 0 : scroll.scrollLeft() ) * mod)
			)
		};

	},

	_generatePosition: function(event) {

		var o = this.options, scroll = this.cssPosition == &#39;absolute&#39; &amp;&amp; !(this.scrollParent[0] != document &amp;&amp; $.ui.contains(this.scrollParent[0], this.offsetParent[0])) ? this.offsetParent : this.scrollParent, scrollIsRootNode = (/(html|body)/i).test(scroll[0].tagName);
		var pageX = event.pageX;
		var pageY = event.pageY;

		/*
		 * - Position constraining -
		 * Constrain the position to a mix of grid, containment.
		 */

		if(this.originalPosition) { //If we are not dragging yet, we won&#39;t check for options
		         var containment;
		         if(this.containment) {
				 if (this.relative_container){
				     var co = this.relative_container.offset();
				     containment = [ this.containment[0] + co.left,
						     this.containment[1] + co.top,
						     this.containment[2] + co.left,
						     this.containment[3] + co.top ];
				 }
				 else {
				     containment = this.containment;
				 }

				if(event.pageX - this.offset.click.left </span><span class="xd">&lt; </span><span class="xn">containment[0]</span><span class="xd">) pageX = containment[0] + this.offset.click.left;
				if(event.pageY - this.offset.click.top </span><span class="xd">&lt; </span><span class="xn">containment[1]</span><span class="xd">) pageY = containment[1] + this.offset.click.top;
				if(event.pageX - this.offset.click.left &gt;</span> containment[2]) pageX = containment[2] + this.offset.click.left;
				if(event.pageY - this.offset.click.top &gt; containment[3]) pageY = containment[3] + this.offset.click.top;
			}

			if(o.grid) {
				//Check for grid elements set to 0 to prevent divide by 0 error causing invalid argument errors in IE (see ticket #6950)
				var top = o.grid[1] ? this.originalPageY + Math.round((pageY - this.originalPageY) / o.grid[1]) * o.grid[1] : this.originalPageY;
				pageY = containment ? (!(top - this.offset.click.top <span class="xd">&lt; </span><span class="xn">containment[1] </span><span class="xan">|| </span><span class="xan">top </span><span class="xan">- </span><span class="xan">this.offset.click.top </span><span class="xd">&gt;</span> containment[3]) ? top : (!(top - this.offset.click.top <span class="xd">&lt; </span><span class="xn">containment[1]</span><span class="xd">) ? top - o.grid[1] : top + o.grid[1])) : top;

				var left = o.grid[0] ? this.originalPageX + Math.round((pageX - this.originalPageX) / o.grid[0]) * o.grid[0] : this.originalPageX;
				pageX = containment ? (!(left - this.offset.click.left </span><span class="xd">&lt; </span><span class="xn">containment[0] </span><span class="xan">|| </span><span class="xan">left </span><span class="xan">- </span><span class="xan">this.offset.click.left </span><span class="xd">&gt;</span> containment[2]) ? left : (!(left - this.offset.click.left <span class="xd">&lt; </span><span class="xn">containment[0]</span><span class="xd">) ? left - o.grid[0] : left + o.grid[0])) : left;
			}

		}

		return {
			top: (
				pageY																// The absolute mouse position
				- this.offset.click.top													// Click offset (relative to the element)
				- this.offset.relative.top												// Only for relative positioned nodes: Relative offset from element to offset parent
				- this.offset.parent.top												// The offsetParent&#39;s offset without borders (offset + border)
				+ ($.browser.safari &amp;&amp; $.browser.version </span><span class="xd">&lt; </span><span class="xn">526 </span><span class="xan">&amp;&amp; </span><span class="xan">this.cssPosition </span><span class="xd">=</span><span class="xav">=</span> &#39;<span class="xav">fixed</span>&#39; <span class="xd">? 0 : ( this.cssPosition == &#39;fixed&#39; ? -this.scrollParent.scrollTop() : ( scrollIsRootNode ? 0 : scroll.scrollTop() ) ))
			),
			left: (
				pageX																// The absolute mouse position
				- this.offset.click.left												// Click offset (relative to the element)
				- this.offset.relative.left												// Only for relative positioned nodes: Relative offset from element to offset parent
				- this.offset.parent.left												// The offsetParent&#39;s offset without borders (offset + border)
				+ ($.browser.safari &amp;&amp; $.browser.version </span><span class="xd">&lt; </span><span class="xn">526 </span><span class="xan">&amp;&amp; </span><span class="xan">this.cssPosition </span><span class="xd">=</span><span class="xav">=</span> &#39;<span class="xav">fixed</span>&#39; <span class="xd">? 0 : ( this.cssPosition == &#39;fixed&#39; ? -this.scrollParent.scrollLeft() : scrollIsRootNode ? 0 : scroll.scrollLeft() ))
			)
		};

	},

	_clear: function() {
		this.helper.removeClass(&quot;ui-draggable-dragging&quot;);
		if(this.helper[0] != this.element[0] &amp;&amp; !this.cancelHelperRemoval) this.helper.remove();
		//if($.ui.ddmanager) $.ui.ddmanager.current = null;
		this.helper = null;
		this.cancelHelperRemoval = false;
	},

	// From now on bulk stuff - mainly helpers

	_trigger: function(type, event, ui) {
		ui = ui || this._uiHash();
		$.ui.plugin.call(this, type, [event, ui]);
		if(type == &quot;drag&quot;) this.positionAbs = this._convertPositionTo(&quot;absolute&quot;); //The absolute position has to be recalculated after plugins
		return $.Widget.prototype._trigger.call(this, type, event, ui);
	},

	plugins: {},

	_uiHash: function(event) {
		return {
			helper: this.helper,
			position: this.position,
			originalPosition: this.originalPosition,
			offset: this.positionAbs
		};
	}

});

$.extend($.ui.draggable, {
	version: &quot;1.8.18&quot;
});

$.ui.plugin.add(&quot;draggable&quot;, &quot;connectToSortable&quot;, {
	start: function(event, ui) {

		var inst = $(this).data(&quot;draggable&quot;), o = inst.options,
			uiSortable = $.extend({}, ui, { item: inst.element });
		inst.sortables = [];
		$(o.connectToSortable).each(function() {
			var sortable = $.data(this, &#39;sortable&#39;);
			if (sortable &amp;&amp; !sortable.options.disabled) {
				inst.sortables.push({
					instance: sortable,
					shouldRevert: sortable.options.revert
				});
				sortable.refreshPositions();	// Call the sortable&#39;s refreshPositions at drag start to refresh the containerCache since the sortable container cache is used in drag and needs to be up to date (this will ensure it&#39;s initialised as well as being kept in step with any changes that might have happened on the page).
				sortable._trigger(&quot;activate&quot;, event, uiSortable);
			}
		});

	},
	stop: function(event, ui) {

		//If we are still over the sortable, we fake the stop event of the sortable, but also remove helper
		var inst = $(this).data(&quot;draggable&quot;),
			uiSortable = $.extend({}, ui, { item: inst.element });

		$.each(inst.sortables, function() {
			if(this.instance.isOver) {

				this.instance.isOver = 0;

				inst.cancelHelperRemoval = true; //Don&#39;t remove the helper in the draggable instance
				this.instance.cancelHelperRemoval = false; //Remove it in the sortable instance (so sortable plugins like revert still work)

				//The sortable revert is supported, and we have to set a temporary dropped variable on the draggable to support revert: &#39;valid/invalid&#39;
				if(this.shouldRevert) this.instance.options.revert = true;

				//Trigger the stop of the sortable
				this.instance._mouseStop(event);

				this.instance.options.helper = this.instance.options._helper;

				//If the helper has been the original item, restore properties in the sortable
				if(inst.options.helper == &#39;original&#39;)
					this.instance.currentItem.css({ top: &#39;auto&#39;, left: &#39;auto&#39; });

			} else {
				this.instance.cancelHelperRemoval = false; //Remove the helper in the sortable instance
				this.instance._trigger(&quot;deactivate&quot;, event, uiSortable);
			}

		});

	},
	drag: function(event, ui) {

		var inst = $(this).data(&quot;draggable&quot;), self = this;

		var checkPos = function(o) {
			var dyClick = this.offset.click.top, dxClick = this.offset.click.left;
			var helperTop = this.positionAbs.top, helperLeft = this.positionAbs.left;
			var itemHeight = o.height, itemWidth = o.width;
			var itemTop = o.top, itemLeft = o.left;

			return $.ui.isOver(helperTop + dyClick, helperLeft + dxClick, itemTop, itemLeft, itemHeight, itemWidth);
		};

		$.each(inst.sortables, function(i) {
			
			//Copy over some variables to allow calling the sortable&#39;s native _intersectsWith
			this.instance.positionAbs = inst.positionAbs;
			this.instance.helperProportions = inst.helperProportions;
			this.instance.offset.click = inst.offset.click;
			
			if(this.instance._intersectsWith(this.instance.containerCache)) {

				//If it intersects, we use a little isOver variable and set it once, so our move-in stuff gets fired only once
				if(!this.instance.isOver) {

					this.instance.isOver = 1;
					//Now we fake the start of dragging for the sortable instance,
					//by cloning the list group item, appending it to the sortable and using it as inst.currentItem
					//We can then fire the start event of the sortable with our passed browser event, and our own helper (so it doesn&#39;t create a new one)
					this.instance.currentItem = $(self).clone().removeAttr(&#39;id&#39;).appendTo(this.instance.element).data(&quot;sortable-item&quot;, true);
					this.instance.options._helper = this.instance.options.helper; //Store helper option to later restore it
					this.instance.options.helper = function() { return ui.helper[0]; };

					event.target = this.instance.currentItem[0];
					this.instance._mouseCapture(event, true);
					this.instance._mouseStart(event, true, true);

					//Because the browser event is way off the new appended portlet, we modify a couple of variables to reflect the changes
					this.instance.offset.click.top = inst.offset.click.top;
					this.instance.offset.click.left = inst.offset.click.left;
					this.instance.offset.parent.left -= inst.offset.parent.left - this.instance.offset.parent.left;
					this.instance.offset.parent.top -= inst.offset.parent.top - this.instance.offset.parent.top;

					inst._trigger(&quot;toSortable&quot;, event);
					inst.dropped = this.instance.element; //draggable revert needs that
					//hack so receive/update callbacks work (mostly)
					inst.currentItem = inst.element;
					this.instance.fromOutside = inst;

				}

				//Provided we did all the previous steps, we can fire the drag event of the sortable on every draggable drag, when it intersects with the sortable
				if(this.instance.currentItem) this.instance._mouseDrag(event);

			} else {

				//If it doesn&#39;t intersect with the sortable, and it intersected before,
				//we fake the drag stop of the sortable, but make sure it doesn&#39;t remove the helper by using cancelHelperRemoval
				if(this.instance.isOver) {

					this.instance.isOver = 0;
					this.instance.cancelHelperRemoval = true;
					
					//Prevent reverting on this forced stop
					this.instance.options.revert = false;
					
					// The out event needs to be triggered independently
					this.instance._trigger(&#39;out&#39;, event, this.instance._uiHash(this.instance));
					
					this.instance._mouseStop(event, true);
					this.instance.options.helper = this.instance.options._helper;

					//Now we remove our currentItem, the list group clone again, and the placeholder, and animate the helper back to it&#39;s original size
					this.instance.currentItem.remove();
					if(this.instance.placeholder) this.instance.placeholder.remove();

					inst._trigger(&quot;fromSortable&quot;, event);
					inst.dropped = false; //draggable revert needs that
				}

			};

		});

	}
});

$.ui.plugin.add(&quot;draggable&quot;, &quot;cursor&quot;, {
	start: function(event, ui) {
		var t = $(&#39;body&#39;), o = $(this).data(&#39;draggable&#39;).options;
		if (t.css(&quot;cursor&quot;)) o._cursor = t.css(&quot;cursor&quot;);
		t.css(&quot;cursor&quot;, o.cursor);
	},
	stop: function(event, ui) {
		var o = $(this).data(&#39;draggable&#39;).options;
		if (o._cursor) $(&#39;body&#39;).css(&quot;cursor&quot;, o._cursor);
	}
});

$.ui.plugin.add(&quot;draggable&quot;, &quot;opacity&quot;, {
	start: function(event, ui) {
		var t = $(ui.helper), o = $(this).data(&#39;draggable&#39;).options;
		if(t.css(&quot;opacity&quot;)) o._opacity = t.css(&quot;opacity&quot;);
		t.css(&#39;opacity&#39;, o.opacity);
	},
	stop: function(event, ui) {
		var o = $(this).data(&#39;draggable&#39;).options;
		if(o._opacity) $(ui.helper).css(&#39;opacity&#39;, o._opacity);
	}
});

$.ui.plugin.add(&quot;draggable&quot;, &quot;scroll&quot;, {
	start: function(event, ui) {
		var i = $(this).data(&quot;draggable&quot;);
		if(i.scrollParent[0] != document &amp;&amp; i.scrollParent[0].tagName != &#39;HTML&#39;) i.overflowOffset = i.scrollParent.offset();
	},
	drag: function(event, ui) {

		var i = $(this).data(&quot;draggable&quot;), o = i.options, scrolled = false;

		if(i.scrollParent[0] != document &amp;&amp; i.scrollParent[0].tagName != &#39;HTML&#39;) {

			if(!o.axis || o.axis != &#39;x&#39;) {
				if((i.overflowOffset.top + i.scrollParent[0].offsetHeight) - event.pageY </span><span class="xd">&lt; </span><span class="xn">o.scrollSensitivity</span><span class="xd">)
					i.scrollParent[0].scrollTop = scrolled = i.scrollParent[0].scrollTop + o.scrollSpeed;
				else if(event.pageY - i.overflowOffset.top </span><span class="xd">&lt; </span><span class="xn">o.scrollSensitivity</span><span class="xd">)
					i.scrollParent[0].scrollTop = scrolled = i.scrollParent[0].scrollTop - o.scrollSpeed;
			}

			if(!o.axis || o.axis != &#39;y&#39;) {
				if((i.overflowOffset.left + i.scrollParent[0].offsetWidth) - event.pageX </span><span class="xd">&lt; </span><span class="xn">o.scrollSensitivity</span><span class="xd">)
					i.scrollParent[0].scrollLeft = scrolled = i.scrollParent[0].scrollLeft + o.scrollSpeed;
				else if(event.pageX - i.overflowOffset.left </span><span class="xd">&lt; </span><span class="xn">o.scrollSensitivity</span><span class="xd">)
					i.scrollParent[0].scrollLeft = scrolled = i.scrollParent[0].scrollLeft - o.scrollSpeed;
			}

		} else {

			if(!o.axis || o.axis != &#39;x&#39;) {
				if(event.pageY - $(document).scrollTop() </span><span class="xd">&lt; </span><span class="xn">o.scrollSensitivity</span><span class="xd">)
					scrolled = $(document).scrollTop($(document).scrollTop() - o.scrollSpeed);
				else if($(window).height() - (event.pageY - $(document).scrollTop()) </span><span class="xd">&lt; </span><span class="xn">o.scrollSensitivity</span><span class="xd">)
					scrolled = $(document).scrollTop($(document).scrollTop() + o.scrollSpeed);
			}

			if(!o.axis || o.axis != &#39;y&#39;) {
				if(event.pageX - $(document).scrollLeft() </span><span class="xd">&lt; </span><span class="xn">o.scrollSensitivity</span><span class="xd">)
					scrolled = $(document).scrollLeft($(document).scrollLeft() - o.scrollSpeed);
				else if($(window).width() - (event.pageX - $(document).scrollLeft()) </span><span class="xd">&lt; </span><span class="xn">o.scrollSensitivity</span><span class="xd">)
					scrolled = $(document).scrollLeft($(document).scrollLeft() + o.scrollSpeed);
			}

		}

		if(scrolled !== false &amp;&amp; $.ui.ddmanager &amp;&amp; !o.dropBehaviour)
			$.ui.ddmanager.prepareOffsets(i, event);

	}
});

$.ui.plugin.add(&quot;draggable&quot;, &quot;snap&quot;, {
	start: function(event, ui) {

		var i = $(this).data(&quot;draggable&quot;), o = i.options;
		i.snapElements = [];

		$(o.snap.constructor != String ? ( o.snap.items || &#39;:data(draggable)&#39; ) : o.snap).each(function() {
			var $t = $(this); var $o = $t.offset();
			if(this != i.element[0]) i.snapElements.push({
				item: this,
				width: $t.outerWidth(), height: $t.outerHeight(),
				top: $o.top, left: $o.left
			});
		});

	},
	drag: function(event, ui) {

		var inst = $(this).data(&quot;draggable&quot;), o = inst.options;
		var d = o.snapTolerance;

		var x1 = ui.offset.left, x2 = x1 + inst.helperProportions.width,
			y1 = ui.offset.top, y2 = y1 + inst.helperProportions.height;

		for (var i = inst.snapElements.length - 1; i &gt;</span>= 0; i--){

			var l = inst.snapElements[i].left, r = l + inst.snapElements[i].width,
				t = inst.snapElements[i].top, b = t + inst.snapElements[i].height;

			//Yes, I know, this is insane ;)
			if(!((l-d <span class="xd">&lt; </span><span class="xn">x1 </span><span class="xan">&amp;&amp; </span><span class="xan">x1 </span><span class="xd">&lt; </span><span class="xn">r+d </span><span class="xan">&amp;&amp; </span><span class="xan">t-d </span><span class="xd">&lt; </span><span class="xn">y1 </span><span class="xan">&amp;&amp; </span><span class="xan">y1 </span><span class="xd">&lt; </span><span class="xn">b+d</span><span class="xd">) || (l-d </span><span class="xd">&lt; </span><span class="xn">x1 </span><span class="xan">&amp;&amp; </span><span class="xan">x1 </span><span class="xd">&lt; </span><span class="xn">r+d </span><span class="xan">&amp;&amp; </span><span class="xan">t-d </span><span class="xd">&lt; </span><span class="xn">y2 </span><span class="xan">&amp;&amp; </span><span class="xan">y2 </span><span class="xd">&lt; </span><span class="xn">b+d</span><span class="xd">) || (l-d </span><span class="xd">&lt; </span><span class="xn">x2 </span><span class="xan">&amp;&amp; </span><span class="xan">x2 </span><span class="xd">&lt; </span><span class="xn">r+d </span><span class="xan">&amp;&amp; </span><span class="xan">t-d </span><span class="xd">&lt; </span><span class="xn">y1 </span><span class="xan">&amp;&amp; </span><span class="xan">y1 </span><span class="xd">&lt; </span><span class="xn">b+d</span><span class="xd">) || (l-d </span><span class="xd">&lt; </span><span class="xn">x2 </span><span class="xan">&amp;&amp; </span><span class="xan">x2 </span><span class="xd">&lt; </span><span class="xn">r+d </span><span class="xan">&amp;&amp; </span><span class="xan">t-d </span><span class="xd">&lt; </span><span class="xn">y2 </span><span class="xan">&amp;&amp; </span><span class="xan">y2 </span><span class="xd">&lt; </span><span class="xn">b+d</span><span class="xd">))) {
				if(inst.snapElements[i].snapping) (inst.options.snap.release &amp;&amp; inst.options.snap.release.call(inst.element, event, $.extend(inst._uiHash(), { snapItem: inst.snapElements[i].item })));
				inst.snapElements[i].snapping = false;
				continue;
			}

			if(o.snapMode != &#39;inner&#39;) {
				var ts = Math.abs(t - y2) </span><span class="xd">&lt;</span><span class="xd">= </span><span class="xav">d;</span><span class="xan">
				var </span><span class="xan">bs </span><span class="xd">= </span><span class="xav">Math.abs(b</span><span class="xan"> - </span><span class="xan">y1</span><span class="xd">) </span><span class="xd">&lt;</span><span class="xd">= </span><span class="xav">d;</span><span class="xan">
				var </span><span class="xan">ls </span><span class="xd">= </span><span class="xav">Math.abs(l</span><span class="xan"> - </span><span class="xan">x2</span><span class="xd">) </span><span class="xd">&lt;</span><span class="xd">= </span><span class="xav">d;</span><span class="xan">
				var </span><span class="xan">rs </span><span class="xd">= </span><span class="xav">Math.abs(r</span><span class="xan"> - </span><span class="xan">x1</span><span class="xd">) </span><span class="xd">&lt;</span><span class="xd">= </span><span class="xav">d;</span><span class="xan">
				if</span><span class="xd">(ts) ui.position.top = inst._convertPositionTo(&quot;relative&quot;, { top: t - inst.helperProportions.height, left: 0 }).top - inst.margins.top;
				if(bs) ui.position.top = inst._convertPositionTo(&quot;relative&quot;, { top: b, left: 0 }).top - inst.margins.top;
				if(ls) ui.position.left = inst._convertPositionTo(&quot;relative&quot;, { top: 0, left: l - inst.helperProportions.width }).left - inst.margins.left;
				if(rs) ui.position.left = inst._convertPositionTo(&quot;relative&quot;, { top: 0, left: r }).left - inst.margins.left;
			}

			var first = (ts || bs || ls || rs);

			if(o.snapMode != &#39;outer&#39;) {
				var ts = Math.abs(t - y1) </span><span class="xd">&lt;</span><span class="xd">= </span><span class="xav">d;</span><span class="xan">
				var </span><span class="xan">bs </span><span class="xd">= </span><span class="xav">Math.abs(b</span><span class="xan"> - </span><span class="xan">y2</span><span class="xd">) </span><span class="xd">&lt;</span><span class="xd">= </span><span class="xav">d;</span><span class="xan">
				var </span><span class="xan">ls </span><span class="xd">= </span><span class="xav">Math.abs(l</span><span class="xan"> - </span><span class="xan">x1</span><span class="xd">) </span><span class="xd">&lt;</span><span class="xd">= </span><span class="xav">d;</span><span class="xan">
				var </span><span class="xan">rs </span><span class="xd">= </span><span class="xav">Math.abs(r</span><span class="xan"> - </span><span class="xan">x2</span><span class="xd">) </span><span class="xd">&lt;</span><span class="xd">= </span><span class="xav">d;</span><span class="xan">
				if</span><span class="xd">(ts) ui.position.top = inst._convertPositionTo(&quot;relative&quot;, { top: t, left: 0 }).top - inst.margins.top;
				if(bs) ui.position.top = inst._convertPositionTo(&quot;relative&quot;, { top: b - inst.helperProportions.height, left: 0 }).top - inst.margins.top;
				if(ls) ui.position.left = inst._convertPositionTo(&quot;relative&quot;, { top: 0, left: l }).left - inst.margins.left;
				if(rs) ui.position.left = inst._convertPositionTo(&quot;relative&quot;, { top: 0, left: r - inst.helperProportions.width }).left - inst.margins.left;
			}

			if(!inst.snapElements[i].snapping &amp;&amp; (ts || bs || ls || rs || first))
				(inst.options.snap.snap &amp;&amp; inst.options.snap.snap.call(inst.element, event, $.extend(inst._uiHash(), { snapItem: inst.snapElements[i].item })));
			inst.snapElements[i].snapping = (ts || bs || ls || rs || first);

		};

	}
});

$.ui.plugin.add(&quot;draggable&quot;, &quot;stack&quot;, {
	start: function(event, ui) {

		var o = $(this).data(&quot;draggable&quot;).options;

		var group = $.makeArray($(o.stack)).sort(function(a,b) {
			return (parseInt($(a).css(&quot;zIndex&quot;),10) || 0) - (parseInt($(b).css(&quot;zIndex&quot;),10) || 0);
		});
		if (!group.length) { return; }
		
		var min = parseInt(group[0].style.zIndex) || 0;
		$(group).each(function(i) {
			this.style.zIndex = min + i;
		});

		this[0].style.zIndex = min + group.length;

	}
});

$.ui.plugin.add(&quot;draggable&quot;, &quot;zIndex&quot;, {
	start: function(event, ui) {
		var t = $(ui.helper), o = $(this).data(&quot;draggable&quot;).options;
		if(t.css(&quot;zIndex&quot;)) o._zIndex = t.css(&quot;zIndex&quot;);
		t.css(&#39;zIndex&#39;, o.zIndex);
	},
	stop: function(event, ui) {
		var o = $(this).data(&quot;draggable&quot;).options;
		if(o._zIndex) $(ui.helper).css(&#39;zIndex&#39;, o._zIndex);
	}
});

})(jQuery);
/*
 * jQuery UI Droppable 1.8.18
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Droppables
 *
 * Depends:
 *	jquery.ui.core.js
 *	jquery.ui.widget.js
 *	jquery.ui.mouse.js
 *	jquery.ui.draggable.js
 */
(function( $, undefined ) {

$.widget(&quot;ui.droppable&quot;, {
	widgetEventPrefix: &quot;drop&quot;,
	options: {
		accept: &#39;*&#39;,
		activeClass: false,
		addClasses: true,
		greedy: false,
		hoverClass: false,
		scope: &#39;default&#39;,
		tolerance: &#39;intersect&#39;
	},
	_create: function() {

		var o = this.options, accept = o.accept;
		this.isover = 0; this.isout = 1;

		this.accept = $.isFunction(accept) ? accept : function(d) {
			return d.is(accept);
		};

		//Store the droppable&#39;s proportions
		this.proportions = { width: this.element[0].offsetWidth, height: this.element[0].offsetHeight };

		// Add the reference and positions to the manager
		$.ui.ddmanager.droppables[o.scope] = $.ui.ddmanager.droppables[o.scope] || [];
		$.ui.ddmanager.droppables[o.scope].push(this);

		(o.addClasses &amp;&amp; this.element.addClass(&quot;ui-droppable&quot;));

	},

	destroy: function() {
		var drop = $.ui.ddmanager.droppables[this.options.scope];
		for ( var i = 0; i </span><span class="xd">&lt; </span><span class="xn">drop.length</span><span class="xd">; i++ )
			if ( drop[i] == this )
				drop.splice(i, 1);

		this.element
			.removeClass(&quot;ui-droppable ui-droppable-disabled&quot;)
			.removeData(&quot;droppable&quot;)
			.unbind(&quot;.droppable&quot;);

		return this;
	},

	_setOption: function(key, value) {

		if(key == &#39;accept&#39;) {
			this.accept = $.isFunction(value) ? value : function(d) {
				return d.is(value);
			};
		}
		$.Widget.prototype._setOption.apply(this, arguments);
	},

	_activate: function(event) {
		var draggable = $.ui.ddmanager.current;
		if(this.options.activeClass) this.element.addClass(this.options.activeClass);
		(draggable &amp;&amp; this._trigger(&#39;activate&#39;, event, this.ui(draggable)));
	},

	_deactivate: function(event) {
		var draggable = $.ui.ddmanager.current;
		if(this.options.activeClass) this.element.removeClass(this.options.activeClass);
		(draggable &amp;&amp; this._trigger(&#39;deactivate&#39;, event, this.ui(draggable)));
	},

	_over: function(event) {

		var draggable = $.ui.ddmanager.current;
		if (!draggable || (draggable.currentItem || draggable.element)[0] == this.element[0]) return; // Bail if draggable and droppable are same element

		if (this.accept.call(this.element[0],(draggable.currentItem || draggable.element))) {
			if(this.options.hoverClass) this.element.addClass(this.options.hoverClass);
			this._trigger(&#39;over&#39;, event, this.ui(draggable));
		}

	},

	_out: function(event) {

		var draggable = $.ui.ddmanager.current;
		if (!draggable || (draggable.currentItem || draggable.element)[0] == this.element[0]) return; // Bail if draggable and droppable are same element

		if (this.accept.call(this.element[0],(draggable.currentItem || draggable.element))) {
			if(this.options.hoverClass) this.element.removeClass(this.options.hoverClass);
			this._trigger(&#39;out&#39;, event, this.ui(draggable));
		}

	},

	_drop: function(event,custom) {

		var draggable = custom || $.ui.ddmanager.current;
		if (!draggable || (draggable.currentItem || draggable.element)[0] == this.element[0]) return false; // Bail if draggable and droppable are same element

		var childrenIntersection = false;
		this.element.find(&quot;:data(droppable)&quot;).not(&quot;.ui-draggable-dragging&quot;).each(function() {
			var inst = $.data(this, &#39;droppable&#39;);
			if(
				inst.options.greedy
				&amp;&amp; !inst.options.disabled
				&amp;&amp; inst.options.scope == draggable.options.scope
				&amp;&amp; inst.accept.call(inst.element[0], (draggable.currentItem || draggable.element))
				&amp;&amp; $.ui.intersect(draggable, $.extend(inst, { offset: inst.element.offset() }), inst.options.tolerance)
			) { childrenIntersection = true; return false; }
		});
		if(childrenIntersection) return false;

		if(this.accept.call(this.element[0],(draggable.currentItem || draggable.element))) {
			if(this.options.activeClass) this.element.removeClass(this.options.activeClass);
			if(this.options.hoverClass) this.element.removeClass(this.options.hoverClass);
			this._trigger(&#39;drop&#39;, event, this.ui(draggable));
			return this.element;
		}

		return false;

	},

	ui: function(c) {
		return {
			draggable: (c.currentItem || c.element),
			helper: c.helper,
			position: c.position,
			offset: c.positionAbs
		};
	}

});

$.extend($.ui.droppable, {
	version: &quot;1.8.18&quot;
});

$.ui.intersect = function(draggable, droppable, toleranceMode) {

	if (!droppable.offset) return false;

	var x1 = (draggable.positionAbs || draggable.position.absolute).left, x2 = x1 + draggable.helperProportions.width,
		y1 = (draggable.positionAbs || draggable.position.absolute).top, y2 = y1 + draggable.helperProportions.height;
	var l = droppable.offset.left, r = l + droppable.proportions.width,
		t = droppable.offset.top, b = t + droppable.proportions.height;

	switch (toleranceMode) {
		case &#39;fit&#39;:
			return (l </span><span class="xd">&lt;</span><span class="xd">= </span><span class="xav">x1</span><span class="xan"> &amp;&amp; </span><span class="xan">x2 </span><span class="xd">&lt;</span><span class="xd">= </span><span class="xav">r</span><span class="xan">
				&amp;&amp; </span><span class="xan">t </span><span class="xd">&lt;</span><span class="xd">= </span><span class="xav">y1</span><span class="xan"> &amp;&amp; </span><span class="xan">y2 </span><span class="xd">&lt;</span><span class="xd">= </span><span class="xav">b);</span><span class="xan">
			break</span><span class="xd">;
		case &#39;intersect&#39;:
			return (l </span><span class="xd">&lt; </span><span class="xn">x1 </span><span class="xan">+ </span><span class="xd">(draggable.helperProportions.width / 2) // Right Half
				&amp;&amp; x2 - (draggable.helperProportions.width / 2) </span><span class="xd">&lt; </span><span class="xn">r </span><span class="xd">// Left Half
				&amp;&amp; t </span><span class="xd">&lt; </span><span class="xn">y1 </span><span class="xan">+ </span><span class="xd">(draggable.helperProportions.height / 2) // Bottom Half
				&amp;&amp; y2 - (draggable.helperProportions.height / 2) </span><span class="xd">&lt; </span><span class="xn">b </span><span class="xd">); // Top Half
			break;
		case &#39;pointer&#39;:
			var draggableLeft = ((draggable.positionAbs || draggable.position.absolute).left + (draggable.clickOffset || draggable.offset.click).left),
				draggableTop = ((draggable.positionAbs || draggable.position.absolute).top + (draggable.clickOffset || draggable.offset.click).top),
				isOver = $.ui.isOver(draggableTop, draggableLeft, t, l, droppable.proportions.height, droppable.proportions.width);
			return isOver;
			break;
		case &#39;touch&#39;:
			return (
					(y1 &gt;</span>= t <span class="xer">&amp;</span><span class="xer">&amp;</span> y1 <span class="xd">&lt;</span><span class="xd">= </span><span class="xav">b)</span><span class="xan"> ||	</span><span class="xd">// Top edge touching
					(y2 &gt;</span>= t <span class="xer">&amp;</span><span class="xer">&amp;</span> y2 <span class="xd">&lt;</span><span class="xd">= </span><span class="xav">b)</span><span class="xan"> ||	</span><span class="xd">// Bottom edge touching
					(y1 </span><span class="xd">&lt; </span><span class="xn">t </span><span class="xan">&amp;&amp; </span><span class="xan">y2 </span><span class="xd">&gt;</span> b)		// Surrounded vertically
				) <span class="xer">&amp;</span><span class="xer">&amp;</span> (
					(x1 &gt;= l <span class="xer">&amp;</span><span class="xer">&amp;</span> x1 <span class="xd">&lt;</span><span class="xd">= </span><span class="xav">r)</span><span class="xan"> ||	</span><span class="xd">// Left edge touching
					(x2 &gt;</span>= l <span class="xer">&amp;</span><span class="xer">&amp;</span> x2 <span class="xd">&lt;</span><span class="xd">= </span><span class="xav">r)</span><span class="xan"> ||	</span><span class="xd">// Right edge touching
					(x1 </span><span class="xd">&lt; </span><span class="xn">l </span><span class="xan">&amp;&amp; </span><span class="xan">x2 </span><span class="xd">&gt;</span> r)		// Surrounded horizontally
				);
			break;
		default:
			return false;
			break;
		}

};

/*
	This manager tracks offsets of draggables and droppables
*/
$.ui.ddmanager = {
	current: null,
	droppables: { &#39;default&#39;: [] },
	prepareOffsets: function(t, event) {

		var m = $.ui.ddmanager.droppables[t.options.scope] || [];
		var type = event ? event.type : null; // workaround for #2317
		var list = (t.currentItem || t.element).find(&quot;:data(droppable)&quot;).andSelf();

		droppablesLoop: for (var i = 0; i <span class="xd">&lt; </span><span class="xn">m.length</span><span class="xd">; i++) {

			if(m[i].options.disabled || (t &amp;&amp; !m[i].accept.call(m[i].element[0],(t.currentItem || t.element)))) continue;	//No disabled and non-accepted
			for (var j=0; j </span><span class="xd">&lt; </span><span class="xn">list.length</span><span class="xd">; j++) { if(list[j] == m[i].element[0]) { m[i].proportions.height = 0; continue droppablesLoop; } }; //Filter out elements in the current dragged item
			m[i].visible = m[i].element.css(&quot;display&quot;) != &quot;none&quot;; if(!m[i].visible) continue; 									//If the element is not visible, continue

			if(type == &quot;mousedown&quot;) m[i]._activate.call(m[i], event); //Activate the droppable if used directly from draggables

			m[i].offset = m[i].element.offset();
			m[i].proportions = { width: m[i].element[0].offsetWidth, height: m[i].element[0].offsetHeight };

		}

	},
	drop: function(draggable, event) {

		var dropped = false;
		$.each($.ui.ddmanager.droppables[draggable.options.scope] || [], function() {

			if(!this.options) return;
			if (!this.options.disabled &amp;&amp; this.visible &amp;&amp; $.ui.intersect(draggable, this, this.options.tolerance))
				dropped = this._drop.call(this, event) || dropped;

			if (!this.options.disabled &amp;&amp; this.visible &amp;&amp; this.accept.call(this.element[0],(draggable.currentItem || draggable.element))) {
				this.isout = 1; this.isover = 0;
				this._deactivate.call(this, event);
			}

		});
		return dropped;

	},
	dragStart: function( draggable, event ) {
		//Listen for scrolling so that if the dragging causes scrolling the position of the droppables can be recalculated (see #5003)
		draggable.element.parents( &quot;:not(body,html)&quot; ).bind( &quot;scroll.droppable&quot;, function() {
			if( !draggable.options.refreshPositions ) $.ui.ddmanager.prepareOffsets( draggable, event );
		});
	},
	drag: function(draggable, event) {

		//If you have a highly dynamic page, you might try this option. It renders positions every time you move the mouse.
		if(draggable.options.refreshPositions) $.ui.ddmanager.prepareOffsets(draggable, event);

		//Run through all droppables and check their positions based on specific tolerance options
		$.each($.ui.ddmanager.droppables[draggable.options.scope] || [], function() {

			if(this.options.disabled || this.greedyChild || !this.visible) return;
			var intersects = $.ui.intersect(draggable, this, this.options.tolerance);

			var c = !intersects &amp;&amp; this.isover == 1 ? &#39;isout&#39; : (intersects &amp;&amp; this.isover == 0 ? &#39;isover&#39; : null);
			if(!c) return;

			var parentInstance;
			if (this.options.greedy) {
				var parent = this.element.parents(&#39;:data(droppable):eq(0)&#39;);
				if (parent.length) {
					parentInstance = $.data(parent[0], &#39;droppable&#39;);
					parentInstance.greedyChild = (c == &#39;isover&#39; ? 1 : 0);
				}
			}

			// we just moved into a greedy child
			if (parentInstance &amp;&amp; c == &#39;isover&#39;) {
				parentInstance[&#39;isover&#39;] = 0;
				parentInstance[&#39;isout&#39;] = 1;
				parentInstance._out.call(parentInstance, event);
			}

			this[c] = 1; this[c == &#39;isout&#39; ? &#39;isover&#39; : &#39;isout&#39;] = 0;
			this[c == &quot;isover&quot; ? &quot;_over&quot; : &quot;_out&quot;].call(this, event);

			// we just moved out of a greedy child
			if (parentInstance &amp;&amp; c == &#39;isout&#39;) {
				parentInstance[&#39;isout&#39;] = 0;
				parentInstance[&#39;isover&#39;] = 1;
				parentInstance._over.call(parentInstance, event);
			}
		});

	},
	dragStop: function( draggable, event ) {
		draggable.element.parents( &quot;:not(body,html)&quot; ).unbind( &quot;scroll.droppable&quot; );
		//Call prepareOffsets one final time since IE does not fire return scroll events when overflow was caused by drag (see #5003)
		if( !draggable.options.refreshPositions ) $.ui.ddmanager.prepareOffsets( draggable, event );
	}
};

})(jQuery);
/*
 * jQuery UI Resizable 1.8.18
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Resizables
 *
 * Depends:
 *	jquery.ui.core.js
 *	jquery.ui.mouse.js
 *	jquery.ui.widget.js
 */
(function( $, undefined ) {

$.widget(&quot;ui.resizable&quot;, $.ui.mouse, {
	widgetEventPrefix: &quot;resize&quot;,
	options: {
		alsoResize: false,
		animate: false,
		animateDuration: &quot;slow&quot;,
		animateEasing: &quot;swing&quot;,
		aspectRatio: false,
		autoHide: false,
		containment: false,
		ghost: false,
		grid: false,
		handles: &quot;e,s,se&quot;,
		helper: false,
		maxHeight: null,
		maxWidth: null,
		minHeight: 10,
		minWidth: 10,
		zIndex: 1000
	},
	_create: function() {

		var self = this, o = this.options;
		this.element.addClass(&quot;ui-resizable&quot;);

		$.extend(this, {
			_aspectRatio: !!(o.aspectRatio),
			aspectRatio: o.aspectRatio,
			originalElement: this.element,
			_proportionallyResizeElements: [],
			_helper: o.helper || o.ghost || o.animate ? o.helper || &#39;ui-resizable-helper&#39; : null
		});

		//Wrap the element if it cannot hold child nodes
		if(this.element[0].nodeName.match(/canvas|textarea|input|select|button|img/i)) {

			//Create a wrapper element and set the wrapper to the new current internal element
			this.element.wrap(
				$(&#39;</span><span class="xd">&lt;</span><span class="xn">div </span><span class="xan">class</span><span class="xd">=</span>&quot;<span class="xav">ui-wrapper</span>&quot; <span class="xan">style</span><span class="xd">=</span>&quot;<span class="xav">overflow: hidden;</span>&quot;<span class="xd">&gt;</span><span class="xd">&lt;/</span><span class="xn">div</span><span class="xd">&gt;</span>&#39;).css({
					position: this.element.css(&#39;position&#39;),
					width: this.element.outerWidth(),
					height: this.element.outerHeight(),
					top: this.element.css(&#39;top&#39;),
					left: this.element.css(&#39;left&#39;)
				})
			);

			//Overwrite the original this.element
			this.element = this.element.parent().data(
				&quot;resizable&quot;, this.element.data(&#39;resizable&#39;)
			);

			this.elementIsWrapper = true;

			//Move margins to the wrapper
			this.element.css({ marginLeft: this.originalElement.css(&quot;marginLeft&quot;), marginTop: this.originalElement.css(&quot;marginTop&quot;), marginRight: this.originalElement.css(&quot;marginRight&quot;), marginBottom: this.originalElement.css(&quot;marginBottom&quot;) });
			this.originalElement.css({ marginLeft: 0, marginTop: 0, marginRight: 0, marginBottom: 0});

			//Prevent Safari textarea resize
			this.originalResizeStyle = this.originalElement.css(&#39;resize&#39;);
			this.originalElement.css(&#39;resize&#39;, &#39;none&#39;);

			//Push the actual element to our proportionallyResize internal array
			this._proportionallyResizeElements.push(this.originalElement.css({ position: &#39;static&#39;, zoom: 1, display: &#39;block&#39; }));

			// avoid IE jump (hard set the margin)
			this.originalElement.css({ margin: this.originalElement.css(&#39;margin&#39;) });

			// fix handlers offset
			this._proportionallyResize();

		}

		this.handles = o.handles || (!$(&#39;.ui-resizable-handle&#39;, this.element).length ? &quot;e,s,se&quot; : { n: &#39;.ui-resizable-n&#39;, e: &#39;.ui-resizable-e&#39;, s: &#39;.ui-resizable-s&#39;, w: &#39;.ui-resizable-w&#39;, se: &#39;.ui-resizable-se&#39;, sw: &#39;.ui-resizable-sw&#39;, ne: &#39;.ui-resizable-ne&#39;, nw: &#39;.ui-resizable-nw&#39; });
		if(this.handles.constructor == String) {

			if(this.handles == &#39;all&#39;) this.handles = &#39;n,e,s,w,se,sw,ne,nw&#39;;
			var n = this.handles.split(&quot;,&quot;); this.handles = {};

			for(var i = 0; i <span class="xd">&lt; </span><span class="xn">n.length</span><span class="xd">; i++) {

				var handle = $.trim(n[i]), hname = &#39;ui-resizable-&#39;+handle;
				var axis = $(&#39;</span><span class="xd">&lt;</span><span class="xn">div </span><span class="xan">class</span><span class="xd">=</span>&quot;<span class="xav">ui-resizable-handle &#39; + hname + &#39;</span>&quot;<span class="xd">&gt;</span><span class="xd">&lt;/</span><span class="xn">div</span><span class="xd">&gt;</span>&#39;);

				// increase zIndex of sw, se, ne, nw axis
				//TODO : this modifies original option
				if(/sw|se|ne|nw/.test(handle)) axis.css({ zIndex: ++o.zIndex });

				//TODO : What&#39;s going on here?
				if (&#39;se&#39; == handle) {
					axis.addClass(&#39;ui-icon ui-icon-gripsmall-diagonal-se&#39;);
				};

				//Insert into internal handles object and append to element
				this.handles[handle] = &#39;.ui-resizable-&#39;+handle;
				this.element.append(axis);
			}

		}

		this._renderAxis = function(target) {

			target = target || this.element;

			for(var i in this.handles) {

				if(this.handles[i].constructor == String)
					this.handles[i] = $(this.handles[i], this.element).show();

				//Apply pad to wrapper element, needed to fix axis position (textarea, inputs, scrolls)
				if (this.elementIsWrapper <span class="xer">&amp;</span><span class="xer">&amp;</span> this.originalElement[0].nodeName.match(/textarea|input|select|button/i)) {

					var axis = $(this.handles[i], this.element), padWrapper = 0;

					//Checking the correct pad and border
					padWrapper = /sw|ne|nw|se|n|s/.test(i) ? axis.outerHeight() : axis.outerWidth();

					//The padding type i have to apply...
					var padPos = [ &#39;padding&#39;,
						/ne|nw|n/.test(i) ? &#39;Top&#39; :
						/se|sw|s/.test(i) ? &#39;Bottom&#39; :
						/^e$/.test(i) ? &#39;Right&#39; : &#39;Left&#39; ].join(&quot;&quot;);

					target.css(padPos, padWrapper);

					this._proportionallyResize();

				}

				//TODO: What&#39;s that good for? There&#39;s not anything to be executed left
				if(!$(this.handles[i]).length)
					continue;

			}
		};

		//TODO: make renderAxis a prototype function
		this._renderAxis(this.element);

		this._handles = $(&#39;.ui-resizable-handle&#39;, this.element)
			.disableSelection();

		//Matching axis name
		this._handles.mouseover(function() {
			if (!self.resizing) {
				if (this.className)
					var axis = this.className.match(/ui-resizable-(se|sw|ne|nw|n|e|s|w)/i);
				//Axis, default = se
				self.axis = axis <span class="xer">&amp;</span><span class="xer">&amp;</span> axis[1] ? axis[1] : &#39;se&#39;;
			}
		});

		//If we want to auto hide the elements
		if (o.autoHide) {
			this._handles.hide();
			$(this.element)
				.addClass(&quot;ui-resizable-autohide&quot;)
				.hover(function() {
					if (o.disabled) return;
					$(this).removeClass(&quot;ui-resizable-autohide&quot;);
					self._handles.show();
				},
				function(){
					if (o.disabled) return;
					if (!self.resizing) {
						$(this).addClass(&quot;ui-resizable-autohide&quot;);
						self._handles.hide();
					}
				});
		}

		//Initialize the mouse interaction
		this._mouseInit();

	},

	destroy: function() {

		this._mouseDestroy();

		var _destroy = function(exp) {
			$(exp).removeClass(&quot;ui-resizable ui-resizable-disabled ui-resizable-resizing&quot;)
				.removeData(&quot;resizable&quot;).unbind(&quot;.resizable&quot;).find(&#39;.ui-resizable-handle&#39;).remove();
		};

		//TODO: Unwrap at same DOM position
		if (this.elementIsWrapper) {
			_destroy(this.element);
			var wrapper = this.element;
			wrapper.after(
				this.originalElement.css({
					position: wrapper.css(&#39;position&#39;),
					width: wrapper.outerWidth(),
					height: wrapper.outerHeight(),
					top: wrapper.css(&#39;top&#39;),
					left: wrapper.css(&#39;left&#39;)
				})
			).remove();
		}

		this.originalElement.css(&#39;resize&#39;, this.originalResizeStyle);
		_destroy(this.originalElement);

		return this;
	},

	_mouseCapture: function(event) {
		var handle = false;
		for (var i in this.handles) {
			if ($(this.handles[i])[0] == event.target) {
				handle = true;
			}
		}

		return !this.options.disabled <span class="xer">&amp;</span><span class="xer">&amp;</span> handle;
	},

	_mouseStart: function(event) {

		var o = this.options, iniPos = this.element.position(), el = this.element;

		this.resizing = true;
		this.documentScroll = { top: $(document).scrollTop(), left: $(document).scrollLeft() };

		// bugfix for http://dev.jquery.com/ticket/1749
		if (el.is(&#39;.ui-draggable&#39;) || (/absolute/).test(el.css(&#39;position&#39;))) {
			el.css({ position: &#39;absolute&#39;, top: iniPos.top, left: iniPos.left });
		}

		this._renderProxy();

		var curleft = num(this.helper.css(&#39;left&#39;)), curtop = num(this.helper.css(&#39;top&#39;));

		if (o.containment) {
			curleft += $(o.containment).scrollLeft() || 0;
			curtop += $(o.containment).scrollTop() || 0;
		}

		//Store needed variables
		this.offset = this.helper.offset();
		this.position = { left: curleft, top: curtop };
		this.size = this._helper ? { width: el.outerWidth(), height: el.outerHeight() } : { width: el.width(), height: el.height() };
		this.originalSize = this._helper ? { width: el.outerWidth(), height: el.outerHeight() } : { width: el.width(), height: el.height() };
		this.originalPosition = { left: curleft, top: curtop };
		this.sizeDiff = { width: el.outerWidth() - el.width(), height: el.outerHeight() - el.height() };
		this.originalMousePosition = { left: event.pageX, top: event.pageY };

		//Aspect Ratio
		this.aspectRatio = (typeof o.aspectRatio == &#39;number&#39;) ? o.aspectRatio : ((this.originalSize.width / this.originalSize.height) || 1);

	    var cursor = $(&#39;.ui-resizable-&#39; + this.axis).css(&#39;cursor&#39;);
	    $(&#39;body&#39;).css(&#39;cursor&#39;, cursor == &#39;auto&#39; ? this.axis + &#39;-resize&#39; : cursor);

		el.addClass(&quot;ui-resizable-resizing&quot;);
		this._propagate(&quot;start&quot;, event);
		return true;
	},

	_mouseDrag: function(event) {

		//Increase performance, avoid regex
		var el = this.helper, o = this.options, props = {},
			self = this, smp = this.originalMousePosition, a = this.axis;

		var dx = (event.pageX-smp.left)||0, dy = (event.pageY-smp.top)||0;
		var trigger = this._change[a];
		if (!trigger) return false;

		// Calculate the attrs that will be change
		var data = trigger.apply(this, [event, dx, dy]), ie6 = $.browser.msie <span class="xer">&amp;</span><span class="xer">&amp;</span> $.browser.version <span class="xd">&lt; </span><span class="xn">7</span><span class="xd">, csdif = this.sizeDiff;

		// Put this in the mouseDrag handler since the user can start pressing shift while resizing
		this._updateVirtualBoundaries(event.shiftKey);
		if (this._aspectRatio || event.shiftKey)
			data = this._updateRatio(data, event);

		data = this._respectSize(data, event);

		// plugins callbacks need to be called first
		this._propagate(&quot;resize&quot;, event);

		el.css({
			top: this.position.top + &quot;px&quot;, left: this.position.left + &quot;px&quot;,
			width: this.size.width + &quot;px&quot;, height: this.size.height + &quot;px&quot;
		});

		if (!this._helper &amp;&amp; this._proportionallyResizeElements.length)
			this._proportionallyResize();

		this._updateCache(data);

		// calling the user callback at the end
		this._trigger(&#39;resize&#39;, event, this.ui());

		return false;
	},

	_mouseStop: function(event) {

		this.resizing = false;
		var o = this.options, self = this;

		if(this._helper) {
			var pr = this._proportionallyResizeElements, ista = pr.length &amp;&amp; (/textarea/i).test(pr[0].nodeName),
				soffseth = ista &amp;&amp; $.ui.hasScroll(pr[0], &#39;left&#39;) /* TODO - jump height */ ? 0 : self.sizeDiff.height,
				soffsetw = ista ? 0 : self.sizeDiff.width;

			var s = { width: (self.helper.width()  - soffsetw), height: (self.helper.height() - soffseth) },
				left = (parseInt(self.element.css(&#39;left&#39;), 10) + (self.position.left - self.originalPosition.left)) || null,
				top = (parseInt(self.element.css(&#39;top&#39;), 10) + (self.position.top - self.originalPosition.top)) || null;

			if (!o.animate)
				this.element.css($.extend(s, { top: top, left: left }));

			self.helper.height(self.size.height);
			self.helper.width(self.size.width);

			if (this._helper &amp;&amp; !o.animate) this._proportionallyResize();
		}

		$(&#39;body&#39;).css(&#39;cursor&#39;, &#39;auto&#39;);

		this.element.removeClass(&quot;ui-resizable-resizing&quot;);

		this._propagate(&quot;stop&quot;, event);

		if (this._helper) this.helper.remove();
		return false;

	},

    _updateVirtualBoundaries: function(forceAspectRatio) {
        var o = this.options, pMinWidth, pMaxWidth, pMinHeight, pMaxHeight, b;

        b = {
            minWidth: isNumber(o.minWidth) ? o.minWidth : 0,
            maxWidth: isNumber(o.maxWidth) ? o.maxWidth : Infinity,
            minHeight: isNumber(o.minHeight) ? o.minHeight : 0,
            maxHeight: isNumber(o.maxHeight) ? o.maxHeight : Infinity
        };

        if(this._aspectRatio || forceAspectRatio) {
            // We want to create an enclosing box whose aspect ration is the requested one
            // First, compute the &quot;projected&quot; size for each dimension based on the aspect ratio and other dimension
            pMinWidth = b.minHeight * this.aspectRatio;
            pMinHeight = b.minWidth / this.aspectRatio;
            pMaxWidth = b.maxHeight * this.aspectRatio;
            pMaxHeight = b.maxWidth / this.aspectRatio;

            if(pMinWidth &gt;</span> b.minWidth) b.minWidth = pMinWidth;
            if(pMinHeight &gt; b.minHeight) b.minHeight = pMinHeight;
            if(pMaxWidth <span class="xd">&lt; </span><span class="xn">b.maxWidth</span><span class="xd">) b.maxWidth = pMaxWidth;
            if(pMaxHeight </span><span class="xd">&lt; </span><span class="xn">b.maxHeight</span><span class="xd">) b.maxHeight = pMaxHeight;
        }
        this._vBoundaries = b;
    },

	_updateCache: function(data) {
		var o = this.options;
		this.offset = this.helper.offset();
		if (isNumber(data.left)) this.position.left = data.left;
		if (isNumber(data.top)) this.position.top = data.top;
		if (isNumber(data.height)) this.size.height = data.height;
		if (isNumber(data.width)) this.size.width = data.width;
	},

	_updateRatio: function(data, event) {

		var o = this.options, cpos = this.position, csize = this.size, a = this.axis;

		if (isNumber(data.height)) data.width = (data.height * this.aspectRatio);
		else if (isNumber(data.width)) data.height = (data.width / this.aspectRatio);

		if (a == &#39;sw&#39;) {
			data.left = cpos.left + (csize.width - data.width);
			data.top = null;
		}
		if (a == &#39;nw&#39;) {
			data.top = cpos.top + (csize.height - data.height);
			data.left = cpos.left + (csize.width - data.width);
		}

		return data;
	},

	_respectSize: function(data, event) {

		var el = this.helper, o = this._vBoundaries, pRatio = this._aspectRatio || event.shiftKey, a = this.axis,
				ismaxw = isNumber(data.width) &amp;&amp; o.maxWidth &amp;&amp; (o.maxWidth </span><span class="xd">&lt; </span><span class="xn">data.width</span><span class="xd">), ismaxh = isNumber(data.height) &amp;&amp; o.maxHeight &amp;&amp; (o.maxHeight </span><span class="xd">&lt; </span><span class="xn">data.height</span><span class="xd">),
					isminw = isNumber(data.width) &amp;&amp; o.minWidth &amp;&amp; (o.minWidth &gt;</span> data.width), isminh = isNumber(data.height) <span class="xer">&amp;</span><span class="xer">&amp;</span> o.minHeight <span class="xer">&amp;</span><span class="xer">&amp;</span> (o.minHeight &gt; data.height);

		if (isminw) data.width = o.minWidth;
		if (isminh) data.height = o.minHeight;
		if (ismaxw) data.width = o.maxWidth;
		if (ismaxh) data.height = o.maxHeight;

		var dw = this.originalPosition.left + this.originalSize.width, dh = this.position.top + this.size.height;
		var cw = /sw|nw|w/.test(a), ch = /nw|ne|n/.test(a);

		if (isminw <span class="xer">&amp;</span><span class="xer">&amp;</span> cw) data.left = dw - o.minWidth;
		if (ismaxw <span class="xer">&amp;</span><span class="xer">&amp;</span> cw) data.left = dw - o.maxWidth;
		if (isminh <span class="xer">&amp;</span><span class="xer">&amp;</span> ch)	data.top = dh - o.minHeight;
		if (ismaxh <span class="xer">&amp;</span><span class="xer">&amp;</span> ch)	data.top = dh - o.maxHeight;

		// fixing jump error on top/left - bug #2330
		var isNotwh = !data.width <span class="xer">&amp;</span><span class="xer">&amp;</span> !data.height;
		if (isNotwh <span class="xer">&amp;</span><span class="xer">&amp;</span> !data.left <span class="xer">&amp;</span><span class="xer">&amp;</span> data.top) data.top = null;
		else if (isNotwh <span class="xer">&amp;</span><span class="xer">&amp;</span> !data.top <span class="xer">&amp;</span><span class="xer">&amp;</span> data.left) data.left = null;

		return data;
	},

	_proportionallyResize: function() {

		var o = this.options;
		if (!this._proportionallyResizeElements.length) return;
		var element = this.helper || this.element;

		for (var i=0; i <span class="xd">&lt; </span><span class="xn">this._proportionallyResizeElements.length</span><span class="xd">; i++) {

			var prel = this._proportionallyResizeElements[i];

			if (!this.borderDif) {
				var b = [prel.css(&#39;borderTopWidth&#39;), prel.css(&#39;borderRightWidth&#39;), prel.css(&#39;borderBottomWidth&#39;), prel.css(&#39;borderLeftWidth&#39;)],
					p = [prel.css(&#39;paddingTop&#39;), prel.css(&#39;paddingRight&#39;), prel.css(&#39;paddingBottom&#39;), prel.css(&#39;paddingLeft&#39;)];

				this.borderDif = $.map(b, function(v, i) {
					var border = parseInt(v,10)||0, padding = parseInt(p[i],10)||0;
					return border + padding;
				});
			}

			if ($.browser.msie &amp;&amp; !(!($(element).is(&#39;:hidden&#39;) || $(element).parents(&#39;:hidden&#39;).length)))
				continue;

			prel.css({
				height: (element.height() - this.borderDif[0] - this.borderDif[2]) || 0,
				width: (element.width() - this.borderDif[1] - this.borderDif[3]) || 0
			});

		};

	},

	_renderProxy: function() {

		var el = this.element, o = this.options;
		this.elementOffset = el.offset();

		if(this._helper) {

			this.helper = this.helper || $(&#39;</span><span class="xd">&lt;</span><span class="xn">div </span><span class="xan">style</span><span class="xd">=</span>&quot;<span class="xav">overflow:hidden;</span>&quot;<span class="xd">&gt;</span><span class="xd">&lt;/</span><span class="xn">div</span><span class="xd">&gt;</span>&#39;);

			// fix ie6 offset TODO: This seems broken
			var ie6 = $.browser.msie <span class="xer">&amp;</span><span class="xer">&amp;</span> $.browser.version <span class="xd">&lt; </span><span class="xn">7</span><span class="xd">, ie6offset = (ie6 ? 1 : 0),
			pxyoffset = ( ie6 ? 2 : -1 );

			this.helper.addClass(this._helper).css({
				width: this.element.outerWidth() + pxyoffset,
				height: this.element.outerHeight() + pxyoffset,
				position: &#39;absolute&#39;,
				left: this.elementOffset.left - ie6offset +&#39;px&#39;,
				top: this.elementOffset.top - ie6offset +&#39;px&#39;,
				zIndex: ++o.zIndex //TODO: Don&#39;t modify option
			});

			this.helper
				.appendTo(&quot;body&quot;)
				.disableSelection();

		} else {
			this.helper = this.element;
		}

	},

	_change: {
		e: function(event, dx, dy) {
			return { width: this.originalSize.width + dx };
		},
		w: function(event, dx, dy) {
			var o = this.options, cs = this.originalSize, sp = this.originalPosition;
			return { left: sp.left + dx, width: cs.width - dx };
		},
		n: function(event, dx, dy) {
			var o = this.options, cs = this.originalSize, sp = this.originalPosition;
			return { top: sp.top + dy, height: cs.height - dy };
		},
		s: function(event, dx, dy) {
			return { height: this.originalSize.height + dy };
		},
		se: function(event, dx, dy) {
			return $.extend(this._change.s.apply(this, arguments), this._change.e.apply(this, [event, dx, dy]));
		},
		sw: function(event, dx, dy) {
			return $.extend(this._change.s.apply(this, arguments), this._change.w.apply(this, [event, dx, dy]));
		},
		ne: function(event, dx, dy) {
			return $.extend(this._change.n.apply(this, arguments), this._change.e.apply(this, [event, dx, dy]));
		},
		nw: function(event, dx, dy) {
			return $.extend(this._change.n.apply(this, arguments), this._change.w.apply(this, [event, dx, dy]));
		}
	},

	_propagate: function(n, event) {
		$.ui.plugin.call(this, n, [event, this.ui()]);
		(n != &quot;resize&quot; &amp;&amp; this._trigger(n, event, this.ui()));
	},

	plugins: {},

	ui: function() {
		return {
			originalElement: this.originalElement,
			element: this.element,
			helper: this.helper,
			position: this.position,
			size: this.size,
			originalSize: this.originalSize,
			originalPosition: this.originalPosition
		};
	}

});

$.extend($.ui.resizable, {
	version: &quot;1.8.18&quot;
});

/*
 * Resizable Extensions
 */

$.ui.plugin.add(&quot;resizable&quot;, &quot;alsoResize&quot;, {

	start: function (event, ui) {
		var self = $(this).data(&quot;resizable&quot;), o = self.options;

		var _store = function (exp) {
			$(exp).each(function() {
				var el = $(this);
				el.data(&quot;resizable-alsoresize&quot;, {
					width: parseInt(el.width(), 10), height: parseInt(el.height(), 10),
					left: parseInt(el.css(&#39;left&#39;), 10), top: parseInt(el.css(&#39;top&#39;), 10)
				});
			});
		};

		if (typeof(o.alsoResize) == &#39;object&#39; &amp;&amp; !o.alsoResize.parentNode) {
			if (o.alsoResize.length) { o.alsoResize = o.alsoResize[0]; _store(o.alsoResize); }
			else { $.each(o.alsoResize, function (exp) { _store(exp); }); }
		}else{
			_store(o.alsoResize);
		}
	},

	resize: function (event, ui) {
		var self = $(this).data(&quot;resizable&quot;), o = self.options, os = self.originalSize, op = self.originalPosition;

		var delta = {
			height: (self.size.height - os.height) || 0, width: (self.size.width - os.width) || 0,
			top: (self.position.top - op.top) || 0, left: (self.position.left - op.left) || 0
		},

		_alsoResize = function (exp, c) {
			$(exp).each(function() {
				var el = $(this), start = $(this).data(&quot;resizable-alsoresize&quot;), style = {}, 
					css = c &amp;&amp; c.length ? c : el.parents(ui.originalElement[0]).length ? [&#39;width&#39;, &#39;height&#39;] : [&#39;width&#39;, &#39;height&#39;, &#39;top&#39;, &#39;left&#39;];

				$.each(css, function (i, prop) {
					var sum = (start[prop]||0) + (delta[prop]||0);
					if (sum &amp;&amp; sum &gt;</span>= 0)
						style[prop] = sum || null;
				});

				el.css(style);
			});
		};

		if (typeof(o.alsoResize) == &#39;object&#39; <span class="xer">&amp;</span><span class="xer">&amp;</span> !o.alsoResize.nodeType) {
			$.each(o.alsoResize, function (exp, c) { _alsoResize(exp, c); });
		}else{
			_alsoResize(o.alsoResize);
		}
	},

	stop: function (event, ui) {
		$(this).removeData(&quot;resizable-alsoresize&quot;);
	}
});

$.ui.plugin.add(&quot;resizable&quot;, &quot;animate&quot;, {

	stop: function(event, ui) {
		var self = $(this).data(&quot;resizable&quot;), o = self.options;

		var pr = self._proportionallyResizeElements, ista = pr.length <span class="xer">&amp;</span><span class="xer">&amp;</span> (/textarea/i).test(pr[0].nodeName),
					soffseth = ista <span class="xer">&amp;</span><span class="xer">&amp;</span> $.ui.hasScroll(pr[0], &#39;left&#39;) /* TODO - jump height */ ? 0 : self.sizeDiff.height,
						soffsetw = ista ? 0 : self.sizeDiff.width;

		var style = { width: (self.size.width - soffsetw), height: (self.size.height - soffseth) },
					left = (parseInt(self.element.css(&#39;left&#39;), 10) + (self.position.left - self.originalPosition.left)) || null,
						top = (parseInt(self.element.css(&#39;top&#39;), 10) + (self.position.top - self.originalPosition.top)) || null;

		self.element.animate(
			$.extend(style, top <span class="xer">&amp;</span><span class="xer">&amp;</span> left ? { top: top, left: left } : {}), {
				duration: o.animateDuration,
				easing: o.animateEasing,
				step: function() {

					var data = {
						width: parseInt(self.element.css(&#39;width&#39;), 10),
						height: parseInt(self.element.css(&#39;height&#39;), 10),
						top: parseInt(self.element.css(&#39;top&#39;), 10),
						left: parseInt(self.element.css(&#39;left&#39;), 10)
					};

					if (pr <span class="xer">&amp;</span><span class="xer">&amp;</span> pr.length) $(pr[0]).css({ width: data.width, height: data.height });

					// propagating resize, and updating values for each animation step
					self._updateCache(data);
					self._propagate(&quot;resize&quot;, event);

				}
			}
		);
	}

});

$.ui.plugin.add(&quot;resizable&quot;, &quot;containment&quot;, {

	start: function(event, ui) {
		var self = $(this).data(&quot;resizable&quot;), o = self.options, el = self.element;
		var oc = o.containment,	ce = (oc instanceof $) ? oc.get(0) : (/parent/.test(oc)) ? el.parent().get(0) : oc;
		if (!ce) return;

		self.containerElement = $(ce);

		if (/document/.test(oc) || oc == document) {
			self.containerOffset = { left: 0, top: 0 };
			self.containerPosition = { left: 0, top: 0 };

			self.parentData = {
				element: $(document), left: 0, top: 0,
				width: $(document).width(), height: $(document).height() || document.body.parentNode.scrollHeight
			};
		}

		// i&#39;m a node, so compute top, left, right, bottom
		else {
			var element = $(ce), p = [];
			$([ &quot;Top&quot;, &quot;Right&quot;, &quot;Left&quot;, &quot;Bottom&quot; ]).each(function(i, name) { p[i] = num(element.css(&quot;padding&quot; + name)); });

			self.containerOffset = element.offset();
			self.containerPosition = element.position();
			self.containerSize = { height: (element.innerHeight() - p[3]), width: (element.innerWidth() - p[1]) };

			var co = self.containerOffset, ch = self.containerSize.height,	cw = self.containerSize.width,
						width = ($.ui.hasScroll(ce, &quot;left&quot;) ? ce.scrollWidth : cw ), height = ($.ui.hasScroll(ce) ? ce.scrollHeight : ch);

			self.parentData = {
				element: ce, left: co.left, top: co.top, width: width, height: height
			};
		}
	},

	resize: function(event, ui) {
		var self = $(this).data(&quot;resizable&quot;), o = self.options,
				ps = self.containerSize, co = self.containerOffset, cs = self.size, cp = self.position,
				pRatio = self._aspectRatio || event.shiftKey, cop = { top:0, left:0 }, ce = self.containerElement;

		if (ce[0] != document <span class="xer">&amp;</span><span class="xer">&amp;</span> (/static/).test(ce.css(&#39;position&#39;))) cop = co;

		if (cp.left <span class="xd">&lt; </span><span class="xd">(self._helper ? co.left : 0)) {
			self.size.width = self.size.width + (self._helper ? (self.position.left - co.left) : (self.position.left - cop.left));
			if (pRatio) self.size.height = self.size.width / o.aspectRatio;
			self.position.left = o.helper ? co.left : 0;
		}

		if (cp.top </span><span class="xd">&lt; </span><span class="xd">(self._helper ? co.top : 0)) {
			self.size.height = self.size.height + (self._helper ? (self.position.top - co.top) : self.position.top);
			if (pRatio) self.size.width = self.size.height * o.aspectRatio;
			self.position.top = self._helper ? co.top : 0;
		}

		self.offset.left = self.parentData.left+self.position.left;
		self.offset.top = self.parentData.top+self.position.top;

		var woset = Math.abs( (self._helper ? self.offset.left - cop.left : (self.offset.left - cop.left)) + self.sizeDiff.width ),
					hoset = Math.abs( (self._helper ? self.offset.top - cop.top : (self.offset.top - co.top)) + self.sizeDiff.height );

		var isParent = self.containerElement.get(0) == self.element.parent().get(0),
		    isOffsetRelative = /relative|absolute/.test(self.containerElement.css(&#39;position&#39;));

		if(isParent &amp;&amp; isOffsetRelative) woset -= self.parentData.left;

		if (woset + self.size.width &gt;</span>= self.parentData.width) {
			self.size.width = self.parentData.width - woset;
			if (pRatio) self.size.height = self.size.width / self.aspectRatio;
		}

		if (hoset + self.size.height &gt;= self.parentData.height) {
			self.size.height = self.parentData.height - hoset;
			if (pRatio) self.size.width = self.size.height * self.aspectRatio;
		}
	},

	stop: function(event, ui){
		var self = $(this).data(&quot;resizable&quot;), o = self.options, cp = self.position,
				co = self.containerOffset, cop = self.containerPosition, ce = self.containerElement;

		var helper = $(self.helper), ho = helper.offset(), w = helper.outerWidth() - self.sizeDiff.width, h = helper.outerHeight() - self.sizeDiff.height;

		if (self._helper <span class="xer">&amp;</span><span class="xer">&amp;</span> !o.animate <span class="xer">&amp;</span><span class="xer">&amp;</span> (/relative/).test(ce.css(&#39;position&#39;)))
			$(this).css({ left: ho.left - cop.left - co.left, width: w, height: h });

		if (self._helper <span class="xer">&amp;</span><span class="xer">&amp;</span> !o.animate <span class="xer">&amp;</span><span class="xer">&amp;</span> (/static/).test(ce.css(&#39;position&#39;)))
			$(this).css({ left: ho.left - cop.left - co.left, width: w, height: h });

	}
});

$.ui.plugin.add(&quot;resizable&quot;, &quot;ghost&quot;, {

	start: function(event, ui) {

		var self = $(this).data(&quot;resizable&quot;), o = self.options, cs = self.size;

		self.ghost = self.originalElement.clone();
		self.ghost
			.css({ opacity: .25, display: &#39;block&#39;, position: &#39;relative&#39;, height: cs.height, width: cs.width, margin: 0, left: 0, top: 0 })
			.addClass(&#39;ui-resizable-ghost&#39;)
			.addClass(typeof o.ghost == &#39;string&#39; ? o.ghost : &#39;&#39;);

		self.ghost.appendTo(self.helper);

	},

	resize: function(event, ui){
		var self = $(this).data(&quot;resizable&quot;), o = self.options;
		if (self.ghost) self.ghost.css({ position: &#39;relative&#39;, height: self.size.height, width: self.size.width });
	},

	stop: function(event, ui){
		var self = $(this).data(&quot;resizable&quot;), o = self.options;
		if (self.ghost <span class="xer">&amp;</span><span class="xer">&amp;</span> self.helper) self.helper.get(0).removeChild(self.ghost.get(0));
	}

});

$.ui.plugin.add(&quot;resizable&quot;, &quot;grid&quot;, {

	resize: function(event, ui) {
		var self = $(this).data(&quot;resizable&quot;), o = self.options, cs = self.size, os = self.originalSize, op = self.originalPosition, a = self.axis, ratio = o._aspectRatio || event.shiftKey;
		o.grid = typeof o.grid == &quot;number&quot; ? [o.grid, o.grid] : o.grid;
		var ox = Math.round((cs.width - os.width) / (o.grid[0]||1)) * (o.grid[0]||1), oy = Math.round((cs.height - os.height) / (o.grid[1]||1)) * (o.grid[1]||1);

		if (/^(se|s|e)$/.test(a)) {
			self.size.width = os.width + ox;
			self.size.height = os.height + oy;
		}
		else if (/^(ne)$/.test(a)) {
			self.size.width = os.width + ox;
			self.size.height = os.height + oy;
			self.position.top = op.top - oy;
		}
		else if (/^(sw)$/.test(a)) {
			self.size.width = os.width + ox;
			self.size.height = os.height + oy;
			self.position.left = op.left - ox;
		}
		else {
			self.size.width = os.width + ox;
			self.size.height = os.height + oy;
			self.position.top = op.top - oy;
			self.position.left = op.left - ox;
		}
	}

});

var num = function(v) {
	return parseInt(v, 10) || 0;
};

var isNumber = function(value) {
	return !isNaN(parseInt(value, 10));
};

})(jQuery);
/*
 * jQuery UI Selectable 1.8.18
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Selectables
 *
 * Depends:
 *	jquery.ui.core.js
 *	jquery.ui.mouse.js
 *	jquery.ui.widget.js
 */
(function( $, undefined ) {

$.widget(&quot;ui.selectable&quot;, $.ui.mouse, {
	options: {
		appendTo: &#39;body&#39;,
		autoRefresh: true,
		distance: 0,
		filter: &#39;*&#39;,
		tolerance: &#39;touch&#39;
	},
	_create: function() {
		var self = this;

		this.element.addClass(&quot;ui-selectable&quot;);

		this.dragged = false;

		// cache selectee children based on filter
		var selectees;
		this.refresh = function() {
			selectees = $(self.options.filter, self.element[0]);
			selectees.addClass(&quot;ui-selectee&quot;);
			selectees.each(function() {
				var $this = $(this);
				var pos = $this.offset();
				$.data(this, &quot;selectable-item&quot;, {
					element: this,
					$element: $this,
					left: pos.left,
					top: pos.top,
					right: pos.left + $this.outerWidth(),
					bottom: pos.top + $this.outerHeight(),
					startselected: false,
					selected: $this.hasClass(&#39;ui-selected&#39;),
					selecting: $this.hasClass(&#39;ui-selecting&#39;),
					unselecting: $this.hasClass(&#39;ui-unselecting&#39;)
				});
			});
		};
		this.refresh();

		this.selectees = selectees.addClass(&quot;ui-selectee&quot;);

		this._mouseInit();

		this.helper = $(&quot;<span class="xd">&lt;</span><span class="xn">div </span><span class="xan">class</span><span class="xd">=</span>&#39;<span class="xav">ui-selectable-helper</span>&#39;<span class="xd">&gt;</span><span class="xd">&lt;/</span><span class="xn">div</span><span class="xd">&gt;</span>&quot;);
	},

	destroy: function() {
		this.selectees
			.removeClass(&quot;ui-selectee&quot;)
			.removeData(&quot;selectable-item&quot;);
		this.element
			.removeClass(&quot;ui-selectable ui-selectable-disabled&quot;)
			.removeData(&quot;selectable&quot;)
			.unbind(&quot;.selectable&quot;);
		this._mouseDestroy();

		return this;
	},

	_mouseStart: function(event) {
		var self = this;

		this.opos = [event.pageX, event.pageY];

		if (this.options.disabled)
			return;

		var options = this.options;

		this.selectees = $(options.filter, this.element[0]);

		this._trigger(&quot;start&quot;, event);

		$(options.appendTo).append(this.helper);
		// position helper (lasso)
		this.helper.css({
			&quot;left&quot;: event.clientX,
			&quot;top&quot;: event.clientY,
			&quot;width&quot;: 0,
			&quot;height&quot;: 0
		});

		if (options.autoRefresh) {
			this.refresh();
		}

		this.selectees.filter(&#39;.ui-selected&#39;).each(function() {
			var selectee = $.data(this, &quot;selectable-item&quot;);
			selectee.startselected = true;
			if (!event.metaKey <span class="xer">&amp;</span><span class="xer">&amp;</span> !event.ctrlKey) {
				selectee.$element.removeClass(&#39;ui-selected&#39;);
				selectee.selected = false;
				selectee.$element.addClass(&#39;ui-unselecting&#39;);
				selectee.unselecting = true;
				// selectable UNSELECTING callback
				self._trigger(&quot;unselecting&quot;, event, {
					unselecting: selectee.element
				});
			}
		});

		$(event.target).parents().andSelf().each(function() {
			var selectee = $.data(this, &quot;selectable-item&quot;);
			if (selectee) {
				var doSelect = (!event.metaKey <span class="xer">&amp;</span><span class="xer">&amp;</span> !event.ctrlKey) || !selectee.$element.hasClass(&#39;ui-selected&#39;);
				selectee.$element
					.removeClass(doSelect ? &quot;ui-unselecting&quot; : &quot;ui-selected&quot;)
					.addClass(doSelect ? &quot;ui-selecting&quot; : &quot;ui-unselecting&quot;);
				selectee.unselecting = !doSelect;
				selectee.selecting = doSelect;
				selectee.selected = doSelect;
				// selectable (UN)SELECTING callback
				if (doSelect) {
					self._trigger(&quot;selecting&quot;, event, {
						selecting: selectee.element
					});
				} else {
					self._trigger(&quot;unselecting&quot;, event, {
						unselecting: selectee.element
					});
				}
				return false;
			}
		});

	},

	_mouseDrag: function(event) {
		var self = this;
		this.dragged = true;

		if (this.options.disabled)
			return;

		var options = this.options;

		var x1 = this.opos[0], y1 = this.opos[1], x2 = event.pageX, y2 = event.pageY;
		if (x1 &gt; x2) { var tmp = x2; x2 = x1; x1 = tmp; }
		if (y1 &gt; y2) { var tmp = y2; y2 = y1; y1 = tmp; }
		this.helper.css({left: x1, top: y1, width: x2-x1, height: y2-y1});

		this.selectees.each(function() {
			var selectee = $.data(this, &quot;selectable-item&quot;);
			//prevent helper from being selected if appendTo: selectable
			if (!selectee || selectee.element == self.element[0])
				return;
			var hit = false;
			if (options.tolerance == &#39;touch&#39;) {
				hit = ( !(selectee.left &gt; x2 || selectee.right <span class="xd">&lt; </span><span class="xn">x1 </span><span class="xan">|| </span><span class="xan">selectee.top </span><span class="xd">&gt;</span> y2 || selectee.bottom <span class="xd">&lt; </span><span class="xn">y1</span><span class="xd">) );
			} else if (options.tolerance == &#39;fit&#39;) {
				hit = (selectee.left &gt;</span> x1 <span class="xer">&amp;</span><span class="xer">&amp;</span> selectee.right <span class="xd">&lt; </span><span class="xn">x2 </span><span class="xan">&amp;&amp; </span><span class="xan">selectee.top </span><span class="xd">&gt;</span> y1 <span class="xer">&amp;</span><span class="xer">&amp;</span> selectee.bottom <span class="xd">&lt; </span><span class="xn">y2</span><span class="xd">);
			}

			if (hit) {
				// SELECT
				if (selectee.selected) {
					selectee.$element.removeClass(&#39;ui-selected&#39;);
					selectee.selected = false;
				}
				if (selectee.unselecting) {
					selectee.$element.removeClass(&#39;ui-unselecting&#39;);
					selectee.unselecting = false;
				}
				if (!selectee.selecting) {
					selectee.$element.addClass(&#39;ui-selecting&#39;);
					selectee.selecting = true;
					// selectable SELECTING callback
					self._trigger(&quot;selecting&quot;, event, {
						selecting: selectee.element
					});
				}
			} else {
				// UNSELECT
				if (selectee.selecting) {
					if ((event.metaKey || event.ctrlKey) &amp;&amp; selectee.startselected) {
						selectee.$element.removeClass(&#39;ui-selecting&#39;);
						selectee.selecting = false;
						selectee.$element.addClass(&#39;ui-selected&#39;);
						selectee.selected = true;
					} else {
						selectee.$element.removeClass(&#39;ui-selecting&#39;);
						selectee.selecting = false;
						if (selectee.startselected) {
							selectee.$element.addClass(&#39;ui-unselecting&#39;);
							selectee.unselecting = true;
						}
						// selectable UNSELECTING callback
						self._trigger(&quot;unselecting&quot;, event, {
							unselecting: selectee.element
						});
					}
				}
				if (selectee.selected) {
					if (!event.metaKey &amp;&amp; !event.ctrlKey &amp;&amp; !selectee.startselected) {
						selectee.$element.removeClass(&#39;ui-selected&#39;);
						selectee.selected = false;

						selectee.$element.addClass(&#39;ui-unselecting&#39;);
						selectee.unselecting = true;
						// selectable UNSELECTING callback
						self._trigger(&quot;unselecting&quot;, event, {
							unselecting: selectee.element
						});
					}
				}
			}
		});

		return false;
	},

	_mouseStop: function(event) {
		var self = this;

		this.dragged = false;

		var options = this.options;

		$(&#39;.ui-unselecting&#39;, this.element[0]).each(function() {
			var selectee = $.data(this, &quot;selectable-item&quot;);
			selectee.$element.removeClass(&#39;ui-unselecting&#39;);
			selectee.unselecting = false;
			selectee.startselected = false;
			self._trigger(&quot;unselected&quot;, event, {
				unselected: selectee.element
			});
		});
		$(&#39;.ui-selecting&#39;, this.element[0]).each(function() {
			var selectee = $.data(this, &quot;selectable-item&quot;);
			selectee.$element.removeClass(&#39;ui-selecting&#39;).addClass(&#39;ui-selected&#39;);
			selectee.selecting = false;
			selectee.selected = true;
			selectee.startselected = true;
			self._trigger(&quot;selected&quot;, event, {
				selected: selectee.element
			});
		});
		this._trigger(&quot;stop&quot;, event);

		this.helper.remove();

		return false;
	}

});

$.extend($.ui.selectable, {
	version: &quot;1.8.18&quot;
});

})(jQuery);
/*
 * jQuery UI Sortable 1.8.18
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Sortables
 *
 * Depends:
 *	jquery.ui.core.js
 *	jquery.ui.mouse.js
 *	jquery.ui.widget.js
 */
(function( $, undefined ) {

$.widget(&quot;ui.sortable&quot;, $.ui.mouse, {
	widgetEventPrefix: &quot;sort&quot;,
	ready: false,
	options: {
		appendTo: &quot;parent&quot;,
		axis: false,
		connectWith: false,
		containment: false,
		cursor: &#39;auto&#39;,
		cursorAt: false,
		dropOnEmpty: true,
		forcePlaceholderSize: false,
		forceHelperSize: false,
		grid: false,
		handle: false,
		helper: &quot;original&quot;,
		items: &#39;&gt;</span> *&#39;,
		opacity: false,
		placeholder: false,
		revert: false,
		scroll: true,
		scrollSensitivity: 20,
		scrollSpeed: 20,
		scope: &quot;default&quot;,
		tolerance: &quot;intersect&quot;,
		zIndex: 1000
	},
	_create: function() {

		var o = this.options;
		this.containerCache = {};
		this.element.addClass(&quot;ui-sortable&quot;);

		//Get the items
		this.refresh();

		//Let&#39;s determine if the items are being displayed horizontally
		this.floating = this.items.length ? o.axis === &#39;x&#39; || (/left|right/).test(this.items[0].item.css(&#39;float&#39;)) || (/inline|table-cell/).test(this.items[0].item.css(&#39;display&#39;)) : false;

		//Let&#39;s determine the parent&#39;s offset
		this.offset = this.element.offset();

		//Initialize mouse events for interaction
		this._mouseInit();
		
		//We&#39;re ready to go
		this.ready = true

	},

	destroy: function() {
		$.Widget.prototype.destroy.call( this );
		this.element
			.removeClass(&quot;ui-sortable ui-sortable-disabled&quot;);
		this._mouseDestroy();

		for ( var i = this.items.length - 1; i &gt;= 0; i-- )
			this.items[i].item.removeData(this.widgetName + &quot;-item&quot;);

		return this;
	},

	_setOption: function(key, value){
		if ( key === &quot;disabled&quot; ) {
			this.options[ key ] = value;
	
			this.widget()
				[ value ? &quot;addClass&quot; : &quot;removeClass&quot;]( &quot;ui-sortable-disabled&quot; );
		} else {
			// Don&#39;t call widget base _setOption for disable as it adds ui-state-disabled class
			$.Widget.prototype._setOption.apply(this, arguments);
		}
	},

	_mouseCapture: function(event, overrideHandle) {
		var that = this;

		if (this.reverting) {
			return false;
		}

		if(this.options.disabled || this.options.type == &#39;static&#39;) return false;

		//We have to refresh the items data once first
		this._refreshItems(event);

		//Find out if the clicked node (or one of its parents) is a actual item in this.items
		var currentItem = null, self = this, nodes = $(event.target).parents().each(function() {
			if($.data(this, that.widgetName + &#39;-item&#39;) == self) {
				currentItem = $(this);
				return false;
			}
		});
		if($.data(event.target, that.widgetName + &#39;-item&#39;) == self) currentItem = $(event.target);

		if(!currentItem) return false;
		if(this.options.handle <span class="xer">&amp;</span><span class="xer">&amp;</span> !overrideHandle) {
			var validHandle = false;

			$(this.options.handle, currentItem).find(&quot;*&quot;).andSelf().each(function() { if(this == event.target) validHandle = true; });
			if(!validHandle) return false;
		}

		this.currentItem = currentItem;
		this._removeCurrentsFromItems();
		return true;

	},

	_mouseStart: function(event, overrideHandle, noActivation) {

		var o = this.options, self = this;
		this.currentContainer = this;

		//We only need to call refreshPositions, because the refreshItems call has been moved to mouseCapture
		this.refreshPositions();

		//Create and append the visible helper
		this.helper = this._createHelper(event);

		//Cache the helper size
		this._cacheHelperProportions();

		/*
		 * - Position generation -
		 * This block generates everything position related - it&#39;s the core of draggables.
		 */

		//Cache the margins of the original element
		this._cacheMargins();

		//Get the next scrolling parent
		this.scrollParent = this.helper.scrollParent();

		//The element&#39;s absolute position on the page minus margins
		this.offset = this.currentItem.offset();
		this.offset = {
			top: this.offset.top - this.margins.top,
			left: this.offset.left - this.margins.left
		};

		// Only after we got the offset, we can change the helper&#39;s position to absolute
		// TODO: Still need to figure out a way to make relative sorting possible
		this.helper.css(&quot;position&quot;, &quot;absolute&quot;);
		this.cssPosition = this.helper.css(&quot;position&quot;);

		$.extend(this.offset, {
			click: { //Where the click happened, relative to the element
				left: event.pageX - this.offset.left,
				top: event.pageY - this.offset.top
			},
			parent: this._getParentOffset(),
			relative: this._getRelativeOffset() //This is a relative to absolute position minus the actual position calculation - only used for relative positioned helper
		});

		//Generate the original position
		this.originalPosition = this._generatePosition(event);
		this.originalPageX = event.pageX;
		this.originalPageY = event.pageY;

		//Adjust the mouse offset relative to the helper if &#39;cursorAt&#39; is supplied
		(o.cursorAt <span class="xer">&amp;</span><span class="xer">&amp;</span> this._adjustOffsetFromHelper(o.cursorAt));

		//Cache the former DOM position
		this.domPosition = { prev: this.currentItem.prev()[0], parent: this.currentItem.parent()[0] };

		//If the helper is not the original, hide the original so it&#39;s not playing any role during the drag, won&#39;t cause anything bad this way
		if(this.helper[0] != this.currentItem[0]) {
			this.currentItem.hide();
		}

		//Create the placeholder
		this._createPlaceholder();

		//Set a containment if given in the options
		if(o.containment)
			this._setContainment();

		if(o.cursor) { // cursor option
			if ($(&#39;body&#39;).css(&quot;cursor&quot;)) this._storedCursor = $(&#39;body&#39;).css(&quot;cursor&quot;);
			$(&#39;body&#39;).css(&quot;cursor&quot;, o.cursor);
		}

		if(o.opacity) { // opacity option
			if (this.helper.css(&quot;opacity&quot;)) this._storedOpacity = this.helper.css(&quot;opacity&quot;);
			this.helper.css(&quot;opacity&quot;, o.opacity);
		}

		if(o.zIndex) { // zIndex option
			if (this.helper.css(&quot;zIndex&quot;)) this._storedZIndex = this.helper.css(&quot;zIndex&quot;);
			this.helper.css(&quot;zIndex&quot;, o.zIndex);
		}

		//Prepare scrolling
		if(this.scrollParent[0] != document <span class="xer">&amp;</span><span class="xer">&amp;</span> this.scrollParent[0].tagName != &#39;HTML&#39;)
			this.overflowOffset = this.scrollParent.offset();

		//Call callbacks
		this._trigger(&quot;start&quot;, event, this._uiHash());

		//Recache the helper size
		if(!this._preserveHelperProportions)
			this._cacheHelperProportions();


		//Post &#39;activate&#39; events to possible containers
		if(!noActivation) {
			 for (var i = this.containers.length - 1; i &gt;= 0; i--) { this.containers[i]._trigger(&quot;activate&quot;, event, self._uiHash(this)); }
		}

		//Prepare possible droppables
		if($.ui.ddmanager)
			$.ui.ddmanager.current = this;

		if ($.ui.ddmanager <span class="xer">&amp;</span><span class="xer">&amp;</span> !o.dropBehaviour)
			$.ui.ddmanager.prepareOffsets(this, event);

		this.dragging = true;

		this.helper.addClass(&quot;ui-sortable-helper&quot;);
		this._mouseDrag(event); //Execute the drag once - this causes the helper not to be visible before getting its correct position
		return true;

	},

	_mouseDrag: function(event) {

		//Compute the helpers position
		this.position = this._generatePosition(event);
		this.positionAbs = this._convertPositionTo(&quot;absolute&quot;);

		if (!this.lastPositionAbs) {
			this.lastPositionAbs = this.positionAbs;
		}

		//Do scrolling
		if(this.options.scroll) {
			var o = this.options, scrolled = false;
			if(this.scrollParent[0] != document <span class="xer">&amp;</span><span class="xer">&amp;</span> this.scrollParent[0].tagName != &#39;HTML&#39;) {

				if((this.overflowOffset.top + this.scrollParent[0].offsetHeight) - event.pageY <span class="xd">&lt; </span><span class="xn">o.scrollSensitivity</span><span class="xd">)
					this.scrollParent[0].scrollTop = scrolled = this.scrollParent[0].scrollTop + o.scrollSpeed;
				else if(event.pageY - this.overflowOffset.top </span><span class="xd">&lt; </span><span class="xn">o.scrollSensitivity</span><span class="xd">)
					this.scrollParent[0].scrollTop = scrolled = this.scrollParent[0].scrollTop - o.scrollSpeed;

				if((this.overflowOffset.left + this.scrollParent[0].offsetWidth) - event.pageX </span><span class="xd">&lt; </span><span class="xn">o.scrollSensitivity</span><span class="xd">)
					this.scrollParent[0].scrollLeft = scrolled = this.scrollParent[0].scrollLeft + o.scrollSpeed;
				else if(event.pageX - this.overflowOffset.left </span><span class="xd">&lt; </span><span class="xn">o.scrollSensitivity</span><span class="xd">)
					this.scrollParent[0].scrollLeft = scrolled = this.scrollParent[0].scrollLeft - o.scrollSpeed;

			} else {

				if(event.pageY - $(document).scrollTop() </span><span class="xd">&lt; </span><span class="xn">o.scrollSensitivity</span><span class="xd">)
					scrolled = $(document).scrollTop($(document).scrollTop() - o.scrollSpeed);
				else if($(window).height() - (event.pageY - $(document).scrollTop()) </span><span class="xd">&lt; </span><span class="xn">o.scrollSensitivity</span><span class="xd">)
					scrolled = $(document).scrollTop($(document).scrollTop() + o.scrollSpeed);

				if(event.pageX - $(document).scrollLeft() </span><span class="xd">&lt; </span><span class="xn">o.scrollSensitivity</span><span class="xd">)
					scrolled = $(document).scrollLeft($(document).scrollLeft() - o.scrollSpeed);
				else if($(window).width() - (event.pageX - $(document).scrollLeft()) </span><span class="xd">&lt; </span><span class="xn">o.scrollSensitivity</span><span class="xd">)
					scrolled = $(document).scrollLeft($(document).scrollLeft() + o.scrollSpeed);

			}

			if(scrolled !== false &amp;&amp; $.ui.ddmanager &amp;&amp; !o.dropBehaviour)
				$.ui.ddmanager.prepareOffsets(this, event);
		}

		//Regenerate the absolute position used for position checks
		this.positionAbs = this._convertPositionTo(&quot;absolute&quot;);

		//Set the helper position
		if(!this.options.axis || this.options.axis != &quot;y&quot;) this.helper[0].style.left = this.position.left+&#39;px&#39;;
		if(!this.options.axis || this.options.axis != &quot;x&quot;) this.helper[0].style.top = this.position.top+&#39;px&#39;;

		//Rearrange
		for (var i = this.items.length - 1; i &gt;</span>= 0; i--) {

			//Cache variables and intersection, continue if no intersection
			var item = this.items[i], itemElement = item.item[0], intersection = this._intersectsWithPointer(item);
			if (!intersection) continue;

			if(itemElement != this.currentItem[0] //cannot intersect with itself
				<span class="xer">&amp;</span><span class="xer">&amp;</span>	this.placeholder[intersection == 1 ? &quot;next&quot; : &quot;prev&quot;]()[0] != itemElement //no useless actions that have been done before
				<span class="xer">&amp;</span><span class="xer">&amp;</span>	!$.ui.contains(this.placeholder[0], itemElement) //no action if the item moved is the parent of the item checked
				<span class="xer">&amp;</span><span class="xer">&amp;</span> (this.options.type == &#39;semi-dynamic&#39; ? !$.ui.contains(this.element[0], itemElement) : true)
				//<span class="xer">&amp;</span><span class="xer">&amp;</span> itemElement.parentNode == this.placeholder[0].parentNode // only rearrange items within the same container
			) {

				this.direction = intersection == 1 ? &quot;down&quot; : &quot;up&quot;;

				if (this.options.tolerance == &quot;pointer&quot; || this._intersectsWithSides(item)) {
					this._rearrange(event, item);
				} else {
					break;
				}

				this._trigger(&quot;change&quot;, event, this._uiHash());
				break;
			}
		}

		//Post events to containers
		this._contactContainers(event);

		//Interconnect with droppables
		if($.ui.ddmanager) $.ui.ddmanager.drag(this, event);

		//Call callbacks
		this._trigger(&#39;sort&#39;, event, this._uiHash());

		this.lastPositionAbs = this.positionAbs;
		return false;

	},

	_mouseStop: function(event, noPropagation) {

		if(!event) return;

		//If we are using droppables, inform the manager about the drop
		if ($.ui.ddmanager <span class="xer">&amp;</span><span class="xer">&amp;</span> !this.options.dropBehaviour)
			$.ui.ddmanager.drop(this, event);

		if(this.options.revert) {
			var self = this;
			var cur = self.placeholder.offset();

			self.reverting = true;

			$(this.helper).animate({
				left: cur.left - this.offset.parent.left - self.margins.left + (this.offsetParent[0] == document.body ? 0 : this.offsetParent[0].scrollLeft),
				top: cur.top - this.offset.parent.top - self.margins.top + (this.offsetParent[0] == document.body ? 0 : this.offsetParent[0].scrollTop)
			}, parseInt(this.options.revert, 10) || 500, function() {
				self._clear(event);
			});
		} else {
			this._clear(event, noPropagation);
		}

		return false;

	},

	cancel: function() {

		var self = this;

		if(this.dragging) {

			this._mouseUp({ target: null });

			if(this.options.helper == &quot;original&quot;)
				this.currentItem.css(this._storedCSS).removeClass(&quot;ui-sortable-helper&quot;);
			else
				this.currentItem.show();

			//Post deactivating events to containers
			for (var i = this.containers.length - 1; i &gt;= 0; i--){
				this.containers[i]._trigger(&quot;deactivate&quot;, null, self._uiHash(this));
				if(this.containers[i].containerCache.over) {
					this.containers[i]._trigger(&quot;out&quot;, null, self._uiHash(this));
					this.containers[i].containerCache.over = 0;
				}
			}

		}

		if (this.placeholder) {
			//$(this.placeholder[0]).remove(); would have been the jQuery way - unfortunately, it unbinds ALL events from the original node!
			if(this.placeholder[0].parentNode) this.placeholder[0].parentNode.removeChild(this.placeholder[0]);
			if(this.options.helper != &quot;original&quot; <span class="xer">&amp;</span><span class="xer">&amp;</span> this.helper <span class="xer">&amp;</span><span class="xer">&amp;</span> this.helper[0].parentNode) this.helper.remove();

			$.extend(this, {
				helper: null,
				dragging: false,
				reverting: false,
				_noFinalSort: null
			});

			if(this.domPosition.prev) {
				$(this.domPosition.prev).after(this.currentItem);
			} else {
				$(this.domPosition.parent).prepend(this.currentItem);
			}
		}

		return this;

	},

	serialize: function(o) {

		var items = this._getItemsAsjQuery(o <span class="xer">&amp;</span><span class="xer">&amp;</span> o.connected);
		var str = []; o = o || {};

		$(items).each(function() {
			var res = ($(o.item || this).attr(o.attribute || &#39;id&#39;) || &#39;&#39;).match(o.expression || (/(.+)[-=_](.+)/));
			if(res) str.push((o.key || res[1]+&#39;[]&#39;)+&#39;=&#39;+(o.key <span class="xer">&amp;</span><span class="xer">&amp;</span> o.expression ? res[1] : res[2]));
		});

		if(!str.length <span class="xer">&amp;</span><span class="xer">&amp;</span> o.key) {
			str.push(o.key + &#39;=&#39;);
		}

		return str.join(&#39;<span class="xer">&amp;</span>&#39;);

	},

	toArray: function(o) {

		var items = this._getItemsAsjQuery(o <span class="xer">&amp;</span><span class="xer">&amp;</span> o.connected);
		var ret = []; o = o || {};

		items.each(function() { ret.push($(o.item || this).attr(o.attribute || &#39;id&#39;) || &#39;&#39;); });
		return ret;

	},

	/* Be careful with the following core functions */
	_intersectsWith: function(item) {

		var x1 = this.positionAbs.left,
			x2 = x1 + this.helperProportions.width,
			y1 = this.positionAbs.top,
			y2 = y1 + this.helperProportions.height;

		var l = item.left,
			r = l + item.width,
			t = item.top,
			b = t + item.height;

		var dyClick = this.offset.click.top,
			dxClick = this.offset.click.left;

		var isOverElement = (y1 + dyClick) &gt; t <span class="xer">&amp;</span><span class="xer">&amp;</span> (y1 + dyClick) <span class="xd">&lt; </span><span class="xn">b </span><span class="xan">&amp;&amp; </span><span class="xd">(x1 + dxClick) &gt;</span> l <span class="xer">&amp;</span><span class="xer">&amp;</span> (x1 + dxClick) <span class="xd">&lt; </span><span class="xn">r</span><span class="xd">;

		if(	   this.options.tolerance == &quot;pointer&quot;
			|| this.options.forcePointerForContainers
			|| (this.options.tolerance != &quot;pointer&quot; &amp;&amp; this.helperProportions[this.floating ? &#39;width&#39; : &#39;height&#39;] &gt;</span> item[this.floating ? &#39;width&#39; : &#39;height&#39;])
		) {
			return isOverElement;
		} else {

			return (l <span class="xd">&lt; </span><span class="xn">x1 </span><span class="xan">+ </span><span class="xd">(this.helperProportions.width / 2) // Right Half
				&amp;&amp; x2 - (this.helperProportions.width / 2) </span><span class="xd">&lt; </span><span class="xn">r </span><span class="xd">// Left Half
				&amp;&amp; t </span><span class="xd">&lt; </span><span class="xn">y1 </span><span class="xan">+ </span><span class="xd">(this.helperProportions.height / 2) // Bottom Half
				&amp;&amp; y2 - (this.helperProportions.height / 2) </span><span class="xd">&lt; </span><span class="xn">b </span><span class="xd">); // Top Half

		}
	},

	_intersectsWithPointer: function(item) {

		var isOverElementHeight = $.ui.isOverAxis(this.positionAbs.top + this.offset.click.top, item.top, item.height),
			isOverElementWidth = $.ui.isOverAxis(this.positionAbs.left + this.offset.click.left, item.left, item.width),
			isOverElement = isOverElementHeight &amp;&amp; isOverElementWidth,
			verticalDirection = this._getDragVerticalDirection(),
			horizontalDirection = this._getDragHorizontalDirection();

		if (!isOverElement)
			return false;

		return this.floating ?
			( ((horizontalDirection &amp;&amp; horizontalDirection == &quot;right&quot;) || verticalDirection == &quot;down&quot;) ? 2 : 1 )
			: ( verticalDirection &amp;&amp; (verticalDirection == &quot;down&quot; ? 2 : 1) );

	},

	_intersectsWithSides: function(item) {

		var isOverBottomHalf = $.ui.isOverAxis(this.positionAbs.top + this.offset.click.top, item.top + (item.height/2), item.height),
			isOverRightHalf = $.ui.isOverAxis(this.positionAbs.left + this.offset.click.left, item.left + (item.width/2), item.width),
			verticalDirection = this._getDragVerticalDirection(),
			horizontalDirection = this._getDragHorizontalDirection();

		if (this.floating &amp;&amp; horizontalDirection) {
			return ((horizontalDirection == &quot;right&quot; &amp;&amp; isOverRightHalf) || (horizontalDirection == &quot;left&quot; &amp;&amp; !isOverRightHalf));
		} else {
			return verticalDirection &amp;&amp; ((verticalDirection == &quot;down&quot; &amp;&amp; isOverBottomHalf) || (verticalDirection == &quot;up&quot; &amp;&amp; !isOverBottomHalf));
		}

	},

	_getDragVerticalDirection: function() {
		var delta = this.positionAbs.top - this.lastPositionAbs.top;
		return delta != 0 &amp;&amp; (delta &gt;</span> 0 ? &quot;down&quot; : &quot;up&quot;);
	},

	_getDragHorizontalDirection: function() {
		var delta = this.positionAbs.left - this.lastPositionAbs.left;
		return delta != 0 <span class="xer">&amp;</span><span class="xer">&amp;</span> (delta &gt; 0 ? &quot;right&quot; : &quot;left&quot;);
	},

	refresh: function(event) {
		this._refreshItems(event);
		this.refreshPositions();
		return this;
	},

	_connectWith: function() {
		var options = this.options;
		return options.connectWith.constructor == String
			? [options.connectWith]
			: options.connectWith;
	},
	
	_getItemsAsjQuery: function(connected) {

		var self = this;
		var items = [];
		var queries = [];
		var connectWith = this._connectWith();

		if(connectWith <span class="xer">&amp;</span><span class="xer">&amp;</span> connected) {
			for (var i = connectWith.length - 1; i &gt;= 0; i--){
				var cur = $(connectWith[i]);
				for (var j = cur.length - 1; j &gt;= 0; j--){
					var inst = $.data(cur[j], this.widgetName);
					if(inst <span class="xer">&amp;</span><span class="xer">&amp;</span> inst != this <span class="xer">&amp;</span><span class="xer">&amp;</span> !inst.options.disabled) {
						queries.push([$.isFunction(inst.options.items) ? inst.options.items.call(inst.element) : $(inst.options.items, inst.element).not(&quot;.ui-sortable-helper&quot;).not(&#39;.ui-sortable-placeholder&#39;), inst]);
					}
				};
			};
		}

		queries.push([$.isFunction(this.options.items) ? this.options.items.call(this.element, null, { options: this.options, item: this.currentItem }) : $(this.options.items, this.element).not(&quot;.ui-sortable-helper&quot;).not(&#39;.ui-sortable-placeholder&#39;), this]);

		for (var i = queries.length - 1; i &gt;= 0; i--){
			queries[i][0].each(function() {
				items.push(this);
			});
		};

		return $(items);

	},

	_removeCurrentsFromItems: function() {

		var list = this.currentItem.find(&quot;:data(&quot; + this.widgetName + &quot;-item)&quot;);

		for (var i=0; i <span class="xd">&lt; </span><span class="xn">this.items.length</span><span class="xd">; i++) {

			for (var j=0; j </span><span class="xd">&lt; </span><span class="xn">list.length</span><span class="xd">; j++) {
				if(list[j] == this.items[i].item[0])
					this.items.splice(i,1);
			};

		};

	},

	_refreshItems: function(event) {

		this.items = [];
		this.containers = [this];
		var items = this.items;
		var self = this;
		var queries = [[$.isFunction(this.options.items) ? this.options.items.call(this.element[0], event, { item: this.currentItem }) : $(this.options.items, this.element), this]];
		var connectWith = this._connectWith();

		if(connectWith &amp;&amp; this.ready) { //Shouldn&#39;t be run the first time through due to massive slow-down
			for (var i = connectWith.length - 1; i &gt;</span>= 0; i--){
				var cur = $(connectWith[i]);
				for (var j = cur.length - 1; j &gt;= 0; j--){
					var inst = $.data(cur[j], this.widgetName);
					if(inst <span class="xer">&amp;</span><span class="xer">&amp;</span> inst != this <span class="xer">&amp;</span><span class="xer">&amp;</span> !inst.options.disabled) {
						queries.push([$.isFunction(inst.options.items) ? inst.options.items.call(inst.element[0], event, { item: this.currentItem }) : $(inst.options.items, inst.element), inst]);
						this.containers.push(inst);
					}
				};
			};
		}

		for (var i = queries.length - 1; i &gt;= 0; i--) {
			var targetData = queries[i][1];
			var _queries = queries[i][0];

			for (var j=0, queriesLength = _queries.length; j <span class="xd">&lt; </span><span class="xn">queriesLength</span><span class="xd">; j++) {
				var item = $(_queries[j]);

				item.data(this.widgetName + &#39;-item&#39;, targetData); // Data for target checking (mouse manager)

				items.push({
					item: item,
					instance: targetData,
					width: 0, height: 0,
					left: 0, top: 0
				});
			};
		};

	},

	refreshPositions: function(fast) {

		//This has to be redone because due to the item being moved out/into the offsetParent, the offsetParent&#39;s position will change
		if(this.offsetParent &amp;&amp; this.helper) {
			this.offset.parent = this._getParentOffset();
		}

		for (var i = this.items.length - 1; i &gt;</span>= 0; i--){
			var item = this.items[i];

			//We ignore calculating positions of all connected containers when we&#39;re not over them
			if(item.instance != this.currentContainer <span class="xer">&amp;</span><span class="xer">&amp;</span> this.currentContainer <span class="xer">&amp;</span><span class="xer">&amp;</span> item.item[0] != this.currentItem[0])
				continue;

			var t = this.options.toleranceElement ? $(this.options.toleranceElement, item.item) : item.item;

			if (!fast) {
				item.width = t.outerWidth();
				item.height = t.outerHeight();
			}

			var p = t.offset();
			item.left = p.left;
			item.top = p.top;
		};

		if(this.options.custom <span class="xer">&amp;</span><span class="xer">&amp;</span> this.options.custom.refreshContainers) {
			this.options.custom.refreshContainers.call(this);
		} else {
			for (var i = this.containers.length - 1; i &gt;= 0; i--){
				var p = this.containers[i].element.offset();
				this.containers[i].containerCache.left = p.left;
				this.containers[i].containerCache.top = p.top;
				this.containers[i].containerCache.width	= this.containers[i].element.outerWidth();
				this.containers[i].containerCache.height = this.containers[i].element.outerHeight();
			};
		}

		return this;
	},

	_createPlaceholder: function(that) {

		var self = that || this, o = self.options;

		if(!o.placeholder || o.placeholder.constructor == String) {
			var className = o.placeholder;
			o.placeholder = {
				element: function() {

					var el = $(document.createElement(self.currentItem[0].nodeName))
						.addClass(className || self.currentItem[0].className+&quot; ui-sortable-placeholder&quot;)
						.removeClass(&quot;ui-sortable-helper&quot;)[0];

					if(!className)
						el.style.visibility = &quot;hidden&quot;;

					return el;
				},
				update: function(container, p) {

					// 1. If a className is set as &#39;placeholder option, we don&#39;t force sizes - the class is responsible for that
					// 2. The option &#39;forcePlaceholderSize can be enabled to force it even if a class name is specified
					if(className <span class="xer">&amp;</span><span class="xer">&amp;</span> !o.forcePlaceholderSize) return;

					//If the element doesn&#39;t have a actual height by itself (without styles coming from a stylesheet), it receives the inline height from the dragged item
					if(!p.height()) { p.height(self.currentItem.innerHeight() - parseInt(self.currentItem.css(&#39;paddingTop&#39;)||0, 10) - parseInt(self.currentItem.css(&#39;paddingBottom&#39;)||0, 10)); };
					if(!p.width()) { p.width(self.currentItem.innerWidth() - parseInt(self.currentItem.css(&#39;paddingLeft&#39;)||0, 10) - parseInt(self.currentItem.css(&#39;paddingRight&#39;)||0, 10)); };
				}
			};
		}

		//Create the placeholder
		self.placeholder = $(o.placeholder.element.call(self.element, self.currentItem));

		//Append it after the actual current item
		self.currentItem.after(self.placeholder);

		//Update the size of the placeholder (TODO: Logic to fuzzy, see line 316/317)
		o.placeholder.update(self, self.placeholder);

	},

	_contactContainers: function(event) {
		
		// get innermost container that intersects with item 
		var innermostContainer = null, innermostIndex = null;		
		
		
		for (var i = this.containers.length - 1; i &gt;= 0; i--){

			// never consider a container that&#39;s located within the item itself 
			if($.ui.contains(this.currentItem[0], this.containers[i].element[0]))
				continue;

			if(this._intersectsWith(this.containers[i].containerCache)) {

				// if we&#39;ve already found a container and it&#39;s more &quot;inner&quot; than this, then continue 
				if(innermostContainer <span class="xer">&amp;</span><span class="xer">&amp;</span> $.ui.contains(this.containers[i].element[0], innermostContainer.element[0]))
					continue;

				innermostContainer = this.containers[i]; 
				innermostIndex = i;
					
			} else {
				// container doesn&#39;t intersect. trigger &quot;out&quot; event if necessary 
				if(this.containers[i].containerCache.over) {
					this.containers[i]._trigger(&quot;out&quot;, event, this._uiHash(this));
					this.containers[i].containerCache.over = 0;
				}
			}

		}
		
		// if no intersecting containers found, return 
		if(!innermostContainer) return; 

		// move the item into the container if it&#39;s not there already
		if(this.containers.length === 1) {
			this.containers[innermostIndex]._trigger(&quot;over&quot;, event, this._uiHash(this));
			this.containers[innermostIndex].containerCache.over = 1;
		} else if(this.currentContainer != this.containers[innermostIndex]) { 

			//When entering a new container, we will find the item with the least distance and append our item near it 
			var dist = 10000; var itemWithLeastDistance = null; var base = this.positionAbs[this.containers[innermostIndex].floating ? &#39;left&#39; : &#39;top&#39;]; 
			for (var j = this.items.length - 1; j &gt;= 0; j--) { 
				if(!$.ui.contains(this.containers[innermostIndex].element[0], this.items[j].item[0])) continue; 
				var cur = this.items[j][this.containers[innermostIndex].floating ? &#39;left&#39; : &#39;top&#39;]; 
				if(Math.abs(cur - base) <span class="xd">&lt; </span><span class="xn">dist</span><span class="xd">) { 
					dist = Math.abs(cur - base); itemWithLeastDistance = this.items[j]; 
				} 
			} 

			if(!itemWithLeastDistance &amp;&amp; !this.options.dropOnEmpty) //Check if dropOnEmpty is enabled 
				return; 

			this.currentContainer = this.containers[innermostIndex]; 
			itemWithLeastDistance ? this._rearrange(event, itemWithLeastDistance, null, true) : this._rearrange(event, null, this.containers[innermostIndex].element, true); 
			this._trigger(&quot;change&quot;, event, this._uiHash()); 
			this.containers[innermostIndex]._trigger(&quot;change&quot;, event, this._uiHash(this)); 

			//Update the placeholder 
			this.options.placeholder.update(this.currentContainer, this.placeholder); 
		
			this.containers[innermostIndex]._trigger(&quot;over&quot;, event, this._uiHash(this)); 
			this.containers[innermostIndex].containerCache.over = 1;
		} 
	
		
	},

	_createHelper: function(event) {

		var o = this.options;
		var helper = $.isFunction(o.helper) ? $(o.helper.apply(this.element[0], [event, this.currentItem])) : (o.helper == &#39;clone&#39; ? this.currentItem.clone() : this.currentItem);

		if(!helper.parents(&#39;body&#39;).length) //Add the helper to the DOM if that didn&#39;t happen already
			$(o.appendTo != &#39;parent&#39; ? o.appendTo : this.currentItem[0].parentNode)[0].appendChild(helper[0]);

		if(helper[0] == this.currentItem[0])
			this._storedCSS = { width: this.currentItem[0].style.width, height: this.currentItem[0].style.height, position: this.currentItem.css(&quot;position&quot;), top: this.currentItem.css(&quot;top&quot;), left: this.currentItem.css(&quot;left&quot;) };

		if(helper[0].style.width == &#39;&#39; || o.forceHelperSize) helper.width(this.currentItem.width());
		if(helper[0].style.height == &#39;&#39; || o.forceHelperSize) helper.height(this.currentItem.height());

		return helper;

	},

	_adjustOffsetFromHelper: function(obj) {
		if (typeof obj == &#39;string&#39;) {
			obj = obj.split(&#39; &#39;);
		}
		if ($.isArray(obj)) {
			obj = {left: +obj[0], top: +obj[1] || 0};
		}
		if (&#39;left&#39; in obj) {
			this.offset.click.left = obj.left + this.margins.left;
		}
		if (&#39;right&#39; in obj) {
			this.offset.click.left = this.helperProportions.width - obj.right + this.margins.left;
		}
		if (&#39;top&#39; in obj) {
			this.offset.click.top = obj.top + this.margins.top;
		}
		if (&#39;bottom&#39; in obj) {
			this.offset.click.top = this.helperProportions.height - obj.bottom + this.margins.top;
		}
	},

	_getParentOffset: function() {


		//Get the offsetParent and cache its position
		this.offsetParent = this.helper.offsetParent();
		var po = this.offsetParent.offset();

		// This is a special case where we need to modify a offset calculated on start, since the following happened:
		// 1. The position of the helper is absolute, so it&#39;s position is calculated based on the next positioned parent
		// 2. The actual offset parent is a child of the scroll parent, and the scroll parent isn&#39;t the document, which means that
		//    the scroll is included in the initial calculation of the offset of the parent, and never recalculated upon drag
		if(this.cssPosition == &#39;absolute&#39; &amp;&amp; this.scrollParent[0] != document &amp;&amp; $.ui.contains(this.scrollParent[0], this.offsetParent[0])) {
			po.left += this.scrollParent.scrollLeft();
			po.top += this.scrollParent.scrollTop();
		}

		if((this.offsetParent[0] == document.body) //This needs to be actually done for all browsers, since pageX/pageY includes this information
		|| (this.offsetParent[0].tagName &amp;&amp; this.offsetParent[0].tagName.toLowerCase() == &#39;html&#39; &amp;&amp; $.browser.msie)) //Ugly IE fix
			po = { top: 0, left: 0 };

		return {
			top: po.top + (parseInt(this.offsetParent.css(&quot;borderTopWidth&quot;),10) || 0),
			left: po.left + (parseInt(this.offsetParent.css(&quot;borderLeftWidth&quot;),10) || 0)
		};

	},

	_getRelativeOffset: function() {

		if(this.cssPosition == &quot;relative&quot;) {
			var p = this.currentItem.position();
			return {
				top: p.top - (parseInt(this.helper.css(&quot;top&quot;),10) || 0) + this.scrollParent.scrollTop(),
				left: p.left - (parseInt(this.helper.css(&quot;left&quot;),10) || 0) + this.scrollParent.scrollLeft()
			};
		} else {
			return { top: 0, left: 0 };
		}

	},

	_cacheMargins: function() {
		this.margins = {
			left: (parseInt(this.currentItem.css(&quot;marginLeft&quot;),10) || 0),
			top: (parseInt(this.currentItem.css(&quot;marginTop&quot;),10) || 0)
		};
	},

	_cacheHelperProportions: function() {
		this.helperProportions = {
			width: this.helper.outerWidth(),
			height: this.helper.outerHeight()
		};
	},

	_setContainment: function() {

		var o = this.options;
		if(o.containment == &#39;parent&#39;) o.containment = this.helper[0].parentNode;
		if(o.containment == &#39;document&#39; || o.containment == &#39;window&#39;) this.containment = [
			0 - this.offset.relative.left - this.offset.parent.left,
			0 - this.offset.relative.top - this.offset.parent.top,
			$(o.containment == &#39;document&#39; ? document : window).width() - this.helperProportions.width - this.margins.left,
			($(o.containment == &#39;document&#39; ? document : window).height() || document.body.parentNode.scrollHeight) - this.helperProportions.height - this.margins.top
		];

		if(!(/^(document|window|parent)$/).test(o.containment)) {
			var ce = $(o.containment)[0];
			var co = $(o.containment).offset();
			var over = ($(ce).css(&quot;overflow&quot;) != &#39;hidden&#39;);

			this.containment = [
				co.left + (parseInt($(ce).css(&quot;borderLeftWidth&quot;),10) || 0) + (parseInt($(ce).css(&quot;paddingLeft&quot;),10) || 0) - this.margins.left,
				co.top + (parseInt($(ce).css(&quot;borderTopWidth&quot;),10) || 0) + (parseInt($(ce).css(&quot;paddingTop&quot;),10) || 0) - this.margins.top,
				co.left+(over ? Math.max(ce.scrollWidth,ce.offsetWidth) : ce.offsetWidth) - (parseInt($(ce).css(&quot;borderLeftWidth&quot;),10) || 0) - (parseInt($(ce).css(&quot;paddingRight&quot;),10) || 0) - this.helperProportions.width - this.margins.left,
				co.top+(over ? Math.max(ce.scrollHeight,ce.offsetHeight) : ce.offsetHeight) - (parseInt($(ce).css(&quot;borderTopWidth&quot;),10) || 0) - (parseInt($(ce).css(&quot;paddingBottom&quot;),10) || 0) - this.helperProportions.height - this.margins.top
			];
		}

	},

	_convertPositionTo: function(d, pos) {

		if(!pos) pos = this.position;
		var mod = d == &quot;absolute&quot; ? 1 : -1;
		var o = this.options, scroll = this.cssPosition == &#39;absolute&#39; &amp;&amp; !(this.scrollParent[0] != document &amp;&amp; $.ui.contains(this.scrollParent[0], this.offsetParent[0])) ? this.offsetParent : this.scrollParent, scrollIsRootNode = (/(html|body)/i).test(scroll[0].tagName);

		return {
			top: (
				pos.top																	// The absolute mouse position
				+ this.offset.relative.top * mod										// Only for relative positioned nodes: Relative offset from element to offset parent
				+ this.offset.parent.top * mod											// The offsetParent&#39;s offset without borders (offset + border)
				- ($.browser.safari &amp;&amp; this.cssPosition == &#39;fixed&#39; ? 0 : ( this.cssPosition == &#39;fixed&#39; ? -this.scrollParent.scrollTop() : ( scrollIsRootNode ? 0 : scroll.scrollTop() ) ) * mod)
			),
			left: (
				pos.left																// The absolute mouse position
				+ this.offset.relative.left * mod										// Only for relative positioned nodes: Relative offset from element to offset parent
				+ this.offset.parent.left * mod											// The offsetParent&#39;s offset without borders (offset + border)
				- ($.browser.safari &amp;&amp; this.cssPosition == &#39;fixed&#39; ? 0 : ( this.cssPosition == &#39;fixed&#39; ? -this.scrollParent.scrollLeft() : scrollIsRootNode ? 0 : scroll.scrollLeft() ) * mod)
			)
		};

	},

	_generatePosition: function(event) {

		var o = this.options, scroll = this.cssPosition == &#39;absolute&#39; &amp;&amp; !(this.scrollParent[0] != document &amp;&amp; $.ui.contains(this.scrollParent[0], this.offsetParent[0])) ? this.offsetParent : this.scrollParent, scrollIsRootNode = (/(html|body)/i).test(scroll[0].tagName);

		// This is another very weird special case that only happens for relative elements:
		// 1. If the css position is relative
		// 2. and the scroll parent is the document or similar to the offset parent
		// we have to refresh the relative offset during the scroll so there are no jumps
		if(this.cssPosition == &#39;relative&#39; &amp;&amp; !(this.scrollParent[0] != document &amp;&amp; this.scrollParent[0] != this.offsetParent[0])) {
			this.offset.relative = this._getRelativeOffset();
		}

		var pageX = event.pageX;
		var pageY = event.pageY;

		/*
		 * - Position constraining -
		 * Constrain the position to a mix of grid, containment.
		 */

		if(this.originalPosition) { //If we are not dragging yet, we won&#39;t check for options

			if(this.containment) {
				if(event.pageX - this.offset.click.left </span><span class="xd">&lt; </span><span class="xn">this.containment[0]</span><span class="xd">) pageX = this.containment[0] + this.offset.click.left;
				if(event.pageY - this.offset.click.top </span><span class="xd">&lt; </span><span class="xn">this.containment[1]</span><span class="xd">) pageY = this.containment[1] + this.offset.click.top;
				if(event.pageX - this.offset.click.left &gt;</span> this.containment[2]) pageX = this.containment[2] + this.offset.click.left;
				if(event.pageY - this.offset.click.top &gt; this.containment[3]) pageY = this.containment[3] + this.offset.click.top;
			}

			if(o.grid) {
				var top = this.originalPageY + Math.round((pageY - this.originalPageY) / o.grid[1]) * o.grid[1];
				pageY = this.containment ? (!(top - this.offset.click.top <span class="xd">&lt; </span><span class="xn">this.containment[1] </span><span class="xan">|| </span><span class="xan">top </span><span class="xan">- </span><span class="xan">this.offset.click.top </span><span class="xd">&gt;</span> this.containment[3]) ? top : (!(top - this.offset.click.top <span class="xd">&lt; </span><span class="xn">this.containment[1]</span><span class="xd">) ? top - o.grid[1] : top + o.grid[1])) : top;

				var left = this.originalPageX + Math.round((pageX - this.originalPageX) / o.grid[0]) * o.grid[0];
				pageX = this.containment ? (!(left - this.offset.click.left </span><span class="xd">&lt; </span><span class="xn">this.containment[0] </span><span class="xan">|| </span><span class="xan">left </span><span class="xan">- </span><span class="xan">this.offset.click.left </span><span class="xd">&gt;</span> this.containment[2]) ? left : (!(left - this.offset.click.left <span class="xd">&lt; </span><span class="xn">this.containment[0]</span><span class="xd">) ? left - o.grid[0] : left + o.grid[0])) : left;
			}

		}

		return {
			top: (
				pageY																// The absolute mouse position
				- this.offset.click.top													// Click offset (relative to the element)
				- this.offset.relative.top												// Only for relative positioned nodes: Relative offset from element to offset parent
				- this.offset.parent.top												// The offsetParent&#39;s offset without borders (offset + border)
				+ ($.browser.safari &amp;&amp; this.cssPosition == &#39;fixed&#39; ? 0 : ( this.cssPosition == &#39;fixed&#39; ? -this.scrollParent.scrollTop() : ( scrollIsRootNode ? 0 : scroll.scrollTop() ) ))
			),
			left: (
				pageX																// The absolute mouse position
				- this.offset.click.left												// Click offset (relative to the element)
				- this.offset.relative.left												// Only for relative positioned nodes: Relative offset from element to offset parent
				- this.offset.parent.left												// The offsetParent&#39;s offset without borders (offset + border)
				+ ($.browser.safari &amp;&amp; this.cssPosition == &#39;fixed&#39; ? 0 : ( this.cssPosition == &#39;fixed&#39; ? -this.scrollParent.scrollLeft() : scrollIsRootNode ? 0 : scroll.scrollLeft() ))
			)
		};

	},

	_rearrange: function(event, i, a, hardRefresh) {

		a ? a[0].appendChild(this.placeholder[0]) : i.item[0].parentNode.insertBefore(this.placeholder[0], (this.direction == &#39;down&#39; ? i.item[0] : i.item[0].nextSibling));

		//Various things done here to improve the performance:
		// 1. we create a setTimeout, that calls refreshPositions
		// 2. on the instance, we have a counter variable, that get&#39;s higher after every append
		// 3. on the local scope, we copy the counter variable, and check in the timeout, if it&#39;s still the same
		// 4. this lets only the last addition to the timeout stack through
		this.counter = this.counter ? ++this.counter : 1;
		var self = this, counter = this.counter;

		window.setTimeout(function() {
			if(counter == self.counter) self.refreshPositions(!hardRefresh); //Precompute after each DOM insertion, NOT on mousemove
		},0);

	},

	_clear: function(event, noPropagation) {

		this.reverting = false;
		// We delay all events that have to be triggered to after the point where the placeholder has been removed and
		// everything else normalized again
		var delayedTriggers = [], self = this;

		// We first have to update the dom position of the actual currentItem
		// Note: don&#39;t do it if the current item is already removed (by a user), or it gets reappended (see #4088)
		if(!this._noFinalSort &amp;&amp; this.currentItem.parent().length) this.placeholder.before(this.currentItem);
		this._noFinalSort = null;

		if(this.helper[0] == this.currentItem[0]) {
			for(var i in this._storedCSS) {
				if(this._storedCSS[i] == &#39;auto&#39; || this._storedCSS[i] == &#39;static&#39;) this._storedCSS[i] = &#39;&#39;;
			}
			this.currentItem.css(this._storedCSS).removeClass(&quot;ui-sortable-helper&quot;);
		} else {
			this.currentItem.show();
		}

		if(this.fromOutside &amp;&amp; !noPropagation) delayedTriggers.push(function(event) { this._trigger(&quot;receive&quot;, event, this._uiHash(this.fromOutside)); });
		if((this.fromOutside || this.domPosition.prev != this.currentItem.prev().not(&quot;.ui-sortable-helper&quot;)[0] || this.domPosition.parent != this.currentItem.parent()[0]) &amp;&amp; !noPropagation) delayedTriggers.push(function(event) { this._trigger(&quot;update&quot;, event, this._uiHash()); }); //Trigger update callback if the DOM position has changed
		if(!$.ui.contains(this.element[0], this.currentItem[0])) { //Node was moved out of the current element
			if(!noPropagation) delayedTriggers.push(function(event) { this._trigger(&quot;remove&quot;, event, this._uiHash()); });
			for (var i = this.containers.length - 1; i &gt;</span>= 0; i--){
				if($.ui.contains(this.containers[i].element[0], this.currentItem[0]) <span class="xer">&amp;</span><span class="xer">&amp;</span> !noPropagation) {
					delayedTriggers.push((function(c) { return function(event) { c._trigger(&quot;receive&quot;, event, this._uiHash(this)); };  }).call(this, this.containers[i]));
					delayedTriggers.push((function(c) { return function(event) { c._trigger(&quot;update&quot;, event, this._uiHash(this));  }; }).call(this, this.containers[i]));
				}
			};
		};

		//Post events to containers
		for (var i = this.containers.length - 1; i &gt;= 0; i--){
			if(!noPropagation) delayedTriggers.push((function(c) { return function(event) { c._trigger(&quot;deactivate&quot;, event, this._uiHash(this)); };  }).call(this, this.containers[i]));
			if(this.containers[i].containerCache.over) {
				delayedTriggers.push((function(c) { return function(event) { c._trigger(&quot;out&quot;, event, this._uiHash(this)); };  }).call(this, this.containers[i]));
				this.containers[i].containerCache.over = 0;
			}
		}

		//Do what was originally in plugins
		if(this._storedCursor) $(&#39;body&#39;).css(&quot;cursor&quot;, this._storedCursor); //Reset cursor
		if(this._storedOpacity) this.helper.css(&quot;opacity&quot;, this._storedOpacity); //Reset opacity
		if(this._storedZIndex) this.helper.css(&quot;zIndex&quot;, this._storedZIndex == &#39;auto&#39; ? &#39;&#39; : this._storedZIndex); //Reset z-index

		this.dragging = false;
		if(this.cancelHelperRemoval) {
			if(!noPropagation) {
				this._trigger(&quot;beforeStop&quot;, event, this._uiHash());
				for (var i=0; i <span class="xd">&lt; </span><span class="xn">delayedTriggers.length</span><span class="xd">; i++) { delayedTriggers[i].call(this, event); }; //Trigger all delayed events
				this._trigger(&quot;stop&quot;, event, this._uiHash());
			}
			return false;
		}

		if(!noPropagation) this._trigger(&quot;beforeStop&quot;, event, this._uiHash());

		//$(this.placeholder[0]).remove(); would have been the jQuery way - unfortunately, it unbinds ALL events from the original node!
		this.placeholder[0].parentNode.removeChild(this.placeholder[0]);

		if(this.helper[0] != this.currentItem[0]) this.helper.remove(); this.helper = null;

		if(!noPropagation) {
			for (var i=0; i </span><span class="xd">&lt; </span><span class="xn">delayedTriggers.length</span><span class="xd">; i++) { delayedTriggers[i].call(this, event); }; //Trigger all delayed events
			this._trigger(&quot;stop&quot;, event, this._uiHash());
		}

		this.fromOutside = false;
		return true;

	},

	_trigger: function() {
		if ($.Widget.prototype._trigger.apply(this, arguments) === false) {
			this.cancel();
		}
	},

	_uiHash: function(inst) {
		var self = inst || this;
		return {
			helper: self.helper,
			placeholder: self.placeholder || $([]),
			position: self.position,
			originalPosition: self.originalPosition,
			offset: self.positionAbs,
			item: self.currentItem,
			sender: inst ? inst.element : null
		};
	}

});

$.extend($.ui.sortable, {
	version: &quot;1.8.18&quot;
});

})(jQuery);
/*
 * jQuery UI Accordion 1.8.18
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Accordion
 *
 * Depends:
 *	jquery.ui.core.js
 *	jquery.ui.widget.js
 */
(function( $, undefined ) {

$.widget( &quot;ui.accordion&quot;, {
	options: {
		active: 0,
		animated: &quot;slide&quot;,
		autoHeight: true,
		clearStyle: false,
		collapsible: false,
		event: &quot;click&quot;,
		fillSpace: false,
		header: &quot;&gt;</span> li &gt; :first-child,&gt; :not(li):even&quot;,
		icons: {
			header: &quot;ui-icon-triangle-1-e&quot;,
			headerSelected: &quot;ui-icon-triangle-1-s&quot;
		},
		navigation: false,
		navigationFilter: function() {
			return this.href.toLowerCase() === location.href.toLowerCase();
		}
	},

	_create: function() {
		var self = this,
			options = self.options;

		self.running = 0;

		self.element
			.addClass( &quot;ui-accordion ui-widget ui-helper-reset&quot; )
			// in lack of child-selectors in CSS
			// we need to mark top-LIs in a UL-accordion for some IE-fix
			.children( &quot;li&quot; )
				.addClass( &quot;ui-accordion-li-fix&quot; );

		self.headers = self.element.find( options.header )
			.addClass( &quot;ui-accordion-header ui-helper-reset ui-state-default ui-corner-all&quot; )
			.bind( &quot;mouseenter.accordion&quot;, function() {
				if ( options.disabled ) {
					return;
				}
				$( this ).addClass( &quot;ui-state-hover&quot; );
			})
			.bind( &quot;mouseleave.accordion&quot;, function() {
				if ( options.disabled ) {
					return;
				}
				$( this ).removeClass( &quot;ui-state-hover&quot; );
			})
			.bind( &quot;focus.accordion&quot;, function() {
				if ( options.disabled ) {
					return;
				}
				$( this ).addClass( &quot;ui-state-focus&quot; );
			})
			.bind( &quot;blur.accordion&quot;, function() {
				if ( options.disabled ) {
					return;
				}
				$( this ).removeClass( &quot;ui-state-focus&quot; );
			});

		self.headers.next()
			.addClass( &quot;ui-accordion-content ui-helper-reset ui-widget-content ui-corner-bottom&quot; );

		if ( options.navigation ) {
			var current = self.element.find( &quot;a&quot; ).filter( options.navigationFilter ).eq( 0 );
			if ( current.length ) {
				var header = current.closest( &quot;.ui-accordion-header&quot; );
				if ( header.length ) {
					// anchor within header
					self.active = header;
				} else {
					// anchor within content
					self.active = current.closest( &quot;.ui-accordion-content&quot; ).prev();
				}
			}
		}

		self.active = self._findActive( self.active || options.active )
			.addClass( &quot;ui-state-default ui-state-active&quot; )
			.toggleClass( &quot;ui-corner-all&quot; )
			.toggleClass( &quot;ui-corner-top&quot; );
		self.active.next().addClass( &quot;ui-accordion-content-active&quot; );

		self._createIcons();
		self.resize();
		
		// ARIA
		self.element.attr( &quot;role&quot;, &quot;tablist&quot; );

		self.headers
			.attr( &quot;role&quot;, &quot;tab&quot; )
			.bind( &quot;keydown.accordion&quot;, function( event ) {
				return self._keydown( event );
			})
			.next()
				.attr( &quot;role&quot;, &quot;tabpanel&quot; );

		self.headers
			.not( self.active || &quot;&quot; )
			.attr({
				&quot;aria-expanded&quot;: &quot;false&quot;,
				&quot;aria-selected&quot;: &quot;false&quot;,
				tabIndex: -1
			})
			.next()
				.hide();

		// make sure at least one header is in the tab order
		if ( !self.active.length ) {
			self.headers.eq( 0 ).attr( &quot;tabIndex&quot;, 0 );
		} else {
			self.active
				.attr({
					&quot;aria-expanded&quot;: &quot;true&quot;,
					&quot;aria-selected&quot;: &quot;true&quot;,
					tabIndex: 0
				});
		}

		// only need links in tab order for Safari
		if ( !$.browser.safari ) {
			self.headers.find( &quot;a&quot; ).attr( &quot;tabIndex&quot;, -1 );
		}

		if ( options.event ) {
			self.headers.bind( options.event.split(&quot; &quot;).join(&quot;.accordion &quot;) + &quot;.accordion&quot;, function(event) {
				self._clickHandler.call( self, event, this );
				event.preventDefault();
			});
		}
	},

	_createIcons: function() {
		var options = this.options;
		if ( options.icons ) {
			$( &quot;<span class="xd">&lt;</span><span class="xn">span</span><span class="xd">&gt;</span><span class="xd">&lt;/</span><span class="xn">span</span><span class="xd">&gt;</span>&quot; )
				.addClass( &quot;ui-icon &quot; + options.icons.header )
				.prependTo( this.headers );
			this.active.children( &quot;.ui-icon&quot; )
				.toggleClass(options.icons.header)
				.toggleClass(options.icons.headerSelected);
			this.element.addClass( &quot;ui-accordion-icons&quot; );
		}
	},

	_destroyIcons: function() {
		this.headers.children( &quot;.ui-icon&quot; ).remove();
		this.element.removeClass( &quot;ui-accordion-icons&quot; );
	},

	destroy: function() {
		var options = this.options;

		this.element
			.removeClass( &quot;ui-accordion ui-widget ui-helper-reset&quot; )
			.removeAttr( &quot;role&quot; );

		this.headers
			.unbind( &quot;.accordion&quot; )
			.removeClass( &quot;ui-accordion-header ui-accordion-disabled ui-helper-reset ui-state-default ui-corner-all ui-state-active ui-state-disabled ui-corner-top&quot; )
			.removeAttr( &quot;role&quot; )
			.removeAttr( &quot;aria-expanded&quot; )
			.removeAttr( &quot;aria-selected&quot; )
			.removeAttr( &quot;tabIndex&quot; );

		this.headers.find( &quot;a&quot; ).removeAttr( &quot;tabIndex&quot; );
		this._destroyIcons();
		var contents = this.headers.next()
			.css( &quot;display&quot;, &quot;&quot; )
			.removeAttr( &quot;role&quot; )
			.removeClass( &quot;ui-helper-reset ui-widget-content ui-corner-bottom ui-accordion-content ui-accordion-content-active ui-accordion-disabled ui-state-disabled&quot; );
		if ( options.autoHeight || options.fillHeight ) {
			contents.css( &quot;height&quot;, &quot;&quot; );
		}

		return $.Widget.prototype.destroy.call( this );
	},

	_setOption: function( key, value ) {
		$.Widget.prototype._setOption.apply( this, arguments );
			
		if ( key == &quot;active&quot; ) {
			this.activate( value );
		}
		if ( key == &quot;icons&quot; ) {
			this._destroyIcons();
			if ( value ) {
				this._createIcons();
			}
		}
		// #5332 - opacity doesn&#39;t cascade to positioned elements in IE
		// so we need to add the disabled class to the headers and panels
		if ( key == &quot;disabled&quot; ) {
			this.headers.add(this.headers.next())
				[ value ? &quot;addClass&quot; : &quot;removeClass&quot; ](
					&quot;ui-accordion-disabled ui-state-disabled&quot; );
		}
	},

	_keydown: function( event ) {
		if ( this.options.disabled || event.altKey || event.ctrlKey ) {
			return;
		}

		var keyCode = $.ui.keyCode,
			length = this.headers.length,
			currentIndex = this.headers.index( event.target ),
			toFocus = false;

		switch ( event.keyCode ) {
			case keyCode.RIGHT:
			case keyCode.DOWN:
				toFocus = this.headers[ ( currentIndex + 1 ) % length ];
				break;
			case keyCode.LEFT:
			case keyCode.UP:
				toFocus = this.headers[ ( currentIndex - 1 + length ) % length ];
				break;
			case keyCode.SPACE:
			case keyCode.ENTER:
				this._clickHandler( { target: event.target }, event.target );
				event.preventDefault();
		}

		if ( toFocus ) {
			$( event.target ).attr( &quot;tabIndex&quot;, -1 );
			$( toFocus ).attr( &quot;tabIndex&quot;, 0 );
			toFocus.focus();
			return false;
		}

		return true;
	},

	resize: function() {
		var options = this.options,
			maxHeight;

		if ( options.fillSpace ) {
			if ( $.browser.msie ) {
				var defOverflow = this.element.parent().css( &quot;overflow&quot; );
				this.element.parent().css( &quot;overflow&quot;, &quot;hidden&quot;);
			}
			maxHeight = this.element.parent().height();
			if ($.browser.msie) {
				this.element.parent().css( &quot;overflow&quot;, defOverflow );
			}

			this.headers.each(function() {
				maxHeight -= $( this ).outerHeight( true );
			});

			this.headers.next()
				.each(function() {
					$( this ).height( Math.max( 0, maxHeight -
						$( this ).innerHeight() + $( this ).height() ) );
				})
				.css( &quot;overflow&quot;, &quot;auto&quot; );
		} else if ( options.autoHeight ) {
			maxHeight = 0;
			this.headers.next()
				.each(function() {
					maxHeight = Math.max( maxHeight, $( this ).height( &quot;&quot; ).height() );
				})
				.height( maxHeight );
		}

		return this;
	},

	activate: function( index ) {
		// TODO this gets called on init, changing the option without an explicit call for that
		this.options.active = index;
		// call clickHandler with custom event
		var active = this._findActive( index )[ 0 ];
		this._clickHandler( { target: active }, active );

		return this;
	},

	_findActive: function( selector ) {
		return selector
			? typeof selector === &quot;number&quot;
				? this.headers.filter( &quot;:eq(&quot; + selector + &quot;)&quot; )
				: this.headers.not( this.headers.not( selector ) )
			: selector === false
				? $( [] )
				: this.headers.filter( &quot;:eq(0)&quot; );
	},

	// TODO isn&#39;t event.target enough? why the separate target argument?
	_clickHandler: function( event, target ) {
		var options = this.options;
		if ( options.disabled ) {
			return;
		}

		// called only when using activate(false) to close all parts programmatically
		if ( !event.target ) {
			if ( !options.collapsible ) {
				return;
			}
			this.active
				.removeClass( &quot;ui-state-active ui-corner-top&quot; )
				.addClass( &quot;ui-state-default ui-corner-all&quot; )
				.children( &quot;.ui-icon&quot; )
					.removeClass( options.icons.headerSelected )
					.addClass( options.icons.header );
			this.active.next().addClass( &quot;ui-accordion-content-active&quot; );
			var toHide = this.active.next(),
				data = {
					options: options,
					newHeader: $( [] ),
					oldHeader: options.active,
					newContent: $( [] ),
					oldContent: toHide
				},
				toShow = ( this.active = $( [] ) );
			this._toggle( toShow, toHide, data );
			return;
		}

		// get the click target
		var clicked = $( event.currentTarget || target ),
			clickedIsActive = clicked[0] === this.active[0];

		// TODO the option is changed, is that correct?
		// TODO if it is correct, shouldn&#39;t that happen after determining that the click is valid?
		options.active = options.collapsible <span class="xer">&amp;</span><span class="xer">&amp;</span> clickedIsActive ?
			false :
			this.headers.index( clicked );

		// if animations are still active, or the active header is the target, ignore click
		if ( this.running || ( !options.collapsible <span class="xer">&amp;</span><span class="xer">&amp;</span> clickedIsActive ) ) {
			return;
		}

		// find elements to show and hide
		var active = this.active,
			toShow = clicked.next(),
			toHide = this.active.next(),
			data = {
				options: options,
				newHeader: clickedIsActive <span class="xer">&amp;</span><span class="xer">&amp;</span> options.collapsible ? $([]) : clicked,
				oldHeader: this.active,
				newContent: clickedIsActive <span class="xer">&amp;</span><span class="xer">&amp;</span> options.collapsible ? $([]) : toShow,
				oldContent: toHide
			},
			down = this.headers.index( this.active[0] ) &gt; this.headers.index( clicked[0] );

		// when the call to ._toggle() comes after the class changes
		// it causes a very odd bug in IE 8 (see #6720)
		this.active = clickedIsActive ? $([]) : clicked;
		this._toggle( toShow, toHide, data, clickedIsActive, down );

		// switch classes
		active
			.removeClass( &quot;ui-state-active ui-corner-top&quot; )
			.addClass( &quot;ui-state-default ui-corner-all&quot; )
			.children( &quot;.ui-icon&quot; )
				.removeClass( options.icons.headerSelected )
				.addClass( options.icons.header );
		if ( !clickedIsActive ) {
			clicked
				.removeClass( &quot;ui-state-default ui-corner-all&quot; )
				.addClass( &quot;ui-state-active ui-corner-top&quot; )
				.children( &quot;.ui-icon&quot; )
					.removeClass( options.icons.header )
					.addClass( options.icons.headerSelected );
			clicked
				.next()
				.addClass( &quot;ui-accordion-content-active&quot; );
		}

		return;
	},

	_toggle: function( toShow, toHide, data, clickedIsActive, down ) {
		var self = this,
			options = self.options;

		self.toShow = toShow;
		self.toHide = toHide;
		self.data = data;

		var complete = function() {
			if ( !self ) {
				return;
			}
			return self._completed.apply( self, arguments );
		};

		// trigger changestart event
		self._trigger( &quot;changestart&quot;, null, self.data );

		// count elements to animate
		self.running = toHide.size() === 0 ? toShow.size() : toHide.size();

		if ( options.animated ) {
			var animOptions = {};

			if ( options.collapsible <span class="xer">&amp;</span><span class="xer">&amp;</span> clickedIsActive ) {
				animOptions = {
					toShow: $( [] ),
					toHide: toHide,
					complete: complete,
					down: down,
					autoHeight: options.autoHeight || options.fillSpace
				};
			} else {
				animOptions = {
					toShow: toShow,
					toHide: toHide,
					complete: complete,
					down: down,
					autoHeight: options.autoHeight || options.fillSpace
				};
			}

			if ( !options.proxied ) {
				options.proxied = options.animated;
			}

			if ( !options.proxiedDuration ) {
				options.proxiedDuration = options.duration;
			}

			options.animated = $.isFunction( options.proxied ) ?
				options.proxied( animOptions ) :
				options.proxied;

			options.duration = $.isFunction( options.proxiedDuration ) ?
				options.proxiedDuration( animOptions ) :
				options.proxiedDuration;

			var animations = $.ui.accordion.animations,
				duration = options.duration,
				easing = options.animated;

			if ( easing <span class="xer">&amp;</span><span class="xer">&amp;</span> !animations[ easing ] <span class="xer">&amp;</span><span class="xer">&amp;</span> !$.easing[ easing ] ) {
				easing = &quot;slide&quot;;
			}
			if ( !animations[ easing ] ) {
				animations[ easing ] = function( options ) {
					this.slide( options, {
						easing: easing,
						duration: duration || 700
					});
				};
			}

			animations[ easing ]( animOptions );
		} else {
			if ( options.collapsible <span class="xer">&amp;</span><span class="xer">&amp;</span> clickedIsActive ) {
				toShow.toggle();
			} else {
				toHide.hide();
				toShow.show();
			}

			complete( true );
		}

		// TODO assert that the blur and focus triggers are really necessary, remove otherwise
		toHide.prev()
			.attr({
				&quot;aria-expanded&quot;: &quot;false&quot;,
				&quot;aria-selected&quot;: &quot;false&quot;,
				tabIndex: -1
			})
			.blur();
		toShow.prev()
			.attr({
				&quot;aria-expanded&quot;: &quot;true&quot;,
				&quot;aria-selected&quot;: &quot;true&quot;,
				tabIndex: 0
			})
			.focus();
	},

	_completed: function( cancel ) {
		this.running = cancel ? 0 : --this.running;
		if ( this.running ) {
			return;
		}

		if ( this.options.clearStyle ) {
			this.toShow.add( this.toHide ).css({
				height: &quot;&quot;,
				overflow: &quot;&quot;
			});
		}

		// other classes are removed before the animation; this one needs to stay until completed
		this.toHide.removeClass( &quot;ui-accordion-content-active&quot; );
		// Work around for rendering bug in IE (#5421)
		if ( this.toHide.length ) {
			this.toHide.parent()[0].className = this.toHide.parent()[0].className;
		}

		this._trigger( &quot;change&quot;, null, this.data );
	}
});

$.extend( $.ui.accordion, {
	version: &quot;1.8.18&quot;,
	animations: {
		slide: function( options, additions ) {
			options = $.extend({
				easing: &quot;swing&quot;,
				duration: 300
			}, options, additions );
			if ( !options.toHide.size() ) {
				options.toShow.animate({
					height: &quot;show&quot;,
					paddingTop: &quot;show&quot;,
					paddingBottom: &quot;show&quot;
				}, options );
				return;
			}
			if ( !options.toShow.size() ) {
				options.toHide.animate({
					height: &quot;hide&quot;,
					paddingTop: &quot;hide&quot;,
					paddingBottom: &quot;hide&quot;
				}, options );
				return;
			}
			var overflow = options.toShow.css( &quot;overflow&quot; ),
				percentDone = 0,
				showProps = {},
				hideProps = {},
				fxAttrs = [ &quot;height&quot;, &quot;paddingTop&quot;, &quot;paddingBottom&quot; ],
				originalWidth;
			// fix width before calculating height of hidden element
			var s = options.toShow;
			originalWidth = s[0].style.width;
			s.width( s.parent().width()
				- parseFloat( s.css( &quot;paddingLeft&quot; ) )
				- parseFloat( s.css( &quot;paddingRight&quot; ) )
				- ( parseFloat( s.css( &quot;borderLeftWidth&quot; ) ) || 0 )
				- ( parseFloat( s.css( &quot;borderRightWidth&quot; ) ) || 0 ) );

			$.each( fxAttrs, function( i, prop ) {
				hideProps[ prop ] = &quot;hide&quot;;

				var parts = ( &quot;&quot; + $.css( options.toShow[0], prop ) ).match( /^([\d+-.]+)(.*)$/ );
				showProps[ prop ] = {
					value: parts[ 1 ],
					unit: parts[ 2 ] || &quot;px&quot;
				};
			});
			options.toShow.css({ height: 0, overflow: &quot;hidden&quot; }).show();
			options.toHide
				.filter( &quot;:hidden&quot; )
					.each( options.complete )
				.end()
				.filter( &quot;:visible&quot; )
				.animate( hideProps, {
				step: function( now, settings ) {
					// only calculate the percent when animating height
					// IE gets very inconsistent results when animating elements
					// with small values, which is common for padding
					if ( settings.prop == &quot;height&quot; ) {
						percentDone = ( settings.end - settings.start === 0 ) ? 0 :
							( settings.now - settings.start ) / ( settings.end - settings.start );
					}

					options.toShow[ 0 ].style[ settings.prop ] =
						( percentDone * showProps[ settings.prop ].value )
						+ showProps[ settings.prop ].unit;
				},
				duration: options.duration,
				easing: options.easing,
				complete: function() {
					if ( !options.autoHeight ) {
						options.toShow.css( &quot;height&quot;, &quot;&quot; );
					}
					options.toShow.css({
						width: originalWidth,
						overflow: overflow
					});
					options.complete();
				}
			});
		},
		bounceslide: function( options ) {
			this.slide( options, {
				easing: options.down ? &quot;easeOutBounce&quot; : &quot;swing&quot;,
				duration: options.down ? 1000 : 200
			});
		}
	}
});

})( jQuery );
/*
 * jQuery UI Autocomplete 1.8.18
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Autocomplete
 *
 * Depends:
 *	jquery.ui.core.js
 *	jquery.ui.widget.js
 *	jquery.ui.position.js
 */
(function( $, undefined ) {

// used to prevent race conditions with remote data sources
var requestIndex = 0;

$.widget( &quot;ui.autocomplete&quot;, {
	options: {
		appendTo: &quot;body&quot;,
		autoFocus: false,
		delay: 300,
		minLength: 1,
		position: {
			my: &quot;left top&quot;,
			at: &quot;left bottom&quot;,
			collision: &quot;none&quot;
		},
		source: null
	},

	pending: 0,

	_create: function() {
		var self = this,
			doc = this.element[ 0 ].ownerDocument,
			suppressKeyPress;

		this.element
			.addClass( &quot;ui-autocomplete-input&quot; )
			.attr( &quot;autocomplete&quot;, &quot;off&quot; )
			// TODO verify these actually work as intended
			.attr({
				role: &quot;textbox&quot;,
				&quot;aria-autocomplete&quot;: &quot;list&quot;,
				&quot;aria-haspopup&quot;: &quot;true&quot;
			})
			.bind( &quot;keydown.autocomplete&quot;, function( event ) {
				if ( self.options.disabled || self.element.propAttr( &quot;readOnly&quot; ) ) {
					return;
				}

				suppressKeyPress = false;
				var keyCode = $.ui.keyCode;
				switch( event.keyCode ) {
				case keyCode.PAGE_UP:
					self._move( &quot;previousPage&quot;, event );
					break;
				case keyCode.PAGE_DOWN:
					self._move( &quot;nextPage&quot;, event );
					break;
				case keyCode.UP:
					self._move( &quot;previous&quot;, event );
					// prevent moving cursor to beginning of text field in some browsers
					event.preventDefault();
					break;
				case keyCode.DOWN:
					self._move( &quot;next&quot;, event );
					// prevent moving cursor to end of text field in some browsers
					event.preventDefault();
					break;
				case keyCode.ENTER:
				case keyCode.NUMPAD_ENTER:
					// when menu is open and has focus
					if ( self.menu.active ) {
						// #6055 - Opera still allows the keypress to occur
						// which causes forms to submit
						suppressKeyPress = true;
						event.preventDefault();
					}
					//passthrough - ENTER and TAB both select the current element
				case keyCode.TAB:
					if ( !self.menu.active ) {
						return;
					}
					self.menu.select( event );
					break;
				case keyCode.ESCAPE:
					self.element.val( self.term );
					self.close( event );
					break;
				default:
					// keypress is triggered before the input value is changed
					clearTimeout( self.searching );
					self.searching = setTimeout(function() {
						// only search if the value has changed
						if ( self.term != self.element.val() ) {
							self.selectedItem = null;
							self.search( null, event );
						}
					}, self.options.delay );
					break;
				}
			})
			.bind( &quot;keypress.autocomplete&quot;, function( event ) {
				if ( suppressKeyPress ) {
					suppressKeyPress = false;
					event.preventDefault();
				}
			})
			.bind( &quot;focus.autocomplete&quot;, function() {
				if ( self.options.disabled ) {
					return;
				}

				self.selectedItem = null;
				self.previous = self.element.val();
			})
			.bind( &quot;blur.autocomplete&quot;, function( event ) {
				if ( self.options.disabled ) {
					return;
				}

				clearTimeout( self.searching );
				// clicks on the menu (or a button to trigger a search) will cause a blur event
				self.closing = setTimeout(function() {
					self.close( event );
					self._change( event );
				}, 150 );
			});
		this._initSource();
		this.response = function() {
			return self._response.apply( self, arguments );
		};
		this.menu = $( &quot;<span class="xd">&lt;</span><span class="xn">ul</span><span class="xd">&gt;</span><span class="xd">&lt;/</span><span class="xn">ul</span><span class="xd">&gt;</span>&quot; )
			.addClass( &quot;ui-autocomplete&quot; )
			.appendTo( $( this.options.appendTo || &quot;body&quot;, doc )[0] )
			// prevent the close-on-blur in case of a &quot;slow&quot; click on the menu (long mousedown)
			.mousedown(function( event ) {
				// clicking on the scrollbar causes focus to shift to the body
				// but we can&#39;t detect a mouseup or a click immediately afterward
				// so we have to track the next mousedown and close the menu if
				// the user clicks somewhere outside of the autocomplete
				var menuElement = self.menu.element[ 0 ];
				if ( !$( event.target ).closest( &quot;.ui-menu-item&quot; ).length ) {
					setTimeout(function() {
						$( document ).one( &#39;mousedown&#39;, function( event ) {
							if ( event.target !== self.element[ 0 ] <span class="xer">&amp;</span><span class="xer">&amp;</span>
								event.target !== menuElement <span class="xer">&amp;</span><span class="xer">&amp;</span>
								!$.ui.contains( menuElement, event.target ) ) {
								self.close();
							}
						});
					}, 1 );
				}

				// use another timeout to make sure the blur-event-handler on the input was already triggered
				setTimeout(function() {
					clearTimeout( self.closing );
				}, 13);
			})
			.menu({
				focus: function( event, ui ) {
					var item = ui.item.data( &quot;item.autocomplete&quot; );
					if ( false !== self._trigger( &quot;focus&quot;, event, { item: item } ) ) {
						// use value to match what will end up in the input, if it was a key event
						if ( /^key/.test(event.originalEvent.type) ) {
							self.element.val( item.value );
						}
					}
				},
				selected: function( event, ui ) {
					var item = ui.item.data( &quot;item.autocomplete&quot; ),
						previous = self.previous;

					// only trigger when focus was lost (click on menu)
					if ( self.element[0] !== doc.activeElement ) {
						self.element.focus();
						self.previous = previous;
						// #6109 - IE triggers two focus events and the second
						// is asynchronous, so we need to reset the previous
						// term synchronously and asynchronously :-(
						setTimeout(function() {
							self.previous = previous;
							self.selectedItem = item;
						}, 1);
					}

					if ( false !== self._trigger( &quot;select&quot;, event, { item: item } ) ) {
						self.element.val( item.value );
					}
					// reset the term after the select event
					// this allows custom select handling to work properly
					self.term = self.element.val();

					self.close( event );
					self.selectedItem = item;
				},
				blur: function( event, ui ) {
					// don&#39;t set the value of the text field if it&#39;s already correct
					// this prevents moving the cursor unnecessarily
					if ( self.menu.element.is(&quot;:visible&quot;) <span class="xer">&amp;</span><span class="xer">&amp;</span>
						( self.element.val() !== self.term ) ) {
						self.element.val( self.term );
					}
				}
			})
			.zIndex( this.element.zIndex() + 1 )
			// workaround for jQuery bug #5781 http://dev.jquery.com/ticket/5781
			.css({ top: 0, left: 0 })
			.hide()
			.data( &quot;menu&quot; );
		if ( $.fn.bgiframe ) {
			 this.menu.element.bgiframe();
		}
		// turning off autocomplete prevents the browser from remembering the
		// value when navigating through history, so we re-enable autocomplete
		// if the page is unloaded before the widget is destroyed. #7790
		self.beforeunloadHandler = function() {
			self.element.removeAttr( &quot;autocomplete&quot; );
		};
		$( window ).bind( &quot;beforeunload&quot;, self.beforeunloadHandler );
	},

	destroy: function() {
		this.element
			.removeClass( &quot;ui-autocomplete-input&quot; )
			.removeAttr( &quot;autocomplete&quot; )
			.removeAttr( &quot;role&quot; )
			.removeAttr( &quot;aria-autocomplete&quot; )
			.removeAttr( &quot;aria-haspopup&quot; );
		this.menu.element.remove();
		$( window ).unbind( &quot;beforeunload&quot;, this.beforeunloadHandler );
		$.Widget.prototype.destroy.call( this );
	},

	_setOption: function( key, value ) {
		$.Widget.prototype._setOption.apply( this, arguments );
		if ( key === &quot;source&quot; ) {
			this._initSource();
		}
		if ( key === &quot;appendTo&quot; ) {
			this.menu.element.appendTo( $( value || &quot;body&quot;, this.element[0].ownerDocument )[0] )
		}
		if ( key === &quot;disabled&quot; <span class="xer">&amp;</span><span class="xer">&amp;</span> value <span class="xer">&amp;</span><span class="xer">&amp;</span> this.xhr ) {
			this.xhr.abort();
		}
	},

	_initSource: function() {
		var self = this,
			array,
			url;
		if ( $.isArray(this.options.source) ) {
			array = this.options.source;
			this.source = function( request, response ) {
				response( $.ui.autocomplete.filter(array, request.term) );
			};
		} else if ( typeof this.options.source === &quot;string&quot; ) {
			url = this.options.source;
			this.source = function( request, response ) {
				if ( self.xhr ) {
					self.xhr.abort();
				}
				self.xhr = $.ajax({
					url: url,
					data: request,
					dataType: &quot;json&quot;,
					context: {
						autocompleteRequest: ++requestIndex
					},
					success: function( data, status ) {
						if ( this.autocompleteRequest === requestIndex ) {
							response( data );
						}
					},
					error: function() {
						if ( this.autocompleteRequest === requestIndex ) {
							response( [] );
						}
					}
				});
			};
		} else {
			this.source = this.options.source;
		}
	},

	search: function( value, event ) {
		value = value != null ? value : this.element.val();

		// always save the actual value, not the one passed as an argument
		this.term = this.element.val();

		if ( value.length <span class="xd">&lt; </span><span class="xn">this.options.minLength </span><span class="xd">) {
			return this.close( event );
		}

		clearTimeout( this.closing );
		if ( this._trigger( &quot;search&quot;, event ) === false ) {
			return;
		}

		return this._search( value );
	},

	_search: function( value ) {
		this.pending++;
		this.element.addClass( &quot;ui-autocomplete-loading&quot; );

		this.source( { term: value }, this.response );
	},

	_response: function( content ) {
		if ( !this.options.disabled &amp;&amp; content &amp;&amp; content.length ) {
			content = this._normalize( content );
			this._suggest( content );
			this._trigger( &quot;open&quot; );
		} else {
			this.close();
		}
		this.pending--;
		if ( !this.pending ) {
			this.element.removeClass( &quot;ui-autocomplete-loading&quot; );
		}
	},

	close: function( event ) {
		clearTimeout( this.closing );
		if ( this.menu.element.is(&quot;:visible&quot;) ) {
			this.menu.element.hide();
			this.menu.deactivate();
			this._trigger( &quot;close&quot;, event );
		}
	},
	
	_change: function( event ) {
		if ( this.previous !== this.element.val() ) {
			this._trigger( &quot;change&quot;, event, { item: this.selectedItem } );
		}
	},

	_normalize: function( items ) {
		// assume all items have the right format when the first item is complete
		if ( items.length &amp;&amp; items[0].label &amp;&amp; items[0].value ) {
			return items;
		}
		return $.map( items, function(item) {
			if ( typeof item === &quot;string&quot; ) {
				return {
					label: item,
					value: item
				};
			}
			return $.extend({
				label: item.label || item.value,
				value: item.value || item.label
			}, item );
		});
	},

	_suggest: function( items ) {
		var ul = this.menu.element
			.empty()
			.zIndex( this.element.zIndex() + 1 );
		this._renderMenu( ul, items );
		// TODO refresh should check if the active item is still in the dom, removing the need for a manual deactivate
		this.menu.deactivate();
		this.menu.refresh();

		// size and position menu
		ul.show();
		this._resizeMenu();
		ul.position( $.extend({
			of: this.element
		}, this.options.position ));

		if ( this.options.autoFocus ) {
			this.menu.next( new $.Event(&quot;mouseover&quot;) );
		}
	},

	_resizeMenu: function() {
		var ul = this.menu.element;
		ul.outerWidth( Math.max(
			// Firefox wraps long text (possibly a rounding bug)
			// so we add 1px to avoid the wrapping (#7513)
			ul.width( &quot;&quot; ).outerWidth() + 1,
			this.element.outerWidth()
		) );
	},

	_renderMenu: function( ul, items ) {
		var self = this;
		$.each( items, function( index, item ) {
			self._renderItem( ul, item );
		});
	},

	_renderItem: function( ul, item) {
		return $( &quot;</span><span class="xd">&lt;</span><span class="xn">li</span><span class="xd">&gt;</span><span class="xd">&lt;/</span><span class="xn">li</span><span class="xd">&gt;</span>&quot; )
			.data( &quot;item.autocomplete&quot;, item )
			.append( $( &quot;<span class="xd">&lt;</span><span class="xn">a</span><span class="xd">&gt;</span><span class="xd">&lt;/</span><span class="xn">a</span><span class="xd">&gt;</span>&quot; ).text( item.label ) )
			.appendTo( ul );
	},

	_move: function( direction, event ) {
		if ( !this.menu.element.is(&quot;:visible&quot;) ) {
			this.search( null, event );
			return;
		}
		if ( this.menu.first() <span class="xer">&amp;</span><span class="xer">&amp;</span> /^previous/.test(direction) ||
				this.menu.last() <span class="xer">&amp;</span><span class="xer">&amp;</span> /^next/.test(direction) ) {
			this.element.val( this.term );
			this.menu.deactivate();
			return;
		}
		this.menu[ direction ]( event );
	},

	widget: function() {
		return this.menu.element;
	}
});

$.extend( $.ui.autocomplete, {
	escapeRegex: function( value ) {
		return value.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, &quot;\\$<span class="xer">&amp;</span>&quot;);
	},
	filter: function(array, term) {
		var matcher = new RegExp( $.ui.autocomplete.escapeRegex(term), &quot;i&quot; );
		return $.grep( array, function(value) {
			return matcher.test( value.label || value.value || value );
		});
	}
});

}( jQuery ));

/*
 * jQuery UI Menu (not officially released)
 * 
 * This widget isn&#39;t yet finished and the API is subject to change. We plan to finish
 * it for the next release. You&#39;re welcome to give it a try anyway and give us feedback,
 * as long as you&#39;re okay with migrating your code later on. We can help with that, too.
 *
 * Copyright 2010, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Menu
 *
 * Depends:
 *	jquery.ui.core.js
 *  jquery.ui.widget.js
 */
(function($) {

$.widget(&quot;ui.menu&quot;, {
	_create: function() {
		var self = this;
		this.element
			.addClass(&quot;ui-menu ui-widget ui-widget-content ui-corner-all&quot;)
			.attr({
				role: &quot;listbox&quot;,
				&quot;aria-activedescendant&quot;: &quot;ui-active-menuitem&quot;
			})
			.click(function( event ) {
				if ( !$( event.target ).closest( &quot;.ui-menu-item a&quot; ).length ) {
					return;
				}
				// temporary
				event.preventDefault();
				self.select( event );
			});
		this.refresh();
	},
	
	refresh: function() {
		var self = this;

		// don&#39;t refresh list items that are already adapted
		var items = this.element.children(&quot;li:not(.ui-menu-item):has(a)&quot;)
			.addClass(&quot;ui-menu-item&quot;)
			.attr(&quot;role&quot;, &quot;menuitem&quot;);
		
		items.children(&quot;a&quot;)
			.addClass(&quot;ui-corner-all&quot;)
			.attr(&quot;tabindex&quot;, -1)
			// mouseenter doesn&#39;t work with event delegation
			.mouseenter(function( event ) {
				self.activate( event, $(this).parent() );
			})
			.mouseleave(function() {
				self.deactivate();
			});
	},

	activate: function( event, item ) {
		this.deactivate();
		if (this.hasScroll()) {
			var offset = item.offset().top - this.element.offset().top,
				scroll = this.element.scrollTop(),
				elementHeight = this.element.height();
			if (offset <span class="xd">&lt; </span><span class="xn">0</span><span class="xd">) {
				this.element.scrollTop( scroll + offset);
			} else if (offset &gt;</span>= elementHeight) {
				this.element.scrollTop( scroll + offset - elementHeight + item.height());
			}
		}
		this.active = item.eq(0)
			.children(&quot;a&quot;)
				.addClass(&quot;ui-state-hover&quot;)
				.attr(&quot;id&quot;, &quot;ui-active-menuitem&quot;)
			.end();
		this._trigger(&quot;focus&quot;, event, { item: item });
	},

	deactivate: function() {
		if (!this.active) { return; }

		this.active.children(&quot;a&quot;)
			.removeClass(&quot;ui-state-hover&quot;)
			.removeAttr(&quot;id&quot;);
		this._trigger(&quot;blur&quot;);
		this.active = null;
	},

	next: function(event) {
		this.move(&quot;next&quot;, &quot;.ui-menu-item:first&quot;, event);
	},

	previous: function(event) {
		this.move(&quot;prev&quot;, &quot;.ui-menu-item:last&quot;, event);
	},

	first: function() {
		return this.active <span class="xer">&amp;</span><span class="xer">&amp;</span> !this.active.prevAll(&quot;.ui-menu-item&quot;).length;
	},

	last: function() {
		return this.active <span class="xer">&amp;</span><span class="xer">&amp;</span> !this.active.nextAll(&quot;.ui-menu-item&quot;).length;
	},

	move: function(direction, edge, event) {
		if (!this.active) {
			this.activate(event, this.element.children(edge));
			return;
		}
		var next = this.active[direction + &quot;All&quot;](&quot;.ui-menu-item&quot;).eq(0);
		if (next.length) {
			this.activate(event, next);
		} else {
			this.activate(event, this.element.children(edge));
		}
	},

	// TODO merge with previousPage
	nextPage: function(event) {
		if (this.hasScroll()) {
			// TODO merge with no-scroll-else
			if (!this.active || this.last()) {
				this.activate(event, this.element.children(&quot;.ui-menu-item:first&quot;));
				return;
			}
			var base = this.active.offset().top,
				height = this.element.height(),
				result = this.element.children(&quot;.ui-menu-item&quot;).filter(function() {
					var close = $(this).offset().top - base - height + $(this).height();
					// TODO improve approximation
					return close <span class="xd">&lt; </span><span class="xn">10 </span><span class="xan">&amp;&amp; </span><span class="xan">close </span><span class="xd">&gt;</span> -10;
				});

			// TODO try to catch this earlier when scrollTop indicates the last page anyway
			if (!result.length) {
				result = this.element.children(&quot;.ui-menu-item:last&quot;);
			}
			this.activate(event, result);
		} else {
			this.activate(event, this.element.children(&quot;.ui-menu-item&quot;)
				.filter(!this.active || this.last() ? &quot;:first&quot; : &quot;:last&quot;));
		}
	},

	// TODO merge with nextPage
	previousPage: function(event) {
		if (this.hasScroll()) {
			// TODO merge with no-scroll-else
			if (!this.active || this.first()) {
				this.activate(event, this.element.children(&quot;.ui-menu-item:last&quot;));
				return;
			}

			var base = this.active.offset().top,
				height = this.element.height();
				result = this.element.children(&quot;.ui-menu-item&quot;).filter(function() {
					var close = $(this).offset().top - base + height - $(this).height();
					// TODO improve approximation
					return close <span class="xd">&lt; </span><span class="xn">10 </span><span class="xan">&amp;&amp; </span><span class="xan">close </span><span class="xd">&gt;</span> -10;
				});

			// TODO try to catch this earlier when scrollTop indicates the last page anyway
			if (!result.length) {
				result = this.element.children(&quot;.ui-menu-item:first&quot;);
			}
			this.activate(event, result);
		} else {
			this.activate(event, this.element.children(&quot;.ui-menu-item&quot;)
				.filter(!this.active || this.first() ? &quot;:last&quot; : &quot;:first&quot;));
		}
	},

	hasScroll: function() {
		return this.element.height() <span class="xd">&lt; </span><span class="xn">this.element[ </span><span class="xan">$.fn.prop </span><span class="xd">? &quot;prop&quot; : &quot;attr&quot; ](&quot;scrollHeight&quot;);
	},

	select: function( event ) {
		this._trigger(&quot;selected&quot;, event, { item: this.active });
	}
});

}(jQuery));
/*
 * jQuery UI Button 1.8.18
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Button
 *
 * Depends:
 *	jquery.ui.core.js
 *	jquery.ui.widget.js
 */
(function( $, undefined ) {

var lastActive, startXPos, startYPos, clickDragged,
	baseClasses = &quot;ui-button ui-widget ui-state-default ui-corner-all&quot;,
	stateClasses = &quot;ui-state-hover ui-state-active &quot;,
	typeClasses = &quot;ui-button-icons-only ui-button-icon-only ui-button-text-icons ui-button-text-icon-primary ui-button-text-icon-secondary ui-button-text-only&quot;,
	formResetHandler = function() {
		var buttons = $( this ).find( &quot;:ui-button&quot; );
		setTimeout(function() {
			buttons.button( &quot;refresh&quot; );
		}, 1 );
	},
	radioGroup = function( radio ) {
		var name = radio.name,
			form = radio.form,
			radios = $( [] );
		if ( name ) {
			if ( form ) {
				radios = $( form ).find( &quot;[name=&#39;&quot; + name + &quot;&#39;]&quot; );
			} else {
				radios = $( &quot;[name=&#39;&quot; + name + &quot;&#39;]&quot;, radio.ownerDocument )
					.filter(function() {
						return !this.form;
					});
			}
		}
		return radios;
	};

$.widget( &quot;ui.button&quot;, {
	options: {
		disabled: null,
		text: true,
		label: null,
		icons: {
			primary: null,
			secondary: null
		}
	},
	_create: function() {
		this.element.closest( &quot;form&quot; )
			.unbind( &quot;reset.button&quot; )
			.bind( &quot;reset.button&quot;, formResetHandler );

		if ( typeof this.options.disabled !== &quot;boolean&quot; ) {
			this.options.disabled = !!this.element.propAttr( &quot;disabled&quot; );
		} else {
			this.element.propAttr( &quot;disabled&quot;, this.options.disabled );
		}

		this._determineButtonType();
		this.hasTitle = !!this.buttonElement.attr( &quot;title&quot; );

		var self = this,
			options = this.options,
			toggleButton = this.type === &quot;checkbox&quot; || this.type === &quot;radio&quot;,
			hoverClass = &quot;ui-state-hover&quot; + ( !toggleButton ? &quot; ui-state-active&quot; : &quot;&quot; ),
			focusClass = &quot;ui-state-focus&quot;;

		if ( options.label === null ) {
			options.label = this.buttonElement.html();
		}

		this.buttonElement
			.addClass( baseClasses )
			.attr( &quot;role&quot;, &quot;button&quot; )
			.bind( &quot;mouseenter.button&quot;, function() {
				if ( options.disabled ) {
					return;
				}
				$( this ).addClass( &quot;ui-state-hover&quot; );
				if ( this === lastActive ) {
					$( this ).addClass( &quot;ui-state-active&quot; );
				}
			})
			.bind( &quot;mouseleave.button&quot;, function() {
				if ( options.disabled ) {
					return;
				}
				$( this ).removeClass( hoverClass );
			})
			.bind( &quot;click.button&quot;, function( event ) {
				if ( options.disabled ) {
					event.preventDefault();
					event.stopImmediatePropagation();
				}
			});

		this.element
			.bind( &quot;focus.button&quot;, function() {
				// no need to check disabled, focus won&#39;t be triggered anyway
				self.buttonElement.addClass( focusClass );
			})
			.bind( &quot;blur.button&quot;, function() {
				self.buttonElement.removeClass( focusClass );
			});

		if ( toggleButton ) {
			this.element.bind( &quot;change.button&quot;, function() {
				if ( clickDragged ) {
					return;
				}
				self.refresh();
			});
			// if mouse moves between mousedown and mouseup (drag) set clickDragged flag
			// prevents issue where button state changes but checkbox/radio checked state
			// does not in Firefox (see ticket #6970)
			this.buttonElement
				.bind( &quot;mousedown.button&quot;, function( event ) {
					if ( options.disabled ) {
						return;
					}
					clickDragged = false;
					startXPos = event.pageX;
					startYPos = event.pageY;
				})
				.bind( &quot;mouseup.button&quot;, function( event ) {
					if ( options.disabled ) {
						return;
					}
					if ( startXPos !== event.pageX || startYPos !== event.pageY ) {
						clickDragged = true;
					}
			});
		}

		if ( this.type === &quot;checkbox&quot; ) {
			this.buttonElement.bind( &quot;click.button&quot;, function() {
				if ( options.disabled || clickDragged ) {
					return false;
				}
				$( this ).toggleClass( &quot;ui-state-active&quot; );
				self.buttonElement.attr( &quot;aria-pressed&quot;, self.element[0].checked );
			});
		} else if ( this.type === &quot;radio&quot; ) {
			this.buttonElement.bind( &quot;click.button&quot;, function() {
				if ( options.disabled || clickDragged ) {
					return false;
				}
				$( this ).addClass( &quot;ui-state-active&quot; );
				self.buttonElement.attr( &quot;aria-pressed&quot;, &quot;true&quot; );

				var radio = self.element[ 0 ];
				radioGroup( radio )
					.not( radio )
					.map(function() {
						return $( this ).button( &quot;widget&quot; )[ 0 ];
					})
					.removeClass( &quot;ui-state-active&quot; )
					.attr( &quot;aria-pressed&quot;, &quot;false&quot; );
			});
		} else {
			this.buttonElement
				.bind( &quot;mousedown.button&quot;, function() {
					if ( options.disabled ) {
						return false;
					}
					$( this ).addClass( &quot;ui-state-active&quot; );
					lastActive = this;
					$( document ).one( &quot;mouseup&quot;, function() {
						lastActive = null;
					});
				})
				.bind( &quot;mouseup.button&quot;, function() {
					if ( options.disabled ) {
						return false;
					}
					$( this ).removeClass( &quot;ui-state-active&quot; );
				})
				.bind( &quot;keydown.button&quot;, function(event) {
					if ( options.disabled ) {
						return false;
					}
					if ( event.keyCode == $.ui.keyCode.SPACE || event.keyCode == $.ui.keyCode.ENTER ) {
						$( this ).addClass( &quot;ui-state-active&quot; );
					}
				})
				.bind( &quot;keyup.button&quot;, function() {
					$( this ).removeClass( &quot;ui-state-active&quot; );
				});

			if ( this.buttonElement.is(&quot;a&quot;) ) {
				this.buttonElement.keyup(function(event) {
					if ( event.keyCode === $.ui.keyCode.SPACE ) {
						// TODO pass through original event correctly (just as 2nd argument doesn&#39;t work)
						$( this ).click();
					}
				});
			}
		}

		// TODO: pull out $.Widget&#39;s handling for the disabled option into
		// $.Widget.prototype._setOptionDisabled so it&#39;s easy to proxy and can
		// be overridden by individual plugins
		this._setOption( &quot;disabled&quot;, options.disabled );
		this._resetButton();
	},

	_determineButtonType: function() {

		if ( this.element.is(&quot;:checkbox&quot;) ) {
			this.type = &quot;checkbox&quot;;
		} else if ( this.element.is(&quot;:radio&quot;) ) {
			this.type = &quot;radio&quot;;
		} else if ( this.element.is(&quot;input&quot;) ) {
			this.type = &quot;input&quot;;
		} else {
			this.type = &quot;button&quot;;
		}

		if ( this.type === &quot;checkbox&quot; || this.type === &quot;radio&quot; ) {
			// we don&#39;t search against the document in case the element
			// is disconnected from the DOM
			var ancestor = this.element.parents().filter(&quot;:last&quot;),
				labelSelector = &quot;label[for=&#39;&quot; + this.element.attr(&quot;id&quot;) + &quot;&#39;]&quot;;
			this.buttonElement = ancestor.find( labelSelector );
			if ( !this.buttonElement.length ) {
				ancestor = ancestor.length ? ancestor.siblings() : this.element.siblings();
				this.buttonElement = ancestor.filter( labelSelector );
				if ( !this.buttonElement.length ) {
					this.buttonElement = ancestor.find( labelSelector );
				}
			}
			this.element.addClass( &quot;ui-helper-hidden-accessible&quot; );

			var checked = this.element.is( &quot;:checked&quot; );
			if ( checked ) {
				this.buttonElement.addClass( &quot;ui-state-active&quot; );
			}
			this.buttonElement.attr( &quot;aria-pressed&quot;, checked );
		} else {
			this.buttonElement = this.element;
		}
	},

	widget: function() {
		return this.buttonElement;
	},

	destroy: function() {
		this.element
			.removeClass( &quot;ui-helper-hidden-accessible&quot; );
		this.buttonElement
			.removeClass( baseClasses + &quot; &quot; + stateClasses + &quot; &quot; + typeClasses )
			.removeAttr( &quot;role&quot; )
			.removeAttr( &quot;aria-pressed&quot; )
			.html( this.buttonElement.find(&quot;.ui-button-text&quot;).html() );

		if ( !this.hasTitle ) {
			this.buttonElement.removeAttr( &quot;title&quot; );
		}

		$.Widget.prototype.destroy.call( this );
	},

	_setOption: function( key, value ) {
		$.Widget.prototype._setOption.apply( this, arguments );
		if ( key === &quot;disabled&quot; ) {
			if ( value ) {
				this.element.propAttr( &quot;disabled&quot;, true );
			} else {
				this.element.propAttr( &quot;disabled&quot;, false );
			}
			return;
		}
		this._resetButton();
	},

	refresh: function() {
		var isDisabled = this.element.is( &quot;:disabled&quot; );
		if ( isDisabled !== this.options.disabled ) {
			this._setOption( &quot;disabled&quot;, isDisabled );
		}
		if ( this.type === &quot;radio&quot; ) {
			radioGroup( this.element[0] ).each(function() {
				if ( $( this ).is( &quot;:checked&quot; ) ) {
					$( this ).button( &quot;widget&quot; )
						.addClass( &quot;ui-state-active&quot; )
						.attr( &quot;aria-pressed&quot;, &quot;true&quot; );
				} else {
					$( this ).button( &quot;widget&quot; )
						.removeClass( &quot;ui-state-active&quot; )
						.attr( &quot;aria-pressed&quot;, &quot;false&quot; );
				}
			});
		} else if ( this.type === &quot;checkbox&quot; ) {
			if ( this.element.is( &quot;:checked&quot; ) ) {
				this.buttonElement
					.addClass( &quot;ui-state-active&quot; )
					.attr( &quot;aria-pressed&quot;, &quot;true&quot; );
			} else {
				this.buttonElement
					.removeClass( &quot;ui-state-active&quot; )
					.attr( &quot;aria-pressed&quot;, &quot;false&quot; );
			}
		}
	},

	_resetButton: function() {
		if ( this.type === &quot;input&quot; ) {
			if ( this.options.label ) {
				this.element.val( this.options.label );
			}
			return;
		}
		var buttonElement = this.buttonElement.removeClass( typeClasses ),
			buttonText = $( &quot;</span><span class="xd">&lt;</span><span class="xn">span</span><span class="xd">&gt;</span><span class="xd">&lt;/</span><span class="xn">span</span><span class="xd">&gt;</span>&quot;, this.element[0].ownerDocument )
				.addClass( &quot;ui-button-text&quot; )
				.html( this.options.label )
				.appendTo( buttonElement.empty() )
				.text(),
			icons = this.options.icons,
			multipleIcons = icons.primary <span class="xer">&amp;</span><span class="xer">&amp;</span> icons.secondary,
			buttonClasses = [];  

		if ( icons.primary || icons.secondary ) {
			if ( this.options.text ) {
				buttonClasses.push( &quot;ui-button-text-icon&quot; + ( multipleIcons ? &quot;s&quot; : ( icons.primary ? &quot;-primary&quot; : &quot;-secondary&quot; ) ) );
			}

			if ( icons.primary ) {
				buttonElement.prepend( &quot;<span class="xd">&lt;</span><span class="xn">span </span><span class="xan">class</span><span class="xd">=</span>&#39;<span class="xav">ui-button-icon-primary ui-icon &quot; + icons.primary + &quot;</span>&#39;<span class="xd">&gt;</span><span class="xd">&lt;/</span><span class="xn">span</span><span class="xd">&gt;</span>&quot; );
			}

			if ( icons.secondary ) {
				buttonElement.append( &quot;<span class="xd">&lt;</span><span class="xn">span </span><span class="xan">class</span><span class="xd">=</span>&#39;<span class="xav">ui-button-icon-secondary ui-icon &quot; + icons.secondary + &quot;</span>&#39;<span class="xd">&gt;</span><span class="xd">&lt;/</span><span class="xn">span</span><span class="xd">&gt;</span>&quot; );
			}

			if ( !this.options.text ) {
				buttonClasses.push( multipleIcons ? &quot;ui-button-icons-only&quot; : &quot;ui-button-icon-only&quot; );

				if ( !this.hasTitle ) {
					buttonElement.attr( &quot;title&quot;, buttonText );
				}
			}
		} else {
			buttonClasses.push( &quot;ui-button-text-only&quot; );
		}
		buttonElement.addClass( buttonClasses.join( &quot; &quot; ) );
	}
});

$.widget( &quot;ui.buttonset&quot;, {
	options: {
		items: &quot;:button, :submit, :reset, :checkbox, :radio, a, :data(button)&quot;
	},

	_create: function() {
		this.element.addClass( &quot;ui-buttonset&quot; );
	},
	
	_init: function() {
		this.refresh();
	},

	_setOption: function( key, value ) {
		if ( key === &quot;disabled&quot; ) {
			this.buttons.button( &quot;option&quot;, key, value );
		}

		$.Widget.prototype._setOption.apply( this, arguments );
	},
	
	refresh: function() {
		var rtl = this.element.css( &quot;direction&quot; ) === &quot;rtl&quot;;
		
		this.buttons = this.element.find( this.options.items )
			.filter( &quot;:ui-button&quot; )
				.button( &quot;refresh&quot; )
			.end()
			.not( &quot;:ui-button&quot; )
				.button()
			.end()
			.map(function() {
				return $( this ).button( &quot;widget&quot; )[ 0 ];
			})
				.removeClass( &quot;ui-corner-all ui-corner-left ui-corner-right&quot; )
				.filter( &quot;:first&quot; )
					.addClass( rtl ? &quot;ui-corner-right&quot; : &quot;ui-corner-left&quot; )
				.end()
				.filter( &quot;:last&quot; )
					.addClass( rtl ? &quot;ui-corner-left&quot; : &quot;ui-corner-right&quot; )
				.end()
			.end();
	},

	destroy: function() {
		this.element.removeClass( &quot;ui-buttonset&quot; );
		this.buttons
			.map(function() {
				return $( this ).button( &quot;widget&quot; )[ 0 ];
			})
				.removeClass( &quot;ui-corner-left ui-corner-right&quot; )
			.end()
			.button( &quot;destroy&quot; );

		$.Widget.prototype.destroy.call( this );
	}
});

}( jQuery ) );
/*
 * jQuery UI Dialog 1.8.18
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Dialog
 *
 * Depends:
 *	jquery.ui.core.js
 *	jquery.ui.widget.js
 *  jquery.ui.button.js
 *	jquery.ui.draggable.js
 *	jquery.ui.mouse.js
 *	jquery.ui.position.js
 *	jquery.ui.resizable.js
 */
(function( $, undefined ) {

var uiDialogClasses =
		&#39;ui-dialog &#39; +
		&#39;ui-widget &#39; +
		&#39;ui-widget-content &#39; +
		&#39;ui-corner-all &#39;,
	sizeRelatedOptions = {
		buttons: true,
		height: true,
		maxHeight: true,
		maxWidth: true,
		minHeight: true,
		minWidth: true,
		width: true
	},
	resizableRelatedOptions = {
		maxHeight: true,
		maxWidth: true,
		minHeight: true,
		minWidth: true
	},
	// support for jQuery 1.3.2 - handle common attrFn methods for dialog
	attrFn = $.attrFn || {
		val: true,
		css: true,
		html: true,
		text: true,
		data: true,
		width: true,
		height: true,
		offset: true,
		click: true
	};

$.widget(&quot;ui.dialog&quot;, {
	options: {
		autoOpen: true,
		buttons: {},
		closeOnEscape: true,
		closeText: &#39;close&#39;,
		dialogClass: &#39;&#39;,
		draggable: true,
		hide: null,
		height: &#39;auto&#39;,
		maxHeight: false,
		maxWidth: false,
		minHeight: 150,
		minWidth: 150,
		modal: false,
		position: {
			my: &#39;center&#39;,
			at: &#39;center&#39;,
			collision: &#39;fit&#39;,
			// ensure that the titlebar is never outside the document
			using: function(pos) {
				var topOffset = $(this).css(pos).offset().top;
				if (topOffset <span class="xd">&lt; </span><span class="xn">0</span><span class="xd">) {
					$(this).css(&#39;top&#39;, pos.top - topOffset);
				}
			}
		},
		resizable: true,
		show: null,
		stack: true,
		title: &#39;&#39;,
		width: 300,
		zIndex: 1000
	},

	_create: function() {
		this.originalTitle = this.element.attr(&#39;title&#39;);
		// #5742 - .attr() might return a DOMElement
		if ( typeof this.originalTitle !== &quot;string&quot; ) {
			this.originalTitle = &quot;&quot;;
		}

		this.options.title = this.options.title || this.originalTitle;
		var self = this,
			options = self.options,

			title = options.title || &#39;&amp;#160;&#39;,
			titleId = $.ui.dialog.getTitleId(self.element),

			uiDialog = (self.uiDialog = $(&#39;</span><span class="xd">&lt;</span><span class="xn">div</span><span class="xd">&gt;</span><span class="xd">&lt;/</span><span class="xn">div</span><span class="xd">&gt;</span>&#39;))
				.appendTo(document.body)
				.hide()
				.addClass(uiDialogClasses + options.dialogClass)
				.css({
					zIndex: options.zIndex
				})
				// setting tabIndex makes the div focusable
				// setting outline to 0 prevents a border on focus in Mozilla
				.attr(&#39;tabIndex&#39;, -1).css(&#39;outline&#39;, 0).keydown(function(event) {
					if (options.closeOnEscape <span class="xer">&amp;</span><span class="xer">&amp;</span> !event.isDefaultPrevented() <span class="xer">&amp;</span><span class="xer">&amp;</span> event.keyCode <span class="xer">&amp;</span><span class="xer">&amp;</span>
						event.keyCode === $.ui.keyCode.ESCAPE) {
						
						self.close(event);
						event.preventDefault();
					}
				})
				.attr({
					role: &#39;dialog&#39;,
					&#39;aria-labelledby&#39;: titleId
				})
				.mousedown(function(event) {
					self.moveToTop(false, event);
				}),

			uiDialogContent = self.element
				.show()
				.removeAttr(&#39;title&#39;)
				.addClass(
					&#39;ui-dialog-content &#39; +
					&#39;ui-widget-content&#39;)
				.appendTo(uiDialog),

			uiDialogTitlebar = (self.uiDialogTitlebar = $(&#39;<span class="xd">&lt;</span><span class="xn">div</span><span class="xd">&gt;</span><span class="xd">&lt;/</span><span class="xn">div</span><span class="xd">&gt;</span>&#39;))
				.addClass(
					&#39;ui-dialog-titlebar &#39; +
					&#39;ui-widget-header &#39; +
					&#39;ui-corner-all &#39; +
					&#39;ui-helper-clearfix&#39;
				)
				.prependTo(uiDialog),

			uiDialogTitlebarClose = $(&#39;<span class="xd">&lt;</span><span class="xn">a </span><span class="xan">href</span><span class="xd">=</span>&quot;<span class="xav">#</span>&quot;<span class="xd">&gt;</span><span class="xd">&lt;/</span><span class="xn">a</span><span class="xd">&gt;</span>&#39;)
				.addClass(
					&#39;ui-dialog-titlebar-close &#39; +
					&#39;ui-corner-all&#39;
				)
				.attr(&#39;role&#39;, &#39;button&#39;)
				.hover(
					function() {
						uiDialogTitlebarClose.addClass(&#39;ui-state-hover&#39;);
					},
					function() {
						uiDialogTitlebarClose.removeClass(&#39;ui-state-hover&#39;);
					}
				)
				.focus(function() {
					uiDialogTitlebarClose.addClass(&#39;ui-state-focus&#39;);
				})
				.blur(function() {
					uiDialogTitlebarClose.removeClass(&#39;ui-state-focus&#39;);
				})
				.click(function(event) {
					self.close(event);
					return false;
				})
				.appendTo(uiDialogTitlebar),

			uiDialogTitlebarCloseText = (self.uiDialogTitlebarCloseText = $(&#39;<span class="xd">&lt;</span><span class="xn">span</span><span class="xd">&gt;</span><span class="xd">&lt;/</span><span class="xn">span</span><span class="xd">&gt;</span>&#39;))
				.addClass(
					&#39;ui-icon &#39; +
					&#39;ui-icon-closethick&#39;
				)
				.text(options.closeText)
				.appendTo(uiDialogTitlebarClose),

			uiDialogTitle = $(&#39;<span class="xd">&lt;</span><span class="xn">span</span><span class="xd">&gt;</span><span class="xd">&lt;/</span><span class="xn">span</span><span class="xd">&gt;</span>&#39;)
				.addClass(&#39;ui-dialog-title&#39;)
				.attr(&#39;id&#39;, titleId)
				.html(title)
				.prependTo(uiDialogTitlebar);

		//handling of deprecated beforeclose (vs beforeClose) option
		//Ticket #4669 http://dev.jqueryui.com/ticket/4669
		//TODO: remove in 1.9pre
		if ($.isFunction(options.beforeclose) <span class="xer">&amp;</span><span class="xer">&amp;</span> !$.isFunction(options.beforeClose)) {
			options.beforeClose = options.beforeclose;
		}

		uiDialogTitlebar.find(&quot;*&quot;).add(uiDialogTitlebar).disableSelection();

		if (options.draggable <span class="xer">&amp;</span><span class="xer">&amp;</span> $.fn.draggable) {
			self._makeDraggable();
		}
		if (options.resizable <span class="xer">&amp;</span><span class="xer">&amp;</span> $.fn.resizable) {
			self._makeResizable();
		}

		self._createButtons(options.buttons);
		self._isOpen = false;

		if ($.fn.bgiframe) {
			uiDialog.bgiframe();
		}
	},

	_init: function() {
		if ( this.options.autoOpen ) {
			this.open();
		}
	},

	destroy: function() {
		var self = this;
		
		if (self.overlay) {
			self.overlay.destroy();
		}
		self.uiDialog.hide();
		self.element
			.unbind(&#39;.dialog&#39;)
			.removeData(&#39;dialog&#39;)
			.removeClass(&#39;ui-dialog-content ui-widget-content&#39;)
			.hide().appendTo(&#39;body&#39;);
		self.uiDialog.remove();

		if (self.originalTitle) {
			self.element.attr(&#39;title&#39;, self.originalTitle);
		}

		return self;
	},

	widget: function() {
		return this.uiDialog;
	},

	close: function(event) {
		var self = this,
			maxZ, thisZ;
		
		if (false === self._trigger(&#39;beforeClose&#39;, event)) {
			return;
		}

		if (self.overlay) {
			self.overlay.destroy();
		}
		self.uiDialog.unbind(&#39;keypress.ui-dialog&#39;);

		self._isOpen = false;

		if (self.options.hide) {
			self.uiDialog.hide(self.options.hide, function() {
				self._trigger(&#39;close&#39;, event);
			});
		} else {
			self.uiDialog.hide();
			self._trigger(&#39;close&#39;, event);
		}

		$.ui.dialog.overlay.resize();

		// adjust the maxZ to allow other modal dialogs to continue to work (see #4309)
		if (self.options.modal) {
			maxZ = 0;
			$(&#39;.ui-dialog&#39;).each(function() {
				if (this !== self.uiDialog[0]) {
					thisZ = $(this).css(&#39;z-index&#39;);
					if(!isNaN(thisZ)) {
						maxZ = Math.max(maxZ, thisZ);
					}
				}
			});
			$.ui.dialog.maxZ = maxZ;
		}

		return self;
	},

	isOpen: function() {
		return this._isOpen;
	},

	// the force parameter allows us to move modal dialogs to their correct
	// position on open
	moveToTop: function(force, event) {
		var self = this,
			options = self.options,
			saveScroll;

		if ((options.modal <span class="xer">&amp;</span><span class="xer">&amp;</span> !force) ||
			(!options.stack <span class="xer">&amp;</span><span class="xer">&amp;</span> !options.modal)) {
			return self._trigger(&#39;focus&#39;, event);
		}

		if (options.zIndex &gt; $.ui.dialog.maxZ) {
			$.ui.dialog.maxZ = options.zIndex;
		}
		if (self.overlay) {
			$.ui.dialog.maxZ += 1;
			self.overlay.$el.css(&#39;z-index&#39;, $.ui.dialog.overlay.maxZ = $.ui.dialog.maxZ);
		}

		//Save and then restore scroll since Opera 9.5+ resets when parent z-Index is changed.
		//  http://ui.jquery.com/bugs/ticket/3193
		saveScroll = { scrollTop: self.element.scrollTop(), scrollLeft: self.element.scrollLeft() };
		$.ui.dialog.maxZ += 1;
		self.uiDialog.css(&#39;z-index&#39;, $.ui.dialog.maxZ);
		self.element.attr(saveScroll);
		self._trigger(&#39;focus&#39;, event);

		return self;
	},

	open: function() {
		if (this._isOpen) { return; }

		var self = this,
			options = self.options,
			uiDialog = self.uiDialog;

		self.overlay = options.modal ? new $.ui.dialog.overlay(self) : null;
		self._size();
		self._position(options.position);
		uiDialog.show(options.show);
		self.moveToTop(true);

		// prevent tabbing out of modal dialogs
		if ( options.modal ) {
			uiDialog.bind( &quot;keydown.ui-dialog&quot;, function( event ) {
				if ( event.keyCode !== $.ui.keyCode.TAB ) {
					return;
				}

				var tabbables = $(&#39;:tabbable&#39;, this),
					first = tabbables.filter(&#39;:first&#39;),
					last  = tabbables.filter(&#39;:last&#39;);

				if (event.target === last[0] <span class="xer">&amp;</span><span class="xer">&amp;</span> !event.shiftKey) {
					first.focus(1);
					return false;
				} else if (event.target === first[0] <span class="xer">&amp;</span><span class="xer">&amp;</span> event.shiftKey) {
					last.focus(1);
					return false;
				}
			});
		}

		// set focus to the first tabbable element in the content area or the first button
		// if there are no tabbable elements, set focus on the dialog itself
		$(self.element.find(&#39;:tabbable&#39;).get().concat(
			uiDialog.find(&#39;.ui-dialog-buttonpane :tabbable&#39;).get().concat(
				uiDialog.get()))).eq(0).focus();

		self._isOpen = true;
		self._trigger(&#39;open&#39;);

		return self;
	},

	_createButtons: function(buttons) {
		var self = this,
			hasButtons = false,
			uiDialogButtonPane = $(&#39;<span class="xd">&lt;</span><span class="xn">div</span><span class="xd">&gt;</span><span class="xd">&lt;/</span><span class="xn">div</span><span class="xd">&gt;</span>&#39;)
				.addClass(
					&#39;ui-dialog-buttonpane &#39; +
					&#39;ui-widget-content &#39; +
					&#39;ui-helper-clearfix&#39;
				),
			uiButtonSet = $( &quot;<span class="xd">&lt;</span><span class="xn">div</span><span class="xd">&gt;</span><span class="xd">&lt;/</span><span class="xn">div</span><span class="xd">&gt;</span>&quot; )
				.addClass( &quot;ui-dialog-buttonset&quot; )
				.appendTo( uiDialogButtonPane );

		// if we already have a button pane, remove it
		self.uiDialog.find(&#39;.ui-dialog-buttonpane&#39;).remove();

		if (typeof buttons === &#39;object&#39; <span class="xer">&amp;</span><span class="xer">&amp;</span> buttons !== null) {
			$.each(buttons, function() {
				return !(hasButtons = true);
			});
		}
		if (hasButtons) {
			$.each(buttons, function(name, props) {
				props = $.isFunction( props ) ?
					{ click: props, text: name } :
					props;
				var button = $(&#39;<span class="xd">&lt;</span><span class="xn">button </span><span class="xan">type</span><span class="xd">=</span>&quot;<span class="xav">button</span>&quot;<span class="xd">&gt;</span><span class="xd">&lt;/</span><span class="xn">button</span><span class="xd">&gt;</span>&#39;)
					.click(function() {
						props.click.apply(self.element[0], arguments);
					})
					.appendTo(uiButtonSet);
				// can&#39;t use .attr( props, true ) with jQuery 1.3.2.
				$.each( props, function( key, value ) {
					if ( key === &quot;click&quot; ) {
						return;
					}
					if ( key in attrFn ) {
						button[ key ]( value );
					} else {
						button.attr( key, value );
					}
				});
				if ($.fn.button) {
					button.button();
				}
			});
			uiDialogButtonPane.appendTo(self.uiDialog);
		}
	},

	_makeDraggable: function() {
		var self = this,
			options = self.options,
			doc = $(document),
			heightBeforeDrag;

		function filteredUi(ui) {
			return {
				position: ui.position,
				offset: ui.offset
			};
		}

		self.uiDialog.draggable({
			cancel: &#39;.ui-dialog-content, .ui-dialog-titlebar-close&#39;,
			handle: &#39;.ui-dialog-titlebar&#39;,
			containment: &#39;document&#39;,
			start: function(event, ui) {
				heightBeforeDrag = options.height === &quot;auto&quot; ? &quot;auto&quot; : $(this).height();
				$(this).height($(this).height()).addClass(&quot;ui-dialog-dragging&quot;);
				self._trigger(&#39;dragStart&#39;, event, filteredUi(ui));
			},
			drag: function(event, ui) {
				self._trigger(&#39;drag&#39;, event, filteredUi(ui));
			},
			stop: function(event, ui) {
				options.position = [ui.position.left - doc.scrollLeft(),
					ui.position.top - doc.scrollTop()];
				$(this).removeClass(&quot;ui-dialog-dragging&quot;).height(heightBeforeDrag);
				self._trigger(&#39;dragStop&#39;, event, filteredUi(ui));
				$.ui.dialog.overlay.resize();
			}
		});
	},

	_makeResizable: function(handles) {
		handles = (handles === undefined ? this.options.resizable : handles);
		var self = this,
			options = self.options,
			// .ui-resizable has position: relative defined in the stylesheet
			// but dialogs have to use absolute or fixed positioning
			position = self.uiDialog.css(&#39;position&#39;),
			resizeHandles = (typeof handles === &#39;string&#39; ?
				handles	:
				&#39;n,e,s,w,se,sw,ne,nw&#39;
			);

		function filteredUi(ui) {
			return {
				originalPosition: ui.originalPosition,
				originalSize: ui.originalSize,
				position: ui.position,
				size: ui.size
			};
		}

		self.uiDialog.resizable({
			cancel: &#39;.ui-dialog-content&#39;,
			containment: &#39;document&#39;,
			alsoResize: self.element,
			maxWidth: options.maxWidth,
			maxHeight: options.maxHeight,
			minWidth: options.minWidth,
			minHeight: self._minHeight(),
			handles: resizeHandles,
			start: function(event, ui) {
				$(this).addClass(&quot;ui-dialog-resizing&quot;);
				self._trigger(&#39;resizeStart&#39;, event, filteredUi(ui));
			},
			resize: function(event, ui) {
				self._trigger(&#39;resize&#39;, event, filteredUi(ui));
			},
			stop: function(event, ui) {
				$(this).removeClass(&quot;ui-dialog-resizing&quot;);
				options.height = $(this).height();
				options.width = $(this).width();
				self._trigger(&#39;resizeStop&#39;, event, filteredUi(ui));
				$.ui.dialog.overlay.resize();
			}
		})
		.css(&#39;position&#39;, position)
		.find(&#39;.ui-resizable-se&#39;).addClass(&#39;ui-icon ui-icon-grip-diagonal-se&#39;);
	},

	_minHeight: function() {
		var options = this.options;

		if (options.height === &#39;auto&#39;) {
			return options.minHeight;
		} else {
			return Math.min(options.minHeight, options.height);
		}
	},

	_position: function(position) {
		var myAt = [],
			offset = [0, 0],
			isVisible;

		if (position) {
			// deep extending converts arrays to objects in jQuery <span class="xd">&lt;</span><span class="xd">= </span><span class="xav">1.3.2</span><span class="xd"> :-(
	//		if (typeof position == &#39;string&#39; || $.isArray(position)) {
	//			myAt = $.isArray(position) ? position : position.split(&#39; &#39;);

			if (typeof position === &#39;string&#39; || (typeof position === &#39;object&#39; &amp;&amp; &#39;0&#39; in position)) {
				myAt = position.split ? position.split(&#39; &#39;) : [position[0], position[1]];
				if (myAt.length === 1) {
					myAt[1] = myAt[0];
				}

				$.each([&#39;left&#39;, &#39;top&#39;], function(i, offsetPosition) {
					if (+myAt[i] === myAt[i]) {
						offset[i] = myAt[i];
						myAt[i] = offsetPosition;
					}
				});

				position = {
					my: myAt.join(&quot; &quot;),
					at: myAt.join(&quot; &quot;),
					offset: offset.join(&quot; &quot;)
				};
			} 

			position = $.extend({}, $.ui.dialog.prototype.options.position, position);
		} else {
			position = $.ui.dialog.prototype.options.position;
		}

		// need to show the dialog to get the actual offset in the position plugin
		isVisible = this.uiDialog.is(&#39;:visible&#39;);
		if (!isVisible) {
			this.uiDialog.show();
		}
		this.uiDialog
			// workaround for jQuery bug #5781 http://dev.jquery.com/ticket/5781
			.css({ top: 0, left: 0 })
			.position($.extend({ of: window }, position));
		if (!isVisible) {
			this.uiDialog.hide();
		}
	},

	_setOptions: function( options ) {
		var self = this,
			resizableOptions = {},
			resize = false;

		$.each( options, function( key, value ) {
			self._setOption( key, value );
			
			if ( key in sizeRelatedOptions ) {
				resize = true;
			}
			if ( key in resizableRelatedOptions ) {
				resizableOptions[ key ] = value;
			}
		});

		if ( resize ) {
			this._size();
		}
		if ( this.uiDialog.is( &quot;:data(resizable)&quot; ) ) {
			this.uiDialog.resizable( &quot;option&quot;, resizableOptions );
		}
	},

	_setOption: function(key, value){
		var self = this,
			uiDialog = self.uiDialog;

		switch (key) {
			//handling of deprecated beforeclose (vs beforeClose) option
			//Ticket #4669 http://dev.jqueryui.com/ticket/4669
			//TODO: remove in 1.9pre
			case &quot;beforeclose&quot;:
				key = &quot;beforeClose&quot;;
				break;
			case &quot;buttons&quot;:
				self._createButtons(value);
				break;
			case &quot;closeText&quot;:
				// ensure that we always pass a string
				self.uiDialogTitlebarCloseText.text(&quot;&quot; + value);
				break;
			case &quot;dialogClass&quot;:
				uiDialog
					.removeClass(self.options.dialogClass)
					.addClass(uiDialogClasses + value);
				break;
			case &quot;disabled&quot;:
				if (value) {
					uiDialog.addClass(&#39;ui-dialog-disabled&#39;);
				} else {
					uiDialog.removeClass(&#39;ui-dialog-disabled&#39;);
				}
				break;
			case &quot;draggable&quot;:
				var isDraggable = uiDialog.is( &quot;:data(draggable)&quot; );
				if ( isDraggable &amp;&amp; !value ) {
					uiDialog.draggable( &quot;destroy&quot; );
				}
				
				if ( !isDraggable &amp;&amp; value ) {
					self._makeDraggable();
				}
				break;
			case &quot;position&quot;:
				self._position(value);
				break;
			case &quot;resizable&quot;:
				// currently resizable, becoming non-resizable
				var isResizable = uiDialog.is( &quot;:data(resizable)&quot; );
				if (isResizable &amp;&amp; !value) {
					uiDialog.resizable(&#39;destroy&#39;);
				}

				// currently resizable, changing handles
				if (isResizable &amp;&amp; typeof value === &#39;string&#39;) {
					uiDialog.resizable(&#39;option&#39;, &#39;handles&#39;, value);
				}

				// currently non-resizable, becoming resizable
				if (!isResizable &amp;&amp; value !== false) {
					self._makeResizable(value);
				}
				break;
			case &quot;title&quot;:
				// convert whatever was passed in o a string, for html() to not throw up
				$(&quot;.ui-dialog-title&quot;, self.uiDialogTitlebar).html(&quot;&quot; + (value || &#39;&amp;#160;&#39;));
				break;
		}

		$.Widget.prototype._setOption.apply(self, arguments);
	},

	_size: function() {
		/* If the user has resized the dialog, the .ui-dialog and .ui-dialog-content
		 * divs will both have width and height set, so we need to reset them
		 */
		var options = this.options,
			nonContentHeight,
			minContentHeight,
			isVisible = this.uiDialog.is( &quot;:visible&quot; );

		// reset content sizing
		this.element.show().css({
			width: &#39;auto&#39;,
			minHeight: 0,
			height: 0
		});

		if (options.minWidth &gt;</span> options.width) {
			options.width = options.minWidth;
		}

		// reset wrapper sizing
		// determine the height of all the non-content elements
		nonContentHeight = this.uiDialog.css({
				height: &#39;auto&#39;,
				width: options.width
			})
			.height();
		minContentHeight = Math.max( 0, options.minHeight - nonContentHeight );
		
		if ( options.height === &quot;auto&quot; ) {
			// only needed for IE6 support
			if ( $.support.minHeight ) {
				this.element.css({
					minHeight: minContentHeight,
					height: &quot;auto&quot;
				});
			} else {
				this.uiDialog.show();
				var autoHeight = this.element.css( &quot;height&quot;, &quot;auto&quot; ).height();
				if ( !isVisible ) {
					this.uiDialog.hide();
				}
				this.element.height( Math.max( autoHeight, minContentHeight ) );
			}
		} else {
			this.element.height( Math.max( options.height - nonContentHeight, 0 ) );
		}

		if (this.uiDialog.is(&#39;:data(resizable)&#39;)) {
			this.uiDialog.resizable(&#39;option&#39;, &#39;minHeight&#39;, this._minHeight());
		}
	}
});

$.extend($.ui.dialog, {
	version: &quot;1.8.18&quot;,

	uuid: 0,
	maxZ: 0,

	getTitleId: function($el) {
		var id = $el.attr(&#39;id&#39;);
		if (!id) {
			this.uuid += 1;
			id = this.uuid;
		}
		return &#39;ui-dialog-title-&#39; + id;
	},

	overlay: function(dialog) {
		this.$el = $.ui.dialog.overlay.create(dialog);
	}
});

$.extend($.ui.dialog.overlay, {
	instances: [],
	// reuse old instances due to IE memory leak with alpha transparency (see #5185)
	oldInstances: [],
	maxZ: 0,
	events: $.map(&#39;focus,mousedown,mouseup,keydown,keypress,click&#39;.split(&#39;,&#39;),
		function(event) { return event + &#39;.dialog-overlay&#39;; }).join(&#39; &#39;),
	create: function(dialog) {
		if (this.instances.length === 0) {
			// prevent use of anchors and inputs
			// we use a setTimeout in case the overlay is created from an
			// event that we&#39;re going to be cancelling (see #2804)
			setTimeout(function() {
				// handle $(el).dialog().dialog(&#39;close&#39;) (see #4065)
				if ($.ui.dialog.overlay.instances.length) {
					$(document).bind($.ui.dialog.overlay.events, function(event) {
						// stop events if the z-index of the target is <span class="xd">&lt; </span><span class="xn">the </span><span class="xan">z-index </span><span class="xan">of </span><span class="xan">the </span><span class="xan">overlay</span><span class="xd">
						// we cannot return true when we don&#39;t want to cancel the event (#3523)
						if ($(event.target).zIndex() </span><span class="xd">&lt; </span><span class="xn">$.ui.dialog.overlay.maxZ</span><span class="xd">) {
							return false;
						}
					});
				}
			}, 1);

			// allow closing by pressing the escape key
			$(document).bind(&#39;keydown.dialog-overlay&#39;, function(event) {
				if (dialog.options.closeOnEscape &amp;&amp; !event.isDefaultPrevented() &amp;&amp; event.keyCode &amp;&amp;
					event.keyCode === $.ui.keyCode.ESCAPE) {
					
					dialog.close(event);
					event.preventDefault();
				}
			});

			// handle window resize
			$(window).bind(&#39;resize.dialog-overlay&#39;, $.ui.dialog.overlay.resize);
		}

		var $el = (this.oldInstances.pop() || $(&#39;</span><span class="xd">&lt;</span><span class="xn">div</span><span class="xd">&gt;</span><span class="xd">&lt;/</span><span class="xn">div</span><span class="xd">&gt;</span>&#39;).addClass(&#39;ui-widget-overlay&#39;))
			.appendTo(document.body)
			.css({
				width: this.width(),
				height: this.height()
			});

		if ($.fn.bgiframe) {
			$el.bgiframe();
		}

		this.instances.push($el);
		return $el;
	},

	destroy: function($el) {
		var indexOf = $.inArray($el, this.instances);
		if (indexOf != -1){
			this.oldInstances.push(this.instances.splice(indexOf, 1)[0]);
		}

		if (this.instances.length === 0) {
			$([document, window]).unbind(&#39;.dialog-overlay&#39;);
		}

		$el.remove();
		
		// adjust the maxZ to allow other modal dialogs to continue to work (see #4309)
		var maxZ = 0;
		$.each(this.instances, function() {
			maxZ = Math.max(maxZ, this.css(&#39;z-index&#39;));
		});
		this.maxZ = maxZ;
	},

	height: function() {
		var scrollHeight,
			offsetHeight;
		// handle IE 6
		if ($.browser.msie <span class="xer">&amp;</span><span class="xer">&amp;</span> $.browser.version <span class="xd">&lt; </span><span class="xn">7</span><span class="xd">) {
			scrollHeight = Math.max(
				document.documentElement.scrollHeight,
				document.body.scrollHeight
			);
			offsetHeight = Math.max(
				document.documentElement.offsetHeight,
				document.body.offsetHeight
			);

			if (scrollHeight </span><span class="xd">&lt; </span><span class="xn">offsetHeight</span><span class="xd">) {
				return $(window).height() + &#39;px&#39;;
			} else {
				return scrollHeight + &#39;px&#39;;
			}
		// handle &quot;good&quot; browsers
		} else {
			return $(document).height() + &#39;px&#39;;
		}
	},

	width: function() {
		var scrollWidth,
			offsetWidth;
		// handle IE
		if ( $.browser.msie ) {
			scrollWidth = Math.max(
				document.documentElement.scrollWidth,
				document.body.scrollWidth
			);
			offsetWidth = Math.max(
				document.documentElement.offsetWidth,
				document.body.offsetWidth
			);

			if (scrollWidth </span><span class="xd">&lt; </span><span class="xn">offsetWidth</span><span class="xd">) {
				return $(window).width() + &#39;px&#39;;
			} else {
				return scrollWidth + &#39;px&#39;;
			}
		// handle &quot;good&quot; browsers
		} else {
			return $(document).width() + &#39;px&#39;;
		}
	},

	resize: function() {
		/* If the dialog is draggable and the user drags it past the
		 * right edge of the window, the document becomes wider so we
		 * need to stretch the overlay. If the user then drags the
		 * dialog back to the left, the document will become narrower,
		 * so we need to shrink the overlay to the appropriate size.
		 * This is handled by shrinking the overlay before setting it
		 * to the full document size.
		 */
		var $overlays = $([]);
		$.each($.ui.dialog.overlay.instances, function() {
			$overlays = $overlays.add(this);
		});

		$overlays.css({
			width: 0,
			height: 0
		}).css({
			width: $.ui.dialog.overlay.width(),
			height: $.ui.dialog.overlay.height()
		});
	}
});

$.extend($.ui.dialog.overlay.prototype, {
	destroy: function() {
		$.ui.dialog.overlay.destroy(this.$el);
	}
});

}(jQuery));
/*
 * jQuery UI Slider 1.8.18
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Slider
 *
 * Depends:
 *	jquery.ui.core.js
 *	jquery.ui.mouse.js
 *	jquery.ui.widget.js
 */
(function( $, undefined ) {

// number of pages in a slider
// (how many times can you page up/down to go through the whole range)
var numPages = 5;

$.widget( &quot;ui.slider&quot;, $.ui.mouse, {

	widgetEventPrefix: &quot;slide&quot;,

	options: {
		animate: false,
		distance: 0,
		max: 100,
		min: 0,
		orientation: &quot;horizontal&quot;,
		range: false,
		step: 1,
		value: 0,
		values: null
	},

	_create: function() {
		var self = this,
			o = this.options,
			existingHandles = this.element.find( &quot;.ui-slider-handle&quot; ).addClass( &quot;ui-state-default ui-corner-all&quot; ),
			handle = &quot;</span><span class="xd">&lt;</span><span class="xn">a </span><span class="xan">class</span><span class="xd">=</span>&#39;<span class="xav">ui-slider-handle ui-state-default ui-corner-all</span>&#39; <span class="xan">href</span><span class="xd">=</span>&#39;<span class="xav">#</span>&#39;<span class="xd">&gt;</span><span class="xd">&lt;/</span><span class="xn">a</span><span class="xd">&gt;</span>&quot;,
			handleCount = ( o.values <span class="xer">&amp;</span><span class="xer">&amp;</span> o.values.length ) || 1,
			handles = [];

		this._keySliding = false;
		this._mouseSliding = false;
		this._animateOff = true;
		this._handleIndex = null;
		this._detectOrientation();
		this._mouseInit();

		this.element
			.addClass( &quot;ui-slider&quot; +
				&quot; ui-slider-&quot; + this.orientation +
				&quot; ui-widget&quot; +
				&quot; ui-widget-content&quot; +
				&quot; ui-corner-all&quot; +
				( o.disabled ? &quot; ui-slider-disabled ui-disabled&quot; : &quot;&quot; ) );

		this.range = $([]);

		if ( o.range ) {
			if ( o.range === true ) {
				if ( !o.values ) {
					o.values = [ this._valueMin(), this._valueMin() ];
				}
				if ( o.values.length <span class="xer">&amp;</span><span class="xer">&amp;</span> o.values.length !== 2 ) {
					o.values = [ o.values[0], o.values[0] ];
				}
			}

			this.range = $( &quot;<span class="xd">&lt;</span><span class="xn">div</span><span class="xd">&gt;</span><span class="xd">&lt;/</span><span class="xn">div</span><span class="xd">&gt;</span>&quot; )
				.appendTo( this.element )
				.addClass( &quot;ui-slider-range&quot; +
				// note: this isn&#39;t the most fittingly semantic framework class for this element,
				// but worked best visually with a variety of themes
				&quot; ui-widget-header&quot; + 
				( ( o.range === &quot;min&quot; || o.range === &quot;max&quot; ) ? &quot; ui-slider-range-&quot; + o.range : &quot;&quot; ) );
		}

		for ( var i = existingHandles.length; i <span class="xd">&lt; </span><span class="xn">handleCount</span><span class="xd">; i += 1 ) {
			handles.push( handle );
		}

		this.handles = existingHandles.add( $( handles.join( &quot;&quot; ) ).appendTo( self.element ) );

		this.handle = this.handles.eq( 0 );

		this.handles.add( this.range ).filter( &quot;a&quot; )
			.click(function( event ) {
				event.preventDefault();
			})
			.hover(function() {
				if ( !o.disabled ) {
					$( this ).addClass( &quot;ui-state-hover&quot; );
				}
			}, function() {
				$( this ).removeClass( &quot;ui-state-hover&quot; );
			})
			.focus(function() {
				if ( !o.disabled ) {
					$( &quot;.ui-slider .ui-state-focus&quot; ).removeClass( &quot;ui-state-focus&quot; );
					$( this ).addClass( &quot;ui-state-focus&quot; );
				} else {
					$( this ).blur();
				}
			})
			.blur(function() {
				$( this ).removeClass( &quot;ui-state-focus&quot; );
			});

		this.handles.each(function( i ) {
			$( this ).data( &quot;index.ui-slider-handle&quot;, i );
		});

		this.handles
			.keydown(function( event ) {
				var index = $( this ).data( &quot;index.ui-slider-handle&quot; ),
					allowed,
					curVal,
					newVal,
					step;
	
				if ( self.options.disabled ) {
					return;
				}
	
				switch ( event.keyCode ) {
					case $.ui.keyCode.HOME:
					case $.ui.keyCode.END:
					case $.ui.keyCode.PAGE_UP:
					case $.ui.keyCode.PAGE_DOWN:
					case $.ui.keyCode.UP:
					case $.ui.keyCode.RIGHT:
					case $.ui.keyCode.DOWN:
					case $.ui.keyCode.LEFT:
						event.preventDefault();
						if ( !self._keySliding ) {
							self._keySliding = true;
							$( this ).addClass( &quot;ui-state-active&quot; );
							allowed = self._start( event, index );
							if ( allowed === false ) {
								return;
							}
						}
						break;
				}
	
				step = self.options.step;
				if ( self.options.values &amp;&amp; self.options.values.length ) {
					curVal = newVal = self.values( index );
				} else {
					curVal = newVal = self.value();
				}
	
				switch ( event.keyCode ) {
					case $.ui.keyCode.HOME:
						newVal = self._valueMin();
						break;
					case $.ui.keyCode.END:
						newVal = self._valueMax();
						break;
					case $.ui.keyCode.PAGE_UP:
						newVal = self._trimAlignValue( curVal + ( (self._valueMax() - self._valueMin()) / numPages ) );
						break;
					case $.ui.keyCode.PAGE_DOWN:
						newVal = self._trimAlignValue( curVal - ( (self._valueMax() - self._valueMin()) / numPages ) );
						break;
					case $.ui.keyCode.UP:
					case $.ui.keyCode.RIGHT:
						if ( curVal === self._valueMax() ) {
							return;
						}
						newVal = self._trimAlignValue( curVal + step );
						break;
					case $.ui.keyCode.DOWN:
					case $.ui.keyCode.LEFT:
						if ( curVal === self._valueMin() ) {
							return;
						}
						newVal = self._trimAlignValue( curVal - step );
						break;
				}
	
				self._slide( event, index, newVal );
			})
			.keyup(function( event ) {
				var index = $( this ).data( &quot;index.ui-slider-handle&quot; );
	
				if ( self._keySliding ) {
					self._keySliding = false;
					self._stop( event, index );
					self._change( event, index );
					$( this ).removeClass( &quot;ui-state-active&quot; );
				}
	
			});

		this._refreshValue();

		this._animateOff = false;
	},

	destroy: function() {
		this.handles.remove();
		this.range.remove();

		this.element
			.removeClass( &quot;ui-slider&quot; +
				&quot; ui-slider-horizontal&quot; +
				&quot; ui-slider-vertical&quot; +
				&quot; ui-slider-disabled&quot; +
				&quot; ui-widget&quot; +
				&quot; ui-widget-content&quot; +
				&quot; ui-corner-all&quot; )
			.removeData( &quot;slider&quot; )
			.unbind( &quot;.slider&quot; );

		this._mouseDestroy();

		return this;
	},

	_mouseCapture: function( event ) {
		var o = this.options,
			position,
			normValue,
			distance,
			closestHandle,
			self,
			index,
			allowed,
			offset,
			mouseOverHandle;

		if ( o.disabled ) {
			return false;
		}

		this.elementSize = {
			width: this.element.outerWidth(),
			height: this.element.outerHeight()
		};
		this.elementOffset = this.element.offset();

		position = { x: event.pageX, y: event.pageY };
		normValue = this._normValueFromMouse( position );
		distance = this._valueMax() - this._valueMin() + 1;
		self = this;
		this.handles.each(function( i ) {
			var thisDistance = Math.abs( normValue - self.values(i) );
			if ( distance &gt;</span> thisDistance ) {
				distance = thisDistance;
				closestHandle = $( this );
				index = i;
			}
		});

		// workaround for bug #3736 (if both handles of a range are at 0,
		// the first is always used as the one with least distance,
		// and moving it is obviously prevented by preventing negative ranges)
		if( o.range === true <span class="xer">&amp;</span><span class="xer">&amp;</span> this.values(1) === o.min ) {
			index += 1;
			closestHandle = $( this.handles[index] );
		}

		allowed = this._start( event, index );
		if ( allowed === false ) {
			return false;
		}
		this._mouseSliding = true;

		self._handleIndex = index;

		closestHandle
			.addClass( &quot;ui-state-active&quot; )
			.focus();
		
		offset = closestHandle.offset();
		mouseOverHandle = !$( event.target ).parents().andSelf().is( &quot;.ui-slider-handle&quot; );
		this._clickOffset = mouseOverHandle ? { left: 0, top: 0 } : {
			left: event.pageX - offset.left - ( closestHandle.width() / 2 ),
			top: event.pageY - offset.top -
				( closestHandle.height() / 2 ) -
				( parseInt( closestHandle.css(&quot;borderTopWidth&quot;), 10 ) || 0 ) -
				( parseInt( closestHandle.css(&quot;borderBottomWidth&quot;), 10 ) || 0) +
				( parseInt( closestHandle.css(&quot;marginTop&quot;), 10 ) || 0)
		};

		if ( !this.handles.hasClass( &quot;ui-state-hover&quot; ) ) {
			this._slide( event, index, normValue );
		}
		this._animateOff = true;
		return true;
	},

	_mouseStart: function( event ) {
		return true;
	},

	_mouseDrag: function( event ) {
		var position = { x: event.pageX, y: event.pageY },
			normValue = this._normValueFromMouse( position );
		
		this._slide( event, this._handleIndex, normValue );

		return false;
	},

	_mouseStop: function( event ) {
		this.handles.removeClass( &quot;ui-state-active&quot; );
		this._mouseSliding = false;

		this._stop( event, this._handleIndex );
		this._change( event, this._handleIndex );

		this._handleIndex = null;
		this._clickOffset = null;
		this._animateOff = false;

		return false;
	},
	
	_detectOrientation: function() {
		this.orientation = ( this.options.orientation === &quot;vertical&quot; ) ? &quot;vertical&quot; : &quot;horizontal&quot;;
	},

	_normValueFromMouse: function( position ) {
		var pixelTotal,
			pixelMouse,
			percentMouse,
			valueTotal,
			valueMouse;

		if ( this.orientation === &quot;horizontal&quot; ) {
			pixelTotal = this.elementSize.width;
			pixelMouse = position.x - this.elementOffset.left - ( this._clickOffset ? this._clickOffset.left : 0 );
		} else {
			pixelTotal = this.elementSize.height;
			pixelMouse = position.y - this.elementOffset.top - ( this._clickOffset ? this._clickOffset.top : 0 );
		}

		percentMouse = ( pixelMouse / pixelTotal );
		if ( percentMouse &gt; 1 ) {
			percentMouse = 1;
		}
		if ( percentMouse <span class="xd">&lt; </span><span class="xn">0 </span><span class="xd">) {
			percentMouse = 0;
		}
		if ( this.orientation === &quot;vertical&quot; ) {
			percentMouse = 1 - percentMouse;
		}

		valueTotal = this._valueMax() - this._valueMin();
		valueMouse = this._valueMin() + percentMouse * valueTotal;

		return this._trimAlignValue( valueMouse );
	},

	_start: function( event, index ) {
		var uiHash = {
			handle: this.handles[ index ],
			value: this.value()
		};
		if ( this.options.values &amp;&amp; this.options.values.length ) {
			uiHash.value = this.values( index );
			uiHash.values = this.values();
		}
		return this._trigger( &quot;start&quot;, event, uiHash );
	},

	_slide: function( event, index, newVal ) {
		var otherVal,
			newValues,
			allowed;

		if ( this.options.values &amp;&amp; this.options.values.length ) {
			otherVal = this.values( index ? 0 : 1 );

			if ( ( this.options.values.length === 2 &amp;&amp; this.options.range === true ) &amp;&amp; 
					( ( index === 0 &amp;&amp; newVal &gt;</span> otherVal) || ( index === 1 <span class="xer">&amp;</span><span class="xer">&amp;</span> newVal <span class="xd">&lt; </span><span class="xn">otherVal </span><span class="xd">) )
				) {
				newVal = otherVal;
			}

			if ( newVal !== this.values( index ) ) {
				newValues = this.values();
				newValues[ index ] = newVal;
				// A slide can be canceled by returning false from the slide callback
				allowed = this._trigger( &quot;slide&quot;, event, {
					handle: this.handles[ index ],
					value: newVal,
					values: newValues
				} );
				otherVal = this.values( index ? 0 : 1 );
				if ( allowed !== false ) {
					this.values( index, newVal, true );
				}
			}
		} else {
			if ( newVal !== this.value() ) {
				// A slide can be canceled by returning false from the slide callback
				allowed = this._trigger( &quot;slide&quot;, event, {
					handle: this.handles[ index ],
					value: newVal
				} );
				if ( allowed !== false ) {
					this.value( newVal );
				}
			}
		}
	},

	_stop: function( event, index ) {
		var uiHash = {
			handle: this.handles[ index ],
			value: this.value()
		};
		if ( this.options.values &amp;&amp; this.options.values.length ) {
			uiHash.value = this.values( index );
			uiHash.values = this.values();
		}

		this._trigger( &quot;stop&quot;, event, uiHash );
	},

	_change: function( event, index ) {
		if ( !this._keySliding &amp;&amp; !this._mouseSliding ) {
			var uiHash = {
				handle: this.handles[ index ],
				value: this.value()
			};
			if ( this.options.values &amp;&amp; this.options.values.length ) {
				uiHash.value = this.values( index );
				uiHash.values = this.values();
			}

			this._trigger( &quot;change&quot;, event, uiHash );
		}
	},

	value: function( newValue ) {
		if ( arguments.length ) {
			this.options.value = this._trimAlignValue( newValue );
			this._refreshValue();
			this._change( null, 0 );
			return;
		}

		return this._value();
	},

	values: function( index, newValue ) {
		var vals,
			newValues,
			i;

		if ( arguments.length &gt;</span> 1 ) {
			this.options.values[ index ] = this._trimAlignValue( newValue );
			this._refreshValue();
			this._change( null, index );
			return;
		}

		if ( arguments.length ) {
			if ( $.isArray( arguments[ 0 ] ) ) {
				vals = this.options.values;
				newValues = arguments[ 0 ];
				for ( i = 0; i <span class="xd">&lt; </span><span class="xn">vals.length</span><span class="xd">; i += 1 ) {
					vals[ i ] = this._trimAlignValue( newValues[ i ] );
					this._change( null, i );
				}
				this._refreshValue();
			} else {
				if ( this.options.values &amp;&amp; this.options.values.length ) {
					return this._values( index );
				} else {
					return this.value();
				}
			}
		} else {
			return this._values();
		}
	},

	_setOption: function( key, value ) {
		var i,
			valsLength = 0;

		if ( $.isArray( this.options.values ) ) {
			valsLength = this.options.values.length;
		}

		$.Widget.prototype._setOption.apply( this, arguments );

		switch ( key ) {
			case &quot;disabled&quot;:
				if ( value ) {
					this.handles.filter( &quot;.ui-state-focus&quot; ).blur();
					this.handles.removeClass( &quot;ui-state-hover&quot; );
					this.handles.propAttr( &quot;disabled&quot;, true );
					this.element.addClass( &quot;ui-disabled&quot; );
				} else {
					this.handles.propAttr( &quot;disabled&quot;, false );
					this.element.removeClass( &quot;ui-disabled&quot; );
				}
				break;
			case &quot;orientation&quot;:
				this._detectOrientation();
				this.element
					.removeClass( &quot;ui-slider-horizontal ui-slider-vertical&quot; )
					.addClass( &quot;ui-slider-&quot; + this.orientation );
				this._refreshValue();
				break;
			case &quot;value&quot;:
				this._animateOff = true;
				this._refreshValue();
				this._change( null, 0 );
				this._animateOff = false;
				break;
			case &quot;values&quot;:
				this._animateOff = true;
				this._refreshValue();
				for ( i = 0; i </span><span class="xd">&lt; </span><span class="xn">valsLength</span><span class="xd">; i += 1 ) {
					this._change( null, i );
				}
				this._animateOff = false;
				break;
		}
	},

	//internal value getter
	// _value() returns value trimmed by min and max, aligned by step
	_value: function() {
		var val = this.options.value;
		val = this._trimAlignValue( val );

		return val;
	},

	//internal values getter
	// _values() returns array of values trimmed by min and max, aligned by step
	// _values( index ) returns single value trimmed by min and max, aligned by step
	_values: function( index ) {
		var val,
			vals,
			i;

		if ( arguments.length ) {
			val = this.options.values[ index ];
			val = this._trimAlignValue( val );

			return val;
		} else {
			// .slice() creates a copy of the array
			// this copy gets trimmed by min and max and then returned
			vals = this.options.values.slice();
			for ( i = 0; i </span><span class="xd">&lt; </span><span class="xn">vals.length</span><span class="xd">; i+= 1) {
				vals[ i ] = this._trimAlignValue( vals[ i ] );
			}

			return vals;
		}
	},
	
	// returns the step-aligned value that val is closest to, between (inclusive) min and max
	_trimAlignValue: function( val ) {
		if ( val </span><span class="xd">&lt;</span><span class="xd">= </span><span class="xav">this._valueMin()</span><span class="xd"> ) {
			return this._valueMin();
		}
		if ( val &gt;</span>= this._valueMax() ) {
			return this._valueMax();
		}
		var step = ( this.options.step &gt; 0 ) ? this.options.step : 1,
			valModStep = (val - this._valueMin()) % step,
			alignValue = val - valModStep;

		if ( Math.abs(valModStep) * 2 &gt;= step ) {
			alignValue += ( valModStep &gt; 0 ) ? step : ( -step );
		}

		// Since JavaScript has problems with large floats, round
		// the final value to 5 digits after the decimal point (see #4124)
		return parseFloat( alignValue.toFixed(5) );
	},

	_valueMin: function() {
		return this.options.min;
	},

	_valueMax: function() {
		return this.options.max;
	},
	
	_refreshValue: function() {
		var oRange = this.options.range,
			o = this.options,
			self = this,
			animate = ( !this._animateOff ) ? o.animate : false,
			valPercent,
			_set = {},
			lastValPercent,
			value,
			valueMin,
			valueMax;

		if ( this.options.values <span class="xer">&amp;</span><span class="xer">&amp;</span> this.options.values.length ) {
			this.handles.each(function( i, j ) {
				valPercent = ( self.values(i) - self._valueMin() ) / ( self._valueMax() - self._valueMin() ) * 100;
				_set[ self.orientation === &quot;horizontal&quot; ? &quot;left&quot; : &quot;bottom&quot; ] = valPercent + &quot;%&quot;;
				$( this ).stop( 1, 1 )[ animate ? &quot;animate&quot; : &quot;css&quot; ]( _set, o.animate );
				if ( self.options.range === true ) {
					if ( self.orientation === &quot;horizontal&quot; ) {
						if ( i === 0 ) {
							self.range.stop( 1, 1 )[ animate ? &quot;animate&quot; : &quot;css&quot; ]( { left: valPercent + &quot;%&quot; }, o.animate );
						}
						if ( i === 1 ) {
							self.range[ animate ? &quot;animate&quot; : &quot;css&quot; ]( { width: ( valPercent - lastValPercent ) + &quot;%&quot; }, { queue: false, duration: o.animate } );
						}
					} else {
						if ( i === 0 ) {
							self.range.stop( 1, 1 )[ animate ? &quot;animate&quot; : &quot;css&quot; ]( { bottom: ( valPercent ) + &quot;%&quot; }, o.animate );
						}
						if ( i === 1 ) {
							self.range[ animate ? &quot;animate&quot; : &quot;css&quot; ]( { height: ( valPercent - lastValPercent ) + &quot;%&quot; }, { queue: false, duration: o.animate } );
						}
					}
				}
				lastValPercent = valPercent;
			});
		} else {
			value = this.value();
			valueMin = this._valueMin();
			valueMax = this._valueMax();
			valPercent = ( valueMax !== valueMin ) ?
					( value - valueMin ) / ( valueMax - valueMin ) * 100 :
					0;
			_set[ self.orientation === &quot;horizontal&quot; ? &quot;left&quot; : &quot;bottom&quot; ] = valPercent + &quot;%&quot;;
			this.handle.stop( 1, 1 )[ animate ? &quot;animate&quot; : &quot;css&quot; ]( _set, o.animate );

			if ( oRange === &quot;min&quot; <span class="xer">&amp;</span><span class="xer">&amp;</span> this.orientation === &quot;horizontal&quot; ) {
				this.range.stop( 1, 1 )[ animate ? &quot;animate&quot; : &quot;css&quot; ]( { width: valPercent + &quot;%&quot; }, o.animate );
			}
			if ( oRange === &quot;max&quot; <span class="xer">&amp;</span><span class="xer">&amp;</span> this.orientation === &quot;horizontal&quot; ) {
				this.range[ animate ? &quot;animate&quot; : &quot;css&quot; ]( { width: ( 100 - valPercent ) + &quot;%&quot; }, { queue: false, duration: o.animate } );
			}
			if ( oRange === &quot;min&quot; <span class="xer">&amp;</span><span class="xer">&amp;</span> this.orientation === &quot;vertical&quot; ) {
				this.range.stop( 1, 1 )[ animate ? &quot;animate&quot; : &quot;css&quot; ]( { height: valPercent + &quot;%&quot; }, o.animate );
			}
			if ( oRange === &quot;max&quot; <span class="xer">&amp;</span><span class="xer">&amp;</span> this.orientation === &quot;vertical&quot; ) {
				this.range[ animate ? &quot;animate&quot; : &quot;css&quot; ]( { height: ( 100 - valPercent ) + &quot;%&quot; }, { queue: false, duration: o.animate } );
			}
		}
	}

});

$.extend( $.ui.slider, {
	version: &quot;1.8.18&quot;
});

}(jQuery));
/*
 * jQuery UI Tabs 1.8.18
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Tabs
 *
 * Depends:
 *	jquery.ui.core.js
 *	jquery.ui.widget.js
 */
(function( $, undefined ) {

var tabId = 0,
	listId = 0;

function getNextTabId() {
	return ++tabId;
}

function getNextListId() {
	return ++listId;
}

$.widget( &quot;ui.tabs&quot;, {
	options: {
		add: null,
		ajaxOptions: null,
		cache: false,
		cookie: null, // e.g. { expires: 7, path: &#39;/&#39;, domain: &#39;jquery.com&#39;, secure: true }
		collapsible: false,
		disable: null,
		disabled: [],
		enable: null,
		event: &quot;click&quot;,
		fx: null, // e.g. { height: &#39;toggle&#39;, opacity: &#39;toggle&#39;, duration: 200 }
		idPrefix: &quot;ui-tabs-&quot;,
		load: null,
		panelTemplate: &quot;<span class="xd">&lt;</span><span class="xn">div</span><span class="xd">&gt;</span><span class="xd">&lt;/</span><span class="xn">div</span><span class="xd">&gt;</span>&quot;,
		remove: null,
		select: null,
		show: null,
		spinner: &quot;<span class="xd">&lt;</span><span class="xn">em</span><span class="xd">&gt;</span>Loading<span class="xer">&amp;#8230;</span><span class="xd">&lt;/</span><span class="xn">em</span><span class="xd">&gt;</span>&quot;,
		tabTemplate: &quot;<span class="xd">&lt;</span><span class="xn">li</span><span class="xd">&gt;</span><span class="xd">&lt;</span><span class="xn">a </span><span class="xan">href</span><span class="xd">=</span>&#39;<span class="xav">#{href}</span>&#39;<span class="xd">&gt;</span><span class="xd">&lt;</span><span class="xn">span</span><span class="xd">&gt;</span>#{label}<span class="xd">&lt;/</span><span class="xn">span</span><span class="xd">&gt;</span><span class="xd">&lt;/</span><span class="xn">a</span><span class="xd">&gt;</span><span class="xd">&lt;/</span><span class="xn">li</span><span class="xd">&gt;</span>&quot;
	},

	_create: function() {
		this._tabify( true );
	},

	_setOption: function( key, value ) {
		if ( key == &quot;selected&quot; ) {
			if (this.options.collapsible <span class="xer">&amp;</span><span class="xer">&amp;</span> value == this.options.selected ) {
				return;
			}
			this.select( value );
		} else {
			this.options[ key ] = value;
			this._tabify();
		}
	},

	_tabId: function( a ) {
		return a.title <span class="xer">&amp;</span><span class="xer">&amp;</span> a.title.replace( /\s/g, &quot;_&quot; ).replace( /[^\w\u00c0-\uFFFF-]/g, &quot;&quot; ) ||
			this.options.idPrefix + getNextTabId();
	},

	_sanitizeSelector: function( hash ) {
		// we need this because an id may contain a &quot;:&quot;
		return hash.replace( /:/g, &quot;\\:&quot; );
	},

	_cookie: function() {
		var cookie = this.cookie ||
			( this.cookie = this.options.cookie.name || &quot;ui-tabs-&quot; + getNextListId() );
		return $.cookie.apply( null, [ cookie ].concat( $.makeArray( arguments ) ) );
	},

	_ui: function( tab, panel ) {
		return {
			tab: tab,
			panel: panel,
			index: this.anchors.index( tab )
		};
	},

	_cleanup: function() {
		// restore all former loading tabs labels
		this.lis.filter( &quot;.ui-state-processing&quot; )
			.removeClass( &quot;ui-state-processing&quot; )
			.find( &quot;span:data(label.tabs)&quot; )
				.each(function() {
					var el = $( this );
					el.html( el.data( &quot;label.tabs&quot; ) ).removeData( &quot;label.tabs&quot; );
				});
	},

	_tabify: function( init ) {
		var self = this,
			o = this.options,
			fragmentId = /^#.+/; // Safari 2 reports &#39;#&#39; for an empty hash

		this.list = this.element.find( &quot;ol,ul&quot; ).eq( 0 );
		this.lis = $( &quot; &gt; li:has(a[href])&quot;, this.list );
		this.anchors = this.lis.map(function() {
			return $( &quot;a&quot;, this )[ 0 ];
		});
		this.panels = $( [] );

		this.anchors.each(function( i, a ) {
			var href = $( a ).attr( &quot;href&quot; );
			// For dynamically created HTML that contains a hash as href IE <span class="xd">&lt; </span><span class="xn">8 </span><span class="xan">expands</span><span class="xd">
			// such href to the full page url with hash and then misinterprets tab as ajax.
			// Same consideration applies for an added tab with a fragment identifier
			// since a[href=#fragment-identifier] does unexpectedly not match.
			// Thus normalize href attribute...
			var hrefBase = href.split( &quot;#&quot; )[ 0 ],
				baseEl;
			if ( hrefBase &amp;&amp; ( hrefBase === location.toString().split( &quot;#&quot; )[ 0 ] ||
					( baseEl = $( &quot;base&quot; )[ 0 ]) &amp;&amp; hrefBase === baseEl.href ) ) {
				href = a.hash;
				a.href = href;
			}

			// inline tab
			if ( fragmentId.test( href ) ) {
				self.panels = self.panels.add( self.element.find( self._sanitizeSelector( href ) ) );
			// remote tab
			// prevent loading the page itself if href is just &quot;#&quot;
			} else if ( href &amp;&amp; href !== &quot;#&quot; ) {
				// required for restore on destroy
				$.data( a, &quot;href.tabs&quot;, href );

				// TODO until #3808 is fixed strip fragment identifier from url
				// (IE fails to load from such url)
				$.data( a, &quot;load.tabs&quot;, href.replace( /#.*$/, &quot;&quot; ) );

				var id = self._tabId( a );
				a.href = &quot;#&quot; + id;
				var $panel = self.element.find( &quot;#&quot; + id );
				if ( !$panel.length ) {
					$panel = $( o.panelTemplate )
						.attr( &quot;id&quot;, id )
						.addClass( &quot;ui-tabs-panel ui-widget-content ui-corner-bottom&quot; )
						.insertAfter( self.panels[ i - 1 ] || self.list );
					$panel.data( &quot;destroy.tabs&quot;, true );
				}
				self.panels = self.panels.add( $panel );
			// invalid tab href
			} else {
				o.disabled.push( i );
			}
		});

		// initialization from scratch
		if ( init ) {
			// attach necessary classes for styling
			this.element.addClass( &quot;ui-tabs ui-widget ui-widget-content ui-corner-all&quot; );
			this.list.addClass( &quot;ui-tabs-nav ui-helper-reset ui-helper-clearfix ui-widget-header ui-corner-all&quot; );
			this.lis.addClass( &quot;ui-state-default ui-corner-top&quot; );
			this.panels.addClass( &quot;ui-tabs-panel ui-widget-content ui-corner-bottom&quot; );

			// Selected tab
			// use &quot;selected&quot; option or try to retrieve:
			// 1. from fragment identifier in url
			// 2. from cookie
			// 3. from selected class attribute on </span><span class="xd">&lt;</span><span class="xn">li</span><span class="xd">&gt;</span>
			if ( o.selected === undefined ) {
				if ( location.hash ) {
					this.anchors.each(function( i, a ) {
						if ( a.hash == location.hash ) {
							o.selected = i;
							return false;
						}
					});
				}
				if ( typeof o.selected !== &quot;number&quot; <span class="xer">&amp;</span><span class="xer">&amp;</span> o.cookie ) {
					o.selected = parseInt( self._cookie(), 10 );
				}
				if ( typeof o.selected !== &quot;number&quot; <span class="xer">&amp;</span><span class="xer">&amp;</span> this.lis.filter( &quot;.ui-tabs-selected&quot; ).length ) {
					o.selected = this.lis.index( this.lis.filter( &quot;.ui-tabs-selected&quot; ) );
				}
				o.selected = o.selected || ( this.lis.length ? 0 : -1 );
			} else if ( o.selected === null ) { // usage of null is deprecated, TODO remove in next release
				o.selected = -1;
			}

			// sanity check - default to first tab...
			o.selected = ( ( o.selected &gt;= 0 <span class="xer">&amp;</span><span class="xer">&amp;</span> this.anchors[ o.selected ] ) || o.selected <span class="xd">&lt; </span><span class="xn">0 </span><span class="xd">)
				? o.selected
				: 0;

			// Take disabling tabs via class attribute from HTML
			// into account and update option properly.
			// A selected tab cannot become disabled.
			o.disabled = $.unique( o.disabled.concat(
				$.map( this.lis.filter( &quot;.ui-state-disabled&quot; ), function( n, i ) {
					return self.lis.index( n );
				})
			) ).sort();

			if ( $.inArray( o.selected, o.disabled ) != -1 ) {
				o.disabled.splice( $.inArray( o.selected, o.disabled ), 1 );
			}

			// highlight selected tab
			this.panels.addClass( &quot;ui-tabs-hide&quot; );
			this.lis.removeClass( &quot;ui-tabs-selected ui-state-active&quot; );
			// check for length avoids error when initializing empty list
			if ( o.selected &gt;</span>= 0 <span class="xer">&amp;</span><span class="xer">&amp;</span> this.anchors.length ) {
				self.element.find( self._sanitizeSelector( self.anchors[ o.selected ].hash ) ).removeClass( &quot;ui-tabs-hide&quot; );
				this.lis.eq( o.selected ).addClass( &quot;ui-tabs-selected ui-state-active&quot; );

				// seems to be expected behavior that the show callback is fired
				self.element.queue( &quot;tabs&quot;, function() {
					self._trigger( &quot;show&quot;, null,
						self._ui( self.anchors[ o.selected ], self.element.find( self._sanitizeSelector( self.anchors[ o.selected ].hash ) )[ 0 ] ) );
				});

				this.load( o.selected );
			}

			// clean up to avoid memory leaks in certain versions of IE 6
			// TODO: namespace this event
			$( window ).bind( &quot;unload&quot;, function() {
				self.lis.add( self.anchors ).unbind( &quot;.tabs&quot; );
				self.lis = self.anchors = self.panels = null;
			});
		// update selected after add/remove
		} else {
			o.selected = this.lis.index( this.lis.filter( &quot;.ui-tabs-selected&quot; ) );
		}

		// update collapsible
		// TODO: use .toggleClass()
		this.element[ o.collapsible ? &quot;addClass&quot; : &quot;removeClass&quot; ]( &quot;ui-tabs-collapsible&quot; );

		// set or update cookie after init and add/remove respectively
		if ( o.cookie ) {
			this._cookie( o.selected, o.cookie );
		}

		// disable tabs
		for ( var i = 0, li; ( li = this.lis[ i ] ); i++ ) {
			$( li )[ $.inArray( i, o.disabled ) != -1 <span class="xer">&amp;</span><span class="xer">&amp;</span>
				// TODO: use .toggleClass()
				!$( li ).hasClass( &quot;ui-tabs-selected&quot; ) ? &quot;addClass&quot; : &quot;removeClass&quot; ]( &quot;ui-state-disabled&quot; );
		}

		// reset cache if switching from cached to not cached
		if ( o.cache === false ) {
			this.anchors.removeData( &quot;cache.tabs&quot; );
		}

		// remove all handlers before, tabify may run on existing tabs after add or option change
		this.lis.add( this.anchors ).unbind( &quot;.tabs&quot; );

		if ( o.event !== &quot;mouseover&quot; ) {
			var addState = function( state, el ) {
				if ( el.is( &quot;:not(.ui-state-disabled)&quot; ) ) {
					el.addClass( &quot;ui-state-&quot; + state );
				}
			};
			var removeState = function( state, el ) {
				el.removeClass( &quot;ui-state-&quot; + state );
			};
			this.lis.bind( &quot;mouseover.tabs&quot; , function() {
				addState( &quot;hover&quot;, $( this ) );
			});
			this.lis.bind( &quot;mouseout.tabs&quot;, function() {
				removeState( &quot;hover&quot;, $( this ) );
			});
			this.anchors.bind( &quot;focus.tabs&quot;, function() {
				addState( &quot;focus&quot;, $( this ).closest( &quot;li&quot; ) );
			});
			this.anchors.bind( &quot;blur.tabs&quot;, function() {
				removeState( &quot;focus&quot;, $( this ).closest( &quot;li&quot; ) );
			});
		}

		// set up animations
		var hideFx, showFx;
		if ( o.fx ) {
			if ( $.isArray( o.fx ) ) {
				hideFx = o.fx[ 0 ];
				showFx = o.fx[ 1 ];
			} else {
				hideFx = showFx = o.fx;
			}
		}

		// Reset certain styles left over from animation
		// and prevent IE&#39;s ClearType bug...
		function resetStyle( $el, fx ) {
			$el.css( &quot;display&quot;, &quot;&quot; );
			if ( !$.support.opacity <span class="xer">&amp;</span><span class="xer">&amp;</span> fx.opacity ) {
				$el[ 0 ].style.removeAttribute( &quot;filter&quot; );
			}
		}

		// Show a tab...
		var showTab = showFx
			? function( clicked, $show ) {
				$( clicked ).closest( &quot;li&quot; ).addClass( &quot;ui-tabs-selected ui-state-active&quot; );
				$show.hide().removeClass( &quot;ui-tabs-hide&quot; ) // avoid flicker that way
					.animate( showFx, showFx.duration || &quot;normal&quot;, function() {
						resetStyle( $show, showFx );
						self._trigger( &quot;show&quot;, null, self._ui( clicked, $show[ 0 ] ) );
					});
			}
			: function( clicked, $show ) {
				$( clicked ).closest( &quot;li&quot; ).addClass( &quot;ui-tabs-selected ui-state-active&quot; );
				$show.removeClass( &quot;ui-tabs-hide&quot; );
				self._trigger( &quot;show&quot;, null, self._ui( clicked, $show[ 0 ] ) );
			};

		// Hide a tab, $show is optional...
		var hideTab = hideFx
			? function( clicked, $hide ) {
				$hide.animate( hideFx, hideFx.duration || &quot;normal&quot;, function() {
					self.lis.removeClass( &quot;ui-tabs-selected ui-state-active&quot; );
					$hide.addClass( &quot;ui-tabs-hide&quot; );
					resetStyle( $hide, hideFx );
					self.element.dequeue( &quot;tabs&quot; );
				});
			}
			: function( clicked, $hide, $show ) {
				self.lis.removeClass( &quot;ui-tabs-selected ui-state-active&quot; );
				$hide.addClass( &quot;ui-tabs-hide&quot; );
				self.element.dequeue( &quot;tabs&quot; );
			};

		// attach tab event handler, unbind to avoid duplicates from former tabifying...
		this.anchors.bind( o.event + &quot;.tabs&quot;, function() {
			var el = this,
				$li = $(el).closest( &quot;li&quot; ),
				$hide = self.panels.filter( &quot;:not(.ui-tabs-hide)&quot; ),
				$show = self.element.find( self._sanitizeSelector( el.hash ) );

			// If tab is already selected and not collapsible or tab disabled or
			// or is already loading or click callback returns false stop here.
			// Check if click handler returns false last so that it is not executed
			// for a disabled or loading tab!
			if ( ( $li.hasClass( &quot;ui-tabs-selected&quot; ) <span class="xer">&amp;</span><span class="xer">&amp;</span> !o.collapsible) ||
				$li.hasClass( &quot;ui-state-disabled&quot; ) ||
				$li.hasClass( &quot;ui-state-processing&quot; ) ||
				self.panels.filter( &quot;:animated&quot; ).length ||
				self._trigger( &quot;select&quot;, null, self._ui( this, $show[ 0 ] ) ) === false ) {
				this.blur();
				return false;
			}

			o.selected = self.anchors.index( this );

			self.abort();

			// if tab may be closed
			if ( o.collapsible ) {
				if ( $li.hasClass( &quot;ui-tabs-selected&quot; ) ) {
					o.selected = -1;

					if ( o.cookie ) {
						self._cookie( o.selected, o.cookie );
					}

					self.element.queue( &quot;tabs&quot;, function() {
						hideTab( el, $hide );
					}).dequeue( &quot;tabs&quot; );

					this.blur();
					return false;
				} else if ( !$hide.length ) {
					if ( o.cookie ) {
						self._cookie( o.selected, o.cookie );
					}

					self.element.queue( &quot;tabs&quot;, function() {
						showTab( el, $show );
					});

					// TODO make passing in node possible, see also http://dev.jqueryui.com/ticket/3171
					self.load( self.anchors.index( this ) );

					this.blur();
					return false;
				}
			}

			if ( o.cookie ) {
				self._cookie( o.selected, o.cookie );
			}

			// show new tab
			if ( $show.length ) {
				if ( $hide.length ) {
					self.element.queue( &quot;tabs&quot;, function() {
						hideTab( el, $hide );
					});
				}
				self.element.queue( &quot;tabs&quot;, function() {
					showTab( el, $show );
				});

				self.load( self.anchors.index( this ) );
			} else {
				throw &quot;jQuery UI Tabs: Mismatching fragment identifier.&quot;;
			}

			// Prevent IE from keeping other link focussed when using the back button
			// and remove dotted border from clicked link. This is controlled via CSS
			// in modern browsers; blur() removes focus from address bar in Firefox
			// which can become a usability and annoying problem with tabs(&#39;rotate&#39;).
			if ( $.browser.msie ) {
				this.blur();
			}
		});

		// disable click in any case
		this.anchors.bind( &quot;click.tabs&quot;, function(){
			return false;
		});
	},

    _getIndex: function( index ) {
		// meta-function to give users option to provide a href string instead of a numerical index.
		// also sanitizes numerical indexes to valid values.
		if ( typeof index == &quot;string&quot; ) {
			index = this.anchors.index( this.anchors.filter( &quot;[href$=&quot; + index + &quot;]&quot; ) );
		}

		return index;
	},

	destroy: function() {
		var o = this.options;

		this.abort();

		this.element
			.unbind( &quot;.tabs&quot; )
			.removeClass( &quot;ui-tabs ui-widget ui-widget-content ui-corner-all ui-tabs-collapsible&quot; )
			.removeData( &quot;tabs&quot; );

		this.list.removeClass( &quot;ui-tabs-nav ui-helper-reset ui-helper-clearfix ui-widget-header ui-corner-all&quot; );

		this.anchors.each(function() {
			var href = $.data( this, &quot;href.tabs&quot; );
			if ( href ) {
				this.href = href;
			}
			var $this = $( this ).unbind( &quot;.tabs&quot; );
			$.each( [ &quot;href&quot;, &quot;load&quot;, &quot;cache&quot; ], function( i, prefix ) {
				$this.removeData( prefix + &quot;.tabs&quot; );
			});
		});

		this.lis.unbind( &quot;.tabs&quot; ).add( this.panels ).each(function() {
			if ( $.data( this, &quot;destroy.tabs&quot; ) ) {
				$( this ).remove();
			} else {
				$( this ).removeClass([
					&quot;ui-state-default&quot;,
					&quot;ui-corner-top&quot;,
					&quot;ui-tabs-selected&quot;,
					&quot;ui-state-active&quot;,
					&quot;ui-state-hover&quot;,
					&quot;ui-state-focus&quot;,
					&quot;ui-state-disabled&quot;,
					&quot;ui-tabs-panel&quot;,
					&quot;ui-widget-content&quot;,
					&quot;ui-corner-bottom&quot;,
					&quot;ui-tabs-hide&quot;
				].join( &quot; &quot; ) );
			}
		});

		if ( o.cookie ) {
			this._cookie( null, o.cookie );
		}

		return this;
	},

	add: function( url, label, index ) {
		if ( index === undefined ) {
			index = this.anchors.length;
		}

		var self = this,
			o = this.options,
			$li = $( o.tabTemplate.replace( /#\{href\}/g, url ).replace( /#\{label\}/g, label ) ),
			id = !url.indexOf( &quot;#&quot; ) ? url.replace( &quot;#&quot;, &quot;&quot; ) : this._tabId( $( &quot;a&quot;, $li )[ 0 ] );

		$li.addClass( &quot;ui-state-default ui-corner-top&quot; ).data( &quot;destroy.tabs&quot;, true );

		// try to find an existing element before creating a new one
		var $panel = self.element.find( &quot;#&quot; + id );
		if ( !$panel.length ) {
			$panel = $( o.panelTemplate )
				.attr( &quot;id&quot;, id )
				.data( &quot;destroy.tabs&quot;, true );
		}
		$panel.addClass( &quot;ui-tabs-panel ui-widget-content ui-corner-bottom ui-tabs-hide&quot; );

		if ( index &gt;= this.lis.length ) {
			$li.appendTo( this.list );
			$panel.appendTo( this.list[ 0 ].parentNode );
		} else {
			$li.insertBefore( this.lis[ index ] );
			$panel.insertBefore( this.panels[ index ] );
		}

		o.disabled = $.map( o.disabled, function( n, i ) {
			return n &gt;= index ? ++n : n;
		});

		this._tabify();

		if ( this.anchors.length == 1 ) {
			o.selected = 0;
			$li.addClass( &quot;ui-tabs-selected ui-state-active&quot; );
			$panel.removeClass( &quot;ui-tabs-hide&quot; );
			this.element.queue( &quot;tabs&quot;, function() {
				self._trigger( &quot;show&quot;, null, self._ui( self.anchors[ 0 ], self.panels[ 0 ] ) );
			});

			this.load( 0 );
		}

		this._trigger( &quot;add&quot;, null, this._ui( this.anchors[ index ], this.panels[ index ] ) );
		return this;
	},

	remove: function( index ) {
		index = this._getIndex( index );
		var o = this.options,
			$li = this.lis.eq( index ).remove(),
			$panel = this.panels.eq( index ).remove();

		// If selected tab was removed focus tab to the right or
		// in case the last tab was removed the tab to the left.
		if ( $li.hasClass( &quot;ui-tabs-selected&quot; ) <span class="xer">&amp;</span><span class="xer">&amp;</span> this.anchors.length &gt; 1) {
			this.select( index + ( index + 1 <span class="xd">&lt; </span><span class="xn">this.anchors.length </span><span class="xd">? 1 : -1 ) );
		}

		o.disabled = $.map(
			$.grep( o.disabled, function(n, i) {
				return n != index;
			}),
			function( n, i ) {
				return n &gt;</span>= index ? --n : n;
			});

		this._tabify();

		this._trigger( &quot;remove&quot;, null, this._ui( $li.find( &quot;a&quot; )[ 0 ], $panel[ 0 ] ) );
		return this;
	},

	enable: function( index ) {
		index = this._getIndex( index );
		var o = this.options;
		if ( $.inArray( index, o.disabled ) == -1 ) {
			return;
		}

		this.lis.eq( index ).removeClass( &quot;ui-state-disabled&quot; );
		o.disabled = $.grep( o.disabled, function( n, i ) {
			return n != index;
		});

		this._trigger( &quot;enable&quot;, null, this._ui( this.anchors[ index ], this.panels[ index ] ) );
		return this;
	},

	disable: function( index ) {
		index = this._getIndex( index );
		var self = this, o = this.options;
		// cannot disable already selected tab
		if ( index != o.selected ) {
			this.lis.eq( index ).addClass( &quot;ui-state-disabled&quot; );

			o.disabled.push( index );
			o.disabled.sort();

			this._trigger( &quot;disable&quot;, null, this._ui( this.anchors[ index ], this.panels[ index ] ) );
		}

		return this;
	},

	select: function( index ) {
		index = this._getIndex( index );
		if ( index == -1 ) {
			if ( this.options.collapsible <span class="xer">&amp;</span><span class="xer">&amp;</span> this.options.selected != -1 ) {
				index = this.options.selected;
			} else {
				return this;
			}
		}
		this.anchors.eq( index ).trigger( this.options.event + &quot;.tabs&quot; );
		return this;
	},

	load: function( index ) {
		index = this._getIndex( index );
		var self = this,
			o = this.options,
			a = this.anchors.eq( index )[ 0 ],
			url = $.data( a, &quot;load.tabs&quot; );

		this.abort();

		// not remote or from cache
		if ( !url || this.element.queue( &quot;tabs&quot; ).length !== 0 <span class="xer">&amp;</span><span class="xer">&amp;</span> $.data( a, &quot;cache.tabs&quot; ) ) {
			this.element.dequeue( &quot;tabs&quot; );
			return;
		}

		// load remote from here on
		this.lis.eq( index ).addClass( &quot;ui-state-processing&quot; );

		if ( o.spinner ) {
			var span = $( &quot;span&quot;, a );
			span.data( &quot;label.tabs&quot;, span.html() ).html( o.spinner );
		}

		this.xhr = $.ajax( $.extend( {}, o.ajaxOptions, {
			url: url,
			success: function( r, s ) {
				self.element.find( self._sanitizeSelector( a.hash ) ).html( r );

				// take care of tab labels
				self._cleanup();

				if ( o.cache ) {
					$.data( a, &quot;cache.tabs&quot;, true );
				}

				self._trigger( &quot;load&quot;, null, self._ui( self.anchors[ index ], self.panels[ index ] ) );
				try {
					o.ajaxOptions.success( r, s );
				}
				catch ( e ) {}
			},
			error: function( xhr, s, e ) {
				// take care of tab labels
				self._cleanup();

				self._trigger( &quot;load&quot;, null, self._ui( self.anchors[ index ], self.panels[ index ] ) );
				try {
					// Passing index avoid a race condition when this method is
					// called after the user has selected another tab.
					// Pass the anchor that initiated this request allows
					// loadError to manipulate the tab content panel via $(a.hash)
					o.ajaxOptions.error( xhr, s, index, a );
				}
				catch ( e ) {}
			}
		} ) );

		// last, so that load event is fired before show...
		self.element.dequeue( &quot;tabs&quot; );

		return this;
	},

	abort: function() {
		// stop possibly running animations
		this.element.queue( [] );
		this.panels.stop( false, true );

		// &quot;tabs&quot; queue must not contain more than two elements,
		// which are the callbacks for the latest clicked tab...
		this.element.queue( &quot;tabs&quot;, this.element.queue( &quot;tabs&quot; ).splice( -2, 2 ) );

		// terminate pending requests from other tabs
		if ( this.xhr ) {
			this.xhr.abort();
			delete this.xhr;
		}

		// take care of tab labels
		this._cleanup();
		return this;
	},

	url: function( index, url ) {
		this.anchors.eq( index ).removeData( &quot;cache.tabs&quot; ).data( &quot;load.tabs&quot;, url );
		return this;
	},

	length: function() {
		return this.anchors.length;
	}
});

$.extend( $.ui.tabs, {
	version: &quot;1.8.18&quot;
});

/*
 * Tabs Extensions
 */

/*
 * Rotate
 */
$.extend( $.ui.tabs.prototype, {
	rotation: null,
	rotate: function( ms, continuing ) {
		var self = this,
			o = this.options;

		var rotate = self._rotate || ( self._rotate = function( e ) {
			clearTimeout( self.rotation );
			self.rotation = setTimeout(function() {
				var t = o.selected;
				self.select( ++t <span class="xd">&lt; </span><span class="xn">self.anchors.length </span><span class="xd">? t : 0 );
			}, ms );
			
			if ( e ) {
				e.stopPropagation();
			}
		});

		var stop = self._unrotate || ( self._unrotate = !continuing
			? function(e) {
				if (e.clientX) { // in case of a true click
					self.rotate(null);
				}
			}
			: function( e ) {
				t = o.selected;
				rotate();
			});

		// start rotation
		if ( ms ) {
			this.element.bind( &quot;tabsshow&quot;, rotate );
			this.anchors.bind( o.event + &quot;.tabs&quot;, stop );
			rotate();
		// stop rotation
		} else {
			clearTimeout( self.rotation );
			this.element.unbind( &quot;tabsshow&quot;, rotate );
			this.anchors.unbind( o.event + &quot;.tabs&quot;, stop );
			delete this._rotate;
			delete this._unrotate;
		}

		return this;
	}
});

})( jQuery );
/*
 * jQuery UI Datepicker 1.8.18
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Datepicker
 *
 * Depends:
 *	jquery.ui.core.js
 */
(function( $, undefined ) {

$.extend($.ui, { datepicker: { version: &quot;1.8.18&quot; } });

var PROP_NAME = &#39;datepicker&#39;;
var dpuuid = new Date().getTime();
var instActive;

/* Date picker manager.
   Use the singleton instance of this class, $.datepicker, to interact with the date picker.
   Settings for (groups of) date pickers are maintained in an instance object,
   allowing multiple different settings on the same page. */

function Datepicker() {
	this.debug = false; // Change this to true to start debugging
	this._curInst = null; // The current instance in use
	this._keyEvent = false; // If the last event was a key event
	this._disabledInputs = []; // List of date picker inputs that have been disabled
	this._datepickerShowing = false; // True if the popup picker is showing , false if not
	this._inDialog = false; // True if showing within a &quot;dialog&quot;, false if not
	this._mainDivId = &#39;ui-datepicker-div&#39;; // The ID of the main datepicker division
	this._inlineClass = &#39;ui-datepicker-inline&#39;; // The name of the inline marker class
	this._appendClass = &#39;ui-datepicker-append&#39;; // The name of the append marker class
	this._triggerClass = &#39;ui-datepicker-trigger&#39;; // The name of the trigger marker class
	this._dialogClass = &#39;ui-datepicker-dialog&#39;; // The name of the dialog marker class
	this._disableClass = &#39;ui-datepicker-disabled&#39;; // The name of the disabled covering marker class
	this._unselectableClass = &#39;ui-datepicker-unselectable&#39;; // The name of the unselectable cell marker class
	this._currentClass = &#39;ui-datepicker-current-day&#39;; // The name of the current day marker class
	this._dayOverClass = &#39;ui-datepicker-days-cell-over&#39;; // The name of the day hover marker class
	this.regional = []; // Available regional settings, indexed by language code
	this.regional[&#39;&#39;] = { // Default regional settings
		closeText: &#39;Done&#39;, // Display text for close link
		prevText: &#39;Prev&#39;, // Display text for previous month link
		nextText: &#39;Next&#39;, // Display text for next month link
		currentText: &#39;Today&#39;, // Display text for current month link
		monthNames: [&#39;January&#39;,&#39;February&#39;,&#39;March&#39;,&#39;April&#39;,&#39;May&#39;,&#39;June&#39;,
			&#39;July&#39;,&#39;August&#39;,&#39;September&#39;,&#39;October&#39;,&#39;November&#39;,&#39;December&#39;], // Names of months for drop-down and formatting
		monthNamesShort: [&#39;Jan&#39;, &#39;Feb&#39;, &#39;Mar&#39;, &#39;Apr&#39;, &#39;May&#39;, &#39;Jun&#39;, &#39;Jul&#39;, &#39;Aug&#39;, &#39;Sep&#39;, &#39;Oct&#39;, &#39;Nov&#39;, &#39;Dec&#39;], // For formatting
		dayNames: [&#39;Sunday&#39;, &#39;Monday&#39;, &#39;Tuesday&#39;, &#39;Wednesday&#39;, &#39;Thursday&#39;, &#39;Friday&#39;, &#39;Saturday&#39;], // For formatting
		dayNamesShort: [&#39;Sun&#39;, &#39;Mon&#39;, &#39;Tue&#39;, &#39;Wed&#39;, &#39;Thu&#39;, &#39;Fri&#39;, &#39;Sat&#39;], // For formatting
		dayNamesMin: [&#39;Su&#39;,&#39;Mo&#39;,&#39;Tu&#39;,&#39;We&#39;,&#39;Th&#39;,&#39;Fr&#39;,&#39;Sa&#39;], // Column headings for days starting at Sunday
		weekHeader: &#39;Wk&#39;, // Column header for week of the year
		dateFormat: &#39;mm/dd/yy&#39;, // See format options on parseDate
		firstDay: 0, // The first day of the week, Sun = 0, Mon = 1, ...
		isRTL: false, // True if right-to-left language, false if left-to-right
		showMonthAfterYear: false, // True if the year select precedes month, false for month then year
		yearSuffix: &#39;&#39; // Additional text to append to the year in the month headers
	};
	this._defaults = { // Global defaults for all the date picker instances
		showOn: &#39;focus&#39;, // &#39;focus&#39; for popup on focus,
			// &#39;button&#39; for trigger button, or &#39;both&#39; for either
		showAnim: &#39;fadeIn&#39;, // Name of jQuery animation for popup
		showOptions: {}, // Options for enhanced animations
		defaultDate: null, // Used when field is blank: actual date,
			// +/-number for offset from today, null for today
		appendText: &#39;&#39;, // Display text following the input box, e.g. showing the format
		buttonText: &#39;...&#39;, // Text for trigger button
		buttonImage: &#39;&#39;, // URL for trigger button image
		buttonImageOnly: false, // True if the image appears alone, false if it appears on a button
		hideIfNoPrevNext: false, // True to hide next/previous month links
			// if not applicable, false to just disable them
		navigationAsDateFormat: false, // True if date formatting applied to prev/today/next links
		gotoCurrent: false, // True if today link goes back to current selection instead
		changeMonth: false, // True if month can be selected directly, false if only prev/next
		changeYear: false, // True if year can be selected directly, false if only prev/next
		yearRange: &#39;c-10:c+10&#39;, // Range of years to display in drop-down,
			// either relative to today&#39;s year (-nn:+nn), relative to currently displayed year
			// (c-nn:c+nn), absolute (nnnn:nnnn), or a combination of the above (nnnn:-n)
		showOtherMonths: false, // True to show dates in other months, false to leave blank
		selectOtherMonths: false, // True to allow selection of dates in other months, false for unselectable
		showWeek: false, // True to show week of the year, false to not show it
		calculateWeek: this.iso8601Week, // How to calculate the week of the year,
			// takes a Date and returns the number of the week for it
		shortYearCutoff: &#39;+10&#39;, // Short year values </span><span class="xd">&lt; </span><span class="xn">this </span><span class="xan">are </span><span class="xan">in </span><span class="xan">the </span><span class="xan">current </span><span class="xan">century</span><span class="xd">,
			// &gt;</span> this are in the previous century,
			// string value starting with &#39;+&#39; for current year + value
		minDate: null, // The earliest selectable date, or null for no limit
		maxDate: null, // The latest selectable date, or null for no limit
		duration: &#39;fast&#39;, // Duration of display/closure
		beforeShowDay: null, // Function that takes a date and returns an array with
			// [0] = true if selectable, false if not, [1] = custom CSS class name(s) or &#39;&#39;,
			// [2] = cell title (optional), e.g. $.datepicker.noWeekends
		beforeShow: null, // Function that takes an input field and
			// returns a set of custom settings for the date picker
		onSelect: null, // Define a callback function when a date is selected
		onChangeMonthYear: null, // Define a callback function when the month or year is changed
		onClose: null, // Define a callback function when the datepicker is closed
		numberOfMonths: 1, // Number of months to show at a time
		showCurrentAtPos: 0, // The position in multipe months at which to show the current month (starting at 0)
		stepMonths: 1, // Number of months to step back/forward
		stepBigMonths: 12, // Number of months to step back/forward for the big links
		altField: &#39;&#39;, // Selector for an alternate field to store selected dates into
		altFormat: &#39;&#39;, // The date format to use for the alternate field
		constrainInput: true, // The input is constrained by the current date format
		showButtonPanel: false, // True to show button panel, false to not show it
		autoSize: false, // True to size the input for the date format, false to leave as is
		disabled: false // The initial disabled state
	};
	$.extend(this._defaults, this.regional[&#39;&#39;]);
	this.dpDiv = bindHover($(&#39;<span class="xd">&lt;</span><span class="xn">div </span><span class="xan">id</span><span class="xd">=</span>&quot;<span class="xav">&#39; + this._mainDivId + &#39;</span>&quot; <span class="xan">class</span><span class="xd">=</span>&quot;<span class="xav">ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all</span>&quot;<span class="xd">&gt;</span><span class="xd">&lt;/</span><span class="xn">div</span><span class="xd">&gt;</span>&#39;));
}

$.extend(Datepicker.prototype, {
	/* Class name added to elements to indicate already configured with a date picker. */
	markerClassName: &#39;hasDatepicker&#39;,
	
	//Keep track of the maximum number of rows displayed (see #7043)
	maxRows: 4,

	/* Debug logging (if enabled). */
	log: function () {
		if (this.debug)
			console.log.apply(&#39;&#39;, arguments);
	},
	
	// TODO rename to &quot;widget&quot; when switching to widget factory
	_widgetDatepicker: function() {
		return this.dpDiv;
	},

	/* Override the default settings for all instances of the date picker.
	   @param  settings  object - the new settings to use as defaults (anonymous object)
	   @return the manager object */
	setDefaults: function(settings) {
		extendRemove(this._defaults, settings || {});
		return this;
	},

	/* Attach the date picker to a jQuery selection.
	   @param  target    element - the target input field or division or span
	   @param  settings  object - the new settings to use for this date picker instance (anonymous) */
	_attachDatepicker: function(target, settings) {
		// check for settings on the control itself - in namespace &#39;date:&#39;
		var inlineSettings = null;
		for (var attrName in this._defaults) {
			var attrValue = target.getAttribute(&#39;date:&#39; + attrName);
			if (attrValue) {
				inlineSettings = inlineSettings || {};
				try {
					inlineSettings[attrName] = eval(attrValue);
				} catch (err) {
					inlineSettings[attrName] = attrValue;
				}
			}
		}
		var nodeName = target.nodeName.toLowerCase();
		var inline = (nodeName == &#39;div&#39; || nodeName == &#39;span&#39;);
		if (!target.id) {
			this.uuid += 1;
			target.id = &#39;dp&#39; + this.uuid;
		}
		var inst = this._newInst($(target), inline);
		inst.settings = $.extend({}, settings || {}, inlineSettings || {});
		if (nodeName == &#39;input&#39;) {
			this._connectDatepicker(target, inst);
		} else if (inline) {
			this._inlineDatepicker(target, inst);
		}
	},

	/* Create a new instance object. */
	_newInst: function(target, inline) {
		var id = target[0].id.replace(/([^A-Za-z0-9_-])/g, &#39;\\\\$1&#39;); // escape jQuery meta chars
		return {id: id, input: target, // associated target
			selectedDay: 0, selectedMonth: 0, selectedYear: 0, // current selection
			drawMonth: 0, drawYear: 0, // month being drawn
			inline: inline, // is datepicker inline or not
			dpDiv: (!inline ? this.dpDiv : // presentation div
			bindHover($(&#39;<span class="xd">&lt;</span><span class="xn">div </span><span class="xan">class</span><span class="xd">=</span>&quot;<span class="xav">&#39; + this._inlineClass + &#39; ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all</span>&quot;<span class="xd">&gt;</span><span class="xd">&lt;/</span><span class="xn">div</span><span class="xd">&gt;</span>&#39;)))};
	},

	/* Attach the date picker to an input field. */
	_connectDatepicker: function(target, inst) {
		var input = $(target);
		inst.append = $([]);
		inst.trigger = $([]);
		if (input.hasClass(this.markerClassName))
			return;
		this._attachments(input, inst);
		input.addClass(this.markerClassName).keydown(this._doKeyDown).
			keypress(this._doKeyPress).keyup(this._doKeyUp).
			bind(&quot;setData.datepicker&quot;, function(event, key, value) {
				inst.settings[key] = value;
			}).bind(&quot;getData.datepicker&quot;, function(event, key) {
				return this._get(inst, key);
			});
		this._autoSize(inst);
		$.data(target, PROP_NAME, inst);
		//If disabled option is true, disable the datepicker once it has been attached to the input (see ticket #5665)
		if( inst.settings.disabled ) {
			this._disableDatepicker( target );
		}
	},

	/* Make attachments based on settings. */
	_attachments: function(input, inst) {
		var appendText = this._get(inst, &#39;appendText&#39;);
		var isRTL = this._get(inst, &#39;isRTL&#39;);
		if (inst.append)
			inst.append.remove();
		if (appendText) {
			inst.append = $(&#39;<span class="xd">&lt;</span><span class="xn">span </span><span class="xan">class</span><span class="xd">=</span>&quot;<span class="xav">&#39; + this._appendClass + &#39;</span>&quot;<span class="xd">&gt;</span>&#39; + appendText + &#39;<span class="xd">&lt;/</span><span class="xn">span</span><span class="xd">&gt;</span>&#39;);
			input[isRTL ? &#39;before&#39; : &#39;after&#39;](inst.append);
		}
		input.unbind(&#39;focus&#39;, this._showDatepicker);
		if (inst.trigger)
			inst.trigger.remove();
		var showOn = this._get(inst, &#39;showOn&#39;);
		if (showOn == &#39;focus&#39; || showOn == &#39;both&#39;) // pop-up date picker when in the marked field
			input.focus(this._showDatepicker);
		if (showOn == &#39;button&#39; || showOn == &#39;both&#39;) { // pop-up date picker when button clicked
			var buttonText = this._get(inst, &#39;buttonText&#39;);
			var buttonImage = this._get(inst, &#39;buttonImage&#39;);
			inst.trigger = $(this._get(inst, &#39;buttonImageOnly&#39;) ?
				$(&#39;<span class="xd">&lt;</span><span class="xn">img</span><span class="xd">/&gt;</span>&#39;).addClass(this._triggerClass).
					attr({ src: buttonImage, alt: buttonText, title: buttonText }) :
				$(&#39;<span class="xd">&lt;</span><span class="xn">button </span><span class="xan">type</span><span class="xd">=</span>&quot;<span class="xav">button</span>&quot;<span class="xd">&gt;</span><span class="xd">&lt;/</span><span class="xn">button</span><span class="xd">&gt;</span>&#39;).addClass(this._triggerClass).
					html(buttonImage == &#39;&#39; ? buttonText : $(&#39;<span class="xd">&lt;</span><span class="xn">img</span><span class="xd">/&gt;</span>&#39;).attr(
					{ src:buttonImage, alt:buttonText, title:buttonText })));
			input[isRTL ? &#39;before&#39; : &#39;after&#39;](inst.trigger);
			inst.trigger.click(function() {
				if ($.datepicker._datepickerShowing <span class="xer">&amp;</span><span class="xer">&amp;</span> $.datepicker._lastInput == input[0])
					$.datepicker._hideDatepicker();
				else if ($.datepicker._datepickerShowing <span class="xer">&amp;</span><span class="xer">&amp;</span> $.datepicker._lastInput != input[0]) {
					$.datepicker._hideDatepicker(); 
					$.datepicker._showDatepicker(input[0]);
				} else
					$.datepicker._showDatepicker(input[0]);
				return false;
			});
		}
	},

	/* Apply the maximum length for the date format. */
	_autoSize: function(inst) {
		if (this._get(inst, &#39;autoSize&#39;) <span class="xer">&amp;</span><span class="xer">&amp;</span> !inst.inline) {
			var date = new Date(2009, 12 - 1, 20); // Ensure double digits
			var dateFormat = this._get(inst, &#39;dateFormat&#39;);
			if (dateFormat.match(/[DM]/)) {
				var findMax = function(names) {
					var max = 0;
					var maxI = 0;
					for (var i = 0; i <span class="xd">&lt; </span><span class="xn">names.length</span><span class="xd">; i++) {
						if (names[i].length &gt;</span> max) {
							max = names[i].length;
							maxI = i;
						}
					}
					return maxI;
				};
				date.setMonth(findMax(this._get(inst, (dateFormat.match(/MM/) ?
					&#39;monthNames&#39; : &#39;monthNamesShort&#39;))));
				date.setDate(findMax(this._get(inst, (dateFormat.match(/DD/) ?
					&#39;dayNames&#39; : &#39;dayNamesShort&#39;))) + 20 - date.getDay());
			}
			inst.input.attr(&#39;size&#39;, this._formatDate(inst, date).length);
		}
	},

	/* Attach an inline date picker to a div. */
	_inlineDatepicker: function(target, inst) {
		var divSpan = $(target);
		if (divSpan.hasClass(this.markerClassName))
			return;
		divSpan.addClass(this.markerClassName).append(inst.dpDiv).
			bind(&quot;setData.datepicker&quot;, function(event, key, value){
				inst.settings[key] = value;
			}).bind(&quot;getData.datepicker&quot;, function(event, key){
				return this._get(inst, key);
			});
		$.data(target, PROP_NAME, inst);
		this._setDate(inst, this._getDefaultDate(inst), true);
		this._updateDatepicker(inst);
		this._updateAlternate(inst);
		//If disabled option is true, disable the datepicker before showing it (see ticket #5665)
		if( inst.settings.disabled ) {
			this._disableDatepicker( target );
		}
		// Set display:block in place of inst.dpDiv.show() which won&#39;t work on disconnected elements
		// http://bugs.jqueryui.com/ticket/7552 - A Datepicker created on a detached div has zero height
		inst.dpDiv.css( &quot;display&quot;, &quot;block&quot; );
	},

	/* Pop-up the date picker in a &quot;dialog&quot; box.
	   @param  input     element - ignored
	   @param  date      string or Date - the initial date to display
	   @param  onSelect  function - the function to call when a date is selected
	   @param  settings  object - update the dialog date picker instance&#39;s settings (anonymous object)
	   @param  pos       int[2] - coordinates for the dialog&#39;s position within the screen or
	                     event - with x/y coordinates or
	                     leave empty for default (screen centre)
	   @return the manager object */
	_dialogDatepicker: function(input, date, onSelect, settings, pos) {
		var inst = this._dialogInst; // internal instance
		if (!inst) {
			this.uuid += 1;
			var id = &#39;dp&#39; + this.uuid;
			this._dialogInput = $(&#39;<span class="xd">&lt;</span><span class="xn">input </span><span class="xan">type</span><span class="xd">=</span>&quot;<span class="xav">text</span>&quot; <span class="xan">id</span><span class="xd">=</span>&quot;<span class="xav">&#39; + id +
				&#39;</span>&quot; <span class="xan">style</span><span class="xd">=</span>&quot;<span class="xav">position: absolute; top: -100px; width: 0px; z-index: -10;</span>&quot;<span class="xd">/&gt;</span>&#39;);
			this._dialogInput.keydown(this._doKeyDown);
			$(&#39;body&#39;).append(this._dialogInput);
			inst = this._dialogInst = this._newInst(this._dialogInput, false);
			inst.settings = {};
			$.data(this._dialogInput[0], PROP_NAME, inst);
		}
		extendRemove(inst.settings, settings || {});
		date = (date <span class="xer">&amp;</span><span class="xer">&amp;</span> date.constructor == Date ? this._formatDate(inst, date) : date);
		this._dialogInput.val(date);

		this._pos = (pos ? (pos.length ? pos : [pos.pageX, pos.pageY]) : null);
		if (!this._pos) {
			var browserWidth = document.documentElement.clientWidth;
			var browserHeight = document.documentElement.clientHeight;
			var scrollX = document.documentElement.scrollLeft || document.body.scrollLeft;
			var scrollY = document.documentElement.scrollTop || document.body.scrollTop;
			this._pos = // should use actual width/height below
				[(browserWidth / 2) - 100 + scrollX, (browserHeight / 2) - 150 + scrollY];
		}

		// move input on screen for focus, but hidden behind dialog
		this._dialogInput.css(&#39;left&#39;, (this._pos[0] + 20) + &#39;px&#39;).css(&#39;top&#39;, this._pos[1] + &#39;px&#39;);
		inst.settings.onSelect = onSelect;
		this._inDialog = true;
		this.dpDiv.addClass(this._dialogClass);
		this._showDatepicker(this._dialogInput[0]);
		if ($.blockUI)
			$.blockUI(this.dpDiv);
		$.data(this._dialogInput[0], PROP_NAME, inst);
		return this;
	},

	/* Detach a datepicker from its control.
	   @param  target    element - the target input field or division or span */
	_destroyDatepicker: function(target) {
		var $target = $(target);
		var inst = $.data(target, PROP_NAME);
		if (!$target.hasClass(this.markerClassName)) {
			return;
		}
		var nodeName = target.nodeName.toLowerCase();
		$.removeData(target, PROP_NAME);
		if (nodeName == &#39;input&#39;) {
			inst.append.remove();
			inst.trigger.remove();
			$target.removeClass(this.markerClassName).
				unbind(&#39;focus&#39;, this._showDatepicker).
				unbind(&#39;keydown&#39;, this._doKeyDown).
				unbind(&#39;keypress&#39;, this._doKeyPress).
				unbind(&#39;keyup&#39;, this._doKeyUp);
		} else if (nodeName == &#39;div&#39; || nodeName == &#39;span&#39;)
			$target.removeClass(this.markerClassName).empty();
	},

	/* Enable the date picker to a jQuery selection.
	   @param  target    element - the target input field or division or span */
	_enableDatepicker: function(target) {
		var $target = $(target);
		var inst = $.data(target, PROP_NAME);
		if (!$target.hasClass(this.markerClassName)) {
			return;
		}
		var nodeName = target.nodeName.toLowerCase();
		if (nodeName == &#39;input&#39;) {
			target.disabled = false;
			inst.trigger.filter(&#39;button&#39;).
				each(function() { this.disabled = false; }).end().
				filter(&#39;img&#39;).css({opacity: &#39;1.0&#39;, cursor: &#39;&#39;});
		}
		else if (nodeName == &#39;div&#39; || nodeName == &#39;span&#39;) {
			var inline = $target.children(&#39;.&#39; + this._inlineClass);
			inline.children().removeClass(&#39;ui-state-disabled&#39;);
			inline.find(&quot;select.ui-datepicker-month, select.ui-datepicker-year&quot;).
				removeAttr(&quot;disabled&quot;);
		}
		this._disabledInputs = $.map(this._disabledInputs,
			function(value) { return (value == target ? null : value); }); // delete entry
	},

	/* Disable the date picker to a jQuery selection.
	   @param  target    element - the target input field or division or span */
	_disableDatepicker: function(target) {
		var $target = $(target);
		var inst = $.data(target, PROP_NAME);
		if (!$target.hasClass(this.markerClassName)) {
			return;
		}
		var nodeName = target.nodeName.toLowerCase();
		if (nodeName == &#39;input&#39;) {
			target.disabled = true;
			inst.trigger.filter(&#39;button&#39;).
				each(function() { this.disabled = true; }).end().
				filter(&#39;img&#39;).css({opacity: &#39;0.5&#39;, cursor: &#39;default&#39;});
		}
		else if (nodeName == &#39;div&#39; || nodeName == &#39;span&#39;) {
			var inline = $target.children(&#39;.&#39; + this._inlineClass);
			inline.children().addClass(&#39;ui-state-disabled&#39;);
			inline.find(&quot;select.ui-datepicker-month, select.ui-datepicker-year&quot;).
				attr(&quot;disabled&quot;, &quot;disabled&quot;);
		}
		this._disabledInputs = $.map(this._disabledInputs,
			function(value) { return (value == target ? null : value); }); // delete entry
		this._disabledInputs[this._disabledInputs.length] = target;
	},

	/* Is the first field in a jQuery collection disabled as a datepicker?
	   @param  target    element - the target input field or division or span
	   @return boolean - true if disabled, false if enabled */
	_isDisabledDatepicker: function(target) {
		if (!target) {
			return false;
		}
		for (var i = 0; i <span class="xd">&lt; </span><span class="xn">this._disabledInputs.length</span><span class="xd">; i++) {
			if (this._disabledInputs[i] == target)
				return true;
		}
		return false;
	},

	/* Retrieve the instance data for the target control.
	   @param  target  element - the target input field or division or span
	   @return  object - the associated instance data
	   @throws  error if a jQuery problem getting data */
	_getInst: function(target) {
		try {
			return $.data(target, PROP_NAME);
		}
		catch (err) {
			throw &#39;Missing instance data for this datepicker&#39;;
		}
	},

	/* Update or retrieve the settings for a date picker attached to an input field or division.
	   @param  target  element - the target input field or division or span
	   @param  name    object - the new settings to update or
	                   string - the name of the setting to change or retrieve,
	                   when retrieving also &#39;all&#39; for all instance settings or
	                   &#39;defaults&#39; for all global defaults
	   @param  value   any - the new value for the setting
	                   (omit if above is an object or to retrieve a value) */
	_optionDatepicker: function(target, name, value) {
		var inst = this._getInst(target);
		if (arguments.length == 2 &amp;&amp; typeof name == &#39;string&#39;) {
			return (name == &#39;defaults&#39; ? $.extend({}, $.datepicker._defaults) :
				(inst ? (name == &#39;all&#39; ? $.extend({}, inst.settings) :
				this._get(inst, name)) : null));
		}
		var settings = name || {};
		if (typeof name == &#39;string&#39;) {
			settings = {};
			settings[name] = value;
		}
		if (inst) {
			if (this._curInst == inst) {
				this._hideDatepicker();
			}
			var date = this._getDateDatepicker(target, true);
			var minDate = this._getMinMaxDate(inst, &#39;min&#39;);
			var maxDate = this._getMinMaxDate(inst, &#39;max&#39;);
			extendRemove(inst.settings, settings);
			// reformat the old minDate/maxDate values if dateFormat changes and a new minDate/maxDate isn&#39;t provided
			if (minDate !== null &amp;&amp; settings[&#39;dateFormat&#39;] !== undefined &amp;&amp; settings[&#39;minDate&#39;] === undefined)
				inst.settings.minDate = this._formatDate(inst, minDate);
			if (maxDate !== null &amp;&amp; settings[&#39;dateFormat&#39;] !== undefined &amp;&amp; settings[&#39;maxDate&#39;] === undefined)
				inst.settings.maxDate = this._formatDate(inst, maxDate);
			this._attachments($(target), inst);
			this._autoSize(inst);
			this._setDate(inst, date);
			this._updateAlternate(inst);
			this._updateDatepicker(inst);
		}
	},

	// change method deprecated
	_changeDatepicker: function(target, name, value) {
		this._optionDatepicker(target, name, value);
	},

	/* Redraw the date picker attached to an input field or division.
	   @param  target  element - the target input field or division or span */
	_refreshDatepicker: function(target) {
		var inst = this._getInst(target);
		if (inst) {
			this._updateDatepicker(inst);
		}
	},

	/* Set the dates for a jQuery selection.
	   @param  target   element - the target input field or division or span
	   @param  date     Date - the new date */
	_setDateDatepicker: function(target, date) {
		var inst = this._getInst(target);
		if (inst) {
			this._setDate(inst, date);
			this._updateDatepicker(inst);
			this._updateAlternate(inst);
		}
	},

	/* Get the date(s) for the first entry in a jQuery selection.
	   @param  target     element - the target input field or division or span
	   @param  noDefault  boolean - true if no default date is to be used
	   @return Date - the current date */
	_getDateDatepicker: function(target, noDefault) {
		var inst = this._getInst(target);
		if (inst &amp;&amp; !inst.inline)
			this._setDateFromField(inst, noDefault);
		return (inst ? this._getDate(inst) : null);
	},

	/* Handle keystrokes. */
	_doKeyDown: function(event) {
		var inst = $.datepicker._getInst(event.target);
		var handled = true;
		var isRTL = inst.dpDiv.is(&#39;.ui-datepicker-rtl&#39;);
		inst._keyEvent = true;
		if ($.datepicker._datepickerShowing)
			switch (event.keyCode) {
				case 9: $.datepicker._hideDatepicker();
						handled = false;
						break; // hide on tab out
				case 13: var sel = $(&#39;td.&#39; + $.datepicker._dayOverClass + &#39;:not(.&#39; + 
									$.datepicker._currentClass + &#39;)&#39;, inst.dpDiv);
						if (sel[0])
							$.datepicker._selectDay(event.target, inst.selectedMonth, inst.selectedYear, sel[0]);
							var onSelect = $.datepicker._get(inst, &#39;onSelect&#39;);
							if (onSelect) {
								var dateStr = $.datepicker._formatDate(inst);

								// trigger custom callback
								onSelect.apply((inst.input ? inst.input[0] : null), [dateStr, inst]);
							}
						else
							$.datepicker._hideDatepicker();
						return false; // don&#39;t submit the form
						break; // select the value on enter
				case 27: $.datepicker._hideDatepicker();
						break; // hide on escape
				case 33: $.datepicker._adjustDate(event.target, (event.ctrlKey ?
							-$.datepicker._get(inst, &#39;stepBigMonths&#39;) :
							-$.datepicker._get(inst, &#39;stepMonths&#39;)), &#39;M&#39;);
						break; // previous month/year on page up/+ ctrl
				case 34: $.datepicker._adjustDate(event.target, (event.ctrlKey ?
							+$.datepicker._get(inst, &#39;stepBigMonths&#39;) :
							+$.datepicker._get(inst, &#39;stepMonths&#39;)), &#39;M&#39;);
						break; // next month/year on page down/+ ctrl
				case 35: if (event.ctrlKey || event.metaKey) $.datepicker._clearDate(event.target);
						handled = event.ctrlKey || event.metaKey;
						break; // clear on ctrl or command +end
				case 36: if (event.ctrlKey || event.metaKey) $.datepicker._gotoToday(event.target);
						handled = event.ctrlKey || event.metaKey;
						break; // current on ctrl or command +home
				case 37: if (event.ctrlKey || event.metaKey) $.datepicker._adjustDate(event.target, (isRTL ? +1 : -1), &#39;D&#39;);
						handled = event.ctrlKey || event.metaKey;
						// -1 day on ctrl or command +left
						if (event.originalEvent.altKey) $.datepicker._adjustDate(event.target, (event.ctrlKey ?
									-$.datepicker._get(inst, &#39;stepBigMonths&#39;) :
									-$.datepicker._get(inst, &#39;stepMonths&#39;)), &#39;M&#39;);
						// next month/year on alt +left on Mac
						break;
				case 38: if (event.ctrlKey || event.metaKey) $.datepicker._adjustDate(event.target, -7, &#39;D&#39;);
						handled = event.ctrlKey || event.metaKey;
						break; // -1 week on ctrl or command +up
				case 39: if (event.ctrlKey || event.metaKey) $.datepicker._adjustDate(event.target, (isRTL ? -1 : +1), &#39;D&#39;);
						handled = event.ctrlKey || event.metaKey;
						// +1 day on ctrl or command +right
						if (event.originalEvent.altKey) $.datepicker._adjustDate(event.target, (event.ctrlKey ?
									+$.datepicker._get(inst, &#39;stepBigMonths&#39;) :
									+$.datepicker._get(inst, &#39;stepMonths&#39;)), &#39;M&#39;);
						// next month/year on alt +right
						break;
				case 40: if (event.ctrlKey || event.metaKey) $.datepicker._adjustDate(event.target, +7, &#39;D&#39;);
						handled = event.ctrlKey || event.metaKey;
						break; // +1 week on ctrl or command +down
				default: handled = false;
			}
		else if (event.keyCode == 36 &amp;&amp; event.ctrlKey) // display the date picker on ctrl+home
			$.datepicker._showDatepicker(this);
		else {
			handled = false;
		}
		if (handled) {
			event.preventDefault();
			event.stopPropagation();
		}
	},

	/* Filter entered characters - based on date format. */
	_doKeyPress: function(event) {
		var inst = $.datepicker._getInst(event.target);
		if ($.datepicker._get(inst, &#39;constrainInput&#39;)) {
			var chars = $.datepicker._possibleChars($.datepicker._get(inst, &#39;dateFormat&#39;));
			var chr = String.fromCharCode(event.charCode == undefined ? event.keyCode : event.charCode);
			return event.ctrlKey || event.metaKey || (chr </span><span class="xd">&lt; </span>&#39;<span class="xav"> </span>&#39; <span class="xan">|| </span><span class="xd">!chars || chars.indexOf(chr) &gt;</span> -1);
		}
	},

	/* Synchronise manual entry and field/alternate field. */
	_doKeyUp: function(event) {
		var inst = $.datepicker._getInst(event.target);
		if (inst.input.val() != inst.lastVal) {
			try {
				var date = $.datepicker.parseDate($.datepicker._get(inst, &#39;dateFormat&#39;),
					(inst.input ? inst.input.val() : null),
					$.datepicker._getFormatConfig(inst));
				if (date) { // only if valid
					$.datepicker._setDateFromField(inst);
					$.datepicker._updateAlternate(inst);
					$.datepicker._updateDatepicker(inst);
				}
			}
			catch (event) {
				$.datepicker.log(event);
			}
		}
		return true;
	},

	/* Pop-up the date picker for a given input field.
       If false returned from beforeShow event handler do not show. 
	   @param  input  element - the input field attached to the date picker or
	                  event - if triggered by focus */
	_showDatepicker: function(input) {
		input = input.target || input;
		if (input.nodeName.toLowerCase() != &#39;input&#39;) // find from button/image trigger
			input = $(&#39;input&#39;, input.parentNode)[0];
		if ($.datepicker._isDisabledDatepicker(input) || $.datepicker._lastInput == input) // already here
			return;
		var inst = $.datepicker._getInst(input);
		if ($.datepicker._curInst <span class="xer">&amp;</span><span class="xer">&amp;</span> $.datepicker._curInst != inst) {
			$.datepicker._curInst.dpDiv.stop(true, true);
			if ( inst <span class="xer">&amp;</span><span class="xer">&amp;</span> $.datepicker._datepickerShowing ) {
				$.datepicker._hideDatepicker( $.datepicker._curInst.input[0] );
			}
		}
		var beforeShow = $.datepicker._get(inst, &#39;beforeShow&#39;);
		var beforeShowSettings = beforeShow ? beforeShow.apply(input, [input, inst]) : {};
		if(beforeShowSettings === false){
            //false
			return;
		}
		extendRemove(inst.settings, beforeShowSettings);
		inst.lastVal = null;
		$.datepicker._lastInput = input;
		$.datepicker._setDateFromField(inst);
		if ($.datepicker._inDialog) // hide cursor
			input.value = &#39;&#39;;
		if (!$.datepicker._pos) { // position below input
			$.datepicker._pos = $.datepicker._findPos(input);
			$.datepicker._pos[1] += input.offsetHeight; // add the height
		}
		var isFixed = false;
		$(input).parents().each(function() {
			isFixed |= $(this).css(&#39;position&#39;) == &#39;fixed&#39;;
			return !isFixed;
		});
		if (isFixed <span class="xer">&amp;</span><span class="xer">&amp;</span> $.browser.opera) { // correction for Opera when fixed and scrolled
			$.datepicker._pos[0] -= document.documentElement.scrollLeft;
			$.datepicker._pos[1] -= document.documentElement.scrollTop;
		}
		var offset = {left: $.datepicker._pos[0], top: $.datepicker._pos[1]};
		$.datepicker._pos = null;
		//to avoid flashes on Firefox
		inst.dpDiv.empty();
		// determine sizing offscreen
		inst.dpDiv.css({position: &#39;absolute&#39;, display: &#39;block&#39;, top: &#39;-1000px&#39;});
		$.datepicker._updateDatepicker(inst);
		// fix width for dynamic number of date pickers
		// and adjust position before showing
		offset = $.datepicker._checkOffset(inst, offset, isFixed);
		inst.dpDiv.css({position: ($.datepicker._inDialog <span class="xer">&amp;</span><span class="xer">&amp;</span> $.blockUI ?
			&#39;static&#39; : (isFixed ? &#39;fixed&#39; : &#39;absolute&#39;)), display: &#39;none&#39;,
			left: offset.left + &#39;px&#39;, top: offset.top + &#39;px&#39;});
		if (!inst.inline) {
			var showAnim = $.datepicker._get(inst, &#39;showAnim&#39;);
			var duration = $.datepicker._get(inst, &#39;duration&#39;);
			var postProcess = function() {
				var cover = inst.dpDiv.find(&#39;iframe.ui-datepicker-cover&#39;); // IE6- only
				if( !! cover.length ){
					var borders = $.datepicker._getBorders(inst.dpDiv);
					cover.css({left: -borders[0], top: -borders[1],
						width: inst.dpDiv.outerWidth(), height: inst.dpDiv.outerHeight()});
				}
			};
			inst.dpDiv.zIndex($(input).zIndex()+1);
			$.datepicker._datepickerShowing = true;
			if ($.effects <span class="xer">&amp;</span><span class="xer">&amp;</span> $.effects[showAnim])
				inst.dpDiv.show(showAnim, $.datepicker._get(inst, &#39;showOptions&#39;), duration, postProcess);
			else
				inst.dpDiv[showAnim || &#39;show&#39;]((showAnim ? duration : null), postProcess);
			if (!showAnim || !duration)
				postProcess();
			if (inst.input.is(&#39;:visible&#39;) <span class="xer">&amp;</span><span class="xer">&amp;</span> !inst.input.is(&#39;:disabled&#39;))
				inst.input.focus();
			$.datepicker._curInst = inst;
		}
	},

	/* Generate the date picker content. */
	_updateDatepicker: function(inst) {
		var self = this;
		self.maxRows = 4; //Reset the max number of rows being displayed (see #7043)
		var borders = $.datepicker._getBorders(inst.dpDiv);
		instActive = inst; // for delegate hover events
		inst.dpDiv.empty().append(this._generateHTML(inst));
		var cover = inst.dpDiv.find(&#39;iframe.ui-datepicker-cover&#39;); // IE6- only
		if( !!cover.length ){ //avoid call to outerXXXX() when not in IE6
			cover.css({left: -borders[0], top: -borders[1], width: inst.dpDiv.outerWidth(), height: inst.dpDiv.outerHeight()})
		}
		inst.dpDiv.find(&#39;.&#39; + this._dayOverClass + &#39; a&#39;).mouseover();
		var numMonths = this._getNumberOfMonths(inst);
		var cols = numMonths[1];
		var width = 17;
		inst.dpDiv.removeClass(&#39;ui-datepicker-multi-2 ui-datepicker-multi-3 ui-datepicker-multi-4&#39;).width(&#39;&#39;);
		if (cols &gt; 1)
			inst.dpDiv.addClass(&#39;ui-datepicker-multi-&#39; + cols).css(&#39;width&#39;, (width * cols) + &#39;em&#39;);
		inst.dpDiv[(numMonths[0] != 1 || numMonths[1] != 1 ? &#39;add&#39; : &#39;remove&#39;) +
			&#39;Class&#39;](&#39;ui-datepicker-multi&#39;);
		inst.dpDiv[(this._get(inst, &#39;isRTL&#39;) ? &#39;add&#39; : &#39;remove&#39;) +
			&#39;Class&#39;](&#39;ui-datepicker-rtl&#39;);
		if (inst == $.datepicker._curInst <span class="xer">&amp;</span><span class="xer">&amp;</span> $.datepicker._datepickerShowing <span class="xer">&amp;</span><span class="xer">&amp;</span> inst.input <span class="xer">&amp;</span><span class="xer">&amp;</span>
				// #6694 - don&#39;t focus the input if it&#39;s already focused
				// this breaks the change event in IE
				inst.input.is(&#39;:visible&#39;) <span class="xer">&amp;</span><span class="xer">&amp;</span> !inst.input.is(&#39;:disabled&#39;) <span class="xer">&amp;</span><span class="xer">&amp;</span> inst.input[0] != document.activeElement)
			inst.input.focus();
		// deffered render of the years select (to avoid flashes on Firefox) 
		if( inst.yearshtml ){
			var origyearshtml = inst.yearshtml;
			setTimeout(function(){
				//assure that inst.yearshtml didn&#39;t change.
				if( origyearshtml === inst.yearshtml <span class="xer">&amp;</span><span class="xer">&amp;</span> inst.yearshtml ){
					inst.dpDiv.find(&#39;select.ui-datepicker-year:first&#39;).replaceWith(inst.yearshtml);
				}
				origyearshtml = inst.yearshtml = null;
			}, 0);
		}
	},

	/* Retrieve the size of left and top borders for an element.
	   @param  elem  (jQuery object) the element of interest
	   @return  (number[2]) the left and top borders */
	_getBorders: function(elem) {
		var convert = function(value) {
			return {thin: 1, medium: 2, thick: 3}[value] || value;
		};
		return [parseFloat(convert(elem.css(&#39;border-left-width&#39;))),
			parseFloat(convert(elem.css(&#39;border-top-width&#39;)))];
	},

	/* Check positioning to remain on screen. */
	_checkOffset: function(inst, offset, isFixed) {
		var dpWidth = inst.dpDiv.outerWidth();
		var dpHeight = inst.dpDiv.outerHeight();
		var inputWidth = inst.input ? inst.input.outerWidth() : 0;
		var inputHeight = inst.input ? inst.input.outerHeight() : 0;
		var viewWidth = document.documentElement.clientWidth + $(document).scrollLeft();
		var viewHeight = document.documentElement.clientHeight + $(document).scrollTop();

		offset.left -= (this._get(inst, &#39;isRTL&#39;) ? (dpWidth - inputWidth) : 0);
		offset.left -= (isFixed <span class="xer">&amp;</span><span class="xer">&amp;</span> offset.left == inst.input.offset().left) ? $(document).scrollLeft() : 0;
		offset.top -= (isFixed <span class="xer">&amp;</span><span class="xer">&amp;</span> offset.top == (inst.input.offset().top + inputHeight)) ? $(document).scrollTop() : 0;

		// now check if datepicker is showing outside window viewport - move to a better place if so.
		offset.left -= Math.min(offset.left, (offset.left + dpWidth &gt; viewWidth <span class="xer">&amp;</span><span class="xer">&amp;</span> viewWidth &gt; dpWidth) ?
			Math.abs(offset.left + dpWidth - viewWidth) : 0);
		offset.top -= Math.min(offset.top, (offset.top + dpHeight &gt; viewHeight <span class="xer">&amp;</span><span class="xer">&amp;</span> viewHeight &gt; dpHeight) ?
			Math.abs(dpHeight + inputHeight) : 0);

		return offset;
	},

	/* Find an object&#39;s position on the screen. */
	_findPos: function(obj) {
		var inst = this._getInst(obj);
		var isRTL = this._get(inst, &#39;isRTL&#39;);
        while (obj <span class="xer">&amp;</span><span class="xer">&amp;</span> (obj.type == &#39;hidden&#39; || obj.nodeType != 1 || $.expr.filters.hidden(obj))) {
            obj = obj[isRTL ? &#39;previousSibling&#39; : &#39;nextSibling&#39;];
        }
        var position = $(obj).offset();
	    return [position.left, position.top];
	},

	/* Hide the date picker from view.
	   @param  input  element - the input field attached to the date picker */
	_hideDatepicker: function(input) {
		var inst = this._curInst;
		if (!inst || (input <span class="xer">&amp;</span><span class="xer">&amp;</span> inst != $.data(input, PROP_NAME)))
			return;
		if (this._datepickerShowing) {
			var showAnim = this._get(inst, &#39;showAnim&#39;);
			var duration = this._get(inst, &#39;duration&#39;);
			var self = this;
			var postProcess = function() {
				$.datepicker._tidyDialog(inst);
				self._curInst = null;
			};
			if ($.effects <span class="xer">&amp;</span><span class="xer">&amp;</span> $.effects[showAnim])
				inst.dpDiv.hide(showAnim, $.datepicker._get(inst, &#39;showOptions&#39;), duration, postProcess);
			else
				inst.dpDiv[(showAnim == &#39;slideDown&#39; ? &#39;slideUp&#39; :
					(showAnim == &#39;fadeIn&#39; ? &#39;fadeOut&#39; : &#39;hide&#39;))]((showAnim ? duration : null), postProcess);
			if (!showAnim)
				postProcess();
			this._datepickerShowing = false;
			var onClose = this._get(inst, &#39;onClose&#39;);
			if (onClose)
				onClose.apply((inst.input ? inst.input[0] : null),
					[(inst.input ? inst.input.val() : &#39;&#39;), inst]);
			this._lastInput = null;
			if (this._inDialog) {
				this._dialogInput.css({ position: &#39;absolute&#39;, left: &#39;0&#39;, top: &#39;-100px&#39; });
				if ($.blockUI) {
					$.unblockUI();
					$(&#39;body&#39;).append(this.dpDiv);
				}
			}
			this._inDialog = false;
		}
	},

	/* Tidy up after a dialog display. */
	_tidyDialog: function(inst) {
		inst.dpDiv.removeClass(this._dialogClass).unbind(&#39;.ui-datepicker-calendar&#39;);
	},

	/* Close date picker if clicked elsewhere. */
	_checkExternalClick: function(event) {
		if (!$.datepicker._curInst)
			return;

		var $target = $(event.target),
			inst = $.datepicker._getInst($target[0]);

		if ( ( ( $target[0].id != $.datepicker._mainDivId <span class="xer">&amp;</span><span class="xer">&amp;</span>
				$target.parents(&#39;#&#39; + $.datepicker._mainDivId).length == 0 <span class="xer">&amp;</span><span class="xer">&amp;</span>
				!$target.hasClass($.datepicker.markerClassName) <span class="xer">&amp;</span><span class="xer">&amp;</span>
				!$target.closest(&quot;.&quot; + $.datepicker._triggerClass).length <span class="xer">&amp;</span><span class="xer">&amp;</span>
				$.datepicker._datepickerShowing <span class="xer">&amp;</span><span class="xer">&amp;</span> !($.datepicker._inDialog <span class="xer">&amp;</span><span class="xer">&amp;</span> $.blockUI) ) ) ||
			( $target.hasClass($.datepicker.markerClassName) <span class="xer">&amp;</span><span class="xer">&amp;</span> $.datepicker._curInst != inst ) )
			$.datepicker._hideDatepicker();
	},

	/* Adjust one of the date sub-fields. */
	_adjustDate: function(id, offset, period) {
		var target = $(id);
		var inst = this._getInst(target[0]);
		if (this._isDisabledDatepicker(target[0])) {
			return;
		}
		this._adjustInstDate(inst, offset +
			(period == &#39;M&#39; ? this._get(inst, &#39;showCurrentAtPos&#39;) : 0), // undo positioning
			period);
		this._updateDatepicker(inst);
	},

	/* Action for current link. */
	_gotoToday: function(id) {
		var target = $(id);
		var inst = this._getInst(target[0]);
		if (this._get(inst, &#39;gotoCurrent&#39;) <span class="xer">&amp;</span><span class="xer">&amp;</span> inst.currentDay) {
			inst.selectedDay = inst.currentDay;
			inst.drawMonth = inst.selectedMonth = inst.currentMonth;
			inst.drawYear = inst.selectedYear = inst.currentYear;
		}
		else {
			var date = new Date();
			inst.selectedDay = date.getDate();
			inst.drawMonth = inst.selectedMonth = date.getMonth();
			inst.drawYear = inst.selectedYear = date.getFullYear();
		}
		this._notifyChange(inst);
		this._adjustDate(target);
	},

	/* Action for selecting a new month/year. */
	_selectMonthYear: function(id, select, period) {
		var target = $(id);
		var inst = this._getInst(target[0]);
		inst[&#39;selected&#39; + (period == &#39;M&#39; ? &#39;Month&#39; : &#39;Year&#39;)] =
		inst[&#39;draw&#39; + (period == &#39;M&#39; ? &#39;Month&#39; : &#39;Year&#39;)] =
			parseInt(select.options[select.selectedIndex].value,10);
		this._notifyChange(inst);
		this._adjustDate(target);
	},

	/* Action for selecting a day. */
	_selectDay: function(id, month, year, td) {
		var target = $(id);
		if ($(td).hasClass(this._unselectableClass) || this._isDisabledDatepicker(target[0])) {
			return;
		}
		var inst = this._getInst(target[0]);
		inst.selectedDay = inst.currentDay = $(&#39;a&#39;, td).html();
		inst.selectedMonth = inst.currentMonth = month;
		inst.selectedYear = inst.currentYear = year;
		this._selectDate(id, this._formatDate(inst,
			inst.currentDay, inst.currentMonth, inst.currentYear));
	},

	/* Erase the input field and hide the date picker. */
	_clearDate: function(id) {
		var target = $(id);
		var inst = this._getInst(target[0]);
		this._selectDate(target, &#39;&#39;);
	},

	/* Update the input field with the selected date. */
	_selectDate: function(id, dateStr) {
		var target = $(id);
		var inst = this._getInst(target[0]);
		dateStr = (dateStr != null ? dateStr : this._formatDate(inst));
		if (inst.input)
			inst.input.val(dateStr);
		this._updateAlternate(inst);
		var onSelect = this._get(inst, &#39;onSelect&#39;);
		if (onSelect)
			onSelect.apply((inst.input ? inst.input[0] : null), [dateStr, inst]);  // trigger custom callback
		else if (inst.input)
			inst.input.trigger(&#39;change&#39;); // fire the change event
		if (inst.inline)
			this._updateDatepicker(inst);
		else {
			this._hideDatepicker();
			this._lastInput = inst.input[0];
			if (typeof(inst.input[0]) != &#39;object&#39;)
				inst.input.focus(); // restore focus
			this._lastInput = null;
		}
	},

	/* Update any alternate field to synchronise with the main field. */
	_updateAlternate: function(inst) {
		var altField = this._get(inst, &#39;altField&#39;);
		if (altField) { // update alternate field too
			var altFormat = this._get(inst, &#39;altFormat&#39;) || this._get(inst, &#39;dateFormat&#39;);
			var date = this._getDate(inst);
			var dateStr = this.formatDate(altFormat, date, this._getFormatConfig(inst));
			$(altField).each(function() { $(this).val(dateStr); });
		}
	},

	/* Set as beforeShowDay function to prevent selection of weekends.
	   @param  date  Date - the date to customise
	   @return [boolean, string] - is this date selectable?, what is its CSS class? */
	noWeekends: function(date) {
		var day = date.getDay();
		return [(day &gt; 0 <span class="xer">&amp;</span><span class="xer">&amp;</span> day <span class="xd">&lt; </span><span class="xn">6</span><span class="xd">), &#39;&#39;];
	},

	/* Set as calculateWeek to determine the week of the year based on the ISO 8601 definition.
	   @param  date  Date - the date to get the week for
	   @return  number - the number of the week within the year that contains this date */
	iso8601Week: function(date) {
		var checkDate = new Date(date.getTime());
		// Find Thursday of this week starting on Monday
		checkDate.setDate(checkDate.getDate() + 4 - (checkDate.getDay() || 7));
		var time = checkDate.getTime();
		checkDate.setMonth(0); // Compare with Jan 1
		checkDate.setDate(1);
		return Math.floor(Math.round((time - checkDate) / 86400000) / 7) + 1;
	},

	/* Parse a string value into a date object.
	   See formatDate below for the possible formats.

	   @param  format    string - the expected format of the date
	   @param  value     string - the date in the above format
	   @param  settings  Object - attributes include:
	                     shortYearCutoff  number - the cutoff year for determining the century (optional)
	                     dayNamesShort    string[7] - abbreviated names of the days from Sunday (optional)
	                     dayNames         string[7] - names of the days from Sunday (optional)
	                     monthNamesShort  string[12] - abbreviated names of the months (optional)
	                     monthNames       string[12] - names of the months (optional)
	   @return  Date - the extracted date value or null if value is blank */
	parseDate: function (format, value, settings) {
		if (format == null || value == null)
			throw &#39;Invalid arguments&#39;;
		value = (typeof value == &#39;object&#39; ? value.toString() : value + &#39;&#39;);
		if (value == &#39;&#39;)
			return null;
		var shortYearCutoff = (settings ? settings.shortYearCutoff : null) || this._defaults.shortYearCutoff;
		shortYearCutoff = (typeof shortYearCutoff != &#39;string&#39; ? shortYearCutoff :
				new Date().getFullYear() % 100 + parseInt(shortYearCutoff, 10));
		var dayNamesShort = (settings ? settings.dayNamesShort : null) || this._defaults.dayNamesShort;
		var dayNames = (settings ? settings.dayNames : null) || this._defaults.dayNames;
		var monthNamesShort = (settings ? settings.monthNamesShort : null) || this._defaults.monthNamesShort;
		var monthNames = (settings ? settings.monthNames : null) || this._defaults.monthNames;
		var year = -1;
		var month = -1;
		var day = -1;
		var doy = -1;
		var literal = false;
		// Check whether a format character is doubled
		var lookAhead = function(match) {
			var matches = (iFormat + 1 </span><span class="xd">&lt; </span><span class="xn">format.length </span><span class="xan">&amp;&amp; </span><span class="xan">format.charAt</span><span class="xd">(iFormat + 1) == match);
			if (matches)
				iFormat++;
			return matches;
		};
		// Extract a number from the string value
		var getNumber = function(match) {
			var isDoubled = lookAhead(match);
			var size = (match == &#39;@&#39; ? 14 : (match == &#39;!&#39; ? 20 :
				(match == &#39;y&#39; &amp;&amp; isDoubled ? 4 : (match == &#39;o&#39; ? 3 : 2))));
			var digits = new RegExp(&#39;^\\d{1,&#39; + size + &#39;}&#39;);
			var num = value.substring(iValue).match(digits);
			if (!num)
				throw &#39;Missing number at position &#39; + iValue;
			iValue += num[0].length;
			return parseInt(num[0], 10);
		};
		// Extract a name from the string value and convert to an index
		var getName = function(match, shortNames, longNames) {
			var names = $.map(lookAhead(match) ? longNames : shortNames, function (v, k) {
				return [ [k, v] ];
			}).sort(function (a, b) {
				return -(a[1].length - b[1].length);
			});
			var index = -1;
			$.each(names, function (i, pair) {
				var name = pair[1];
				if (value.substr(iValue, name.length).toLowerCase() == name.toLowerCase()) {
					index = pair[0];
					iValue += name.length;
					return false;
				}
			});
			if (index != -1)
				return index + 1;
			else
				throw &#39;Unknown name at position &#39; + iValue;
		};
		// Confirm that a literal character matches the string value
		var checkLiteral = function() {
			if (value.charAt(iValue) != format.charAt(iFormat))
				throw &#39;Unexpected literal at position &#39; + iValue;
			iValue++;
		};
		var iValue = 0;
		for (var iFormat = 0; iFormat </span><span class="xd">&lt; </span><span class="xn">format.length</span><span class="xd">; iFormat++) {
			if (literal)
				if (format.charAt(iFormat) == &quot;&#39;&quot; &amp;&amp; !lookAhead(&quot;&#39;&quot;))
					literal = false;
				else
					checkLiteral();
			else
				switch (format.charAt(iFormat)) {
					case &#39;d&#39;:
						day = getNumber(&#39;d&#39;);
						break;
					case &#39;D&#39;:
						getName(&#39;D&#39;, dayNamesShort, dayNames);
						break;
					case &#39;o&#39;:
						doy = getNumber(&#39;o&#39;);
						break;
					case &#39;m&#39;:
						month = getNumber(&#39;m&#39;);
						break;
					case &#39;M&#39;:
						month = getName(&#39;M&#39;, monthNamesShort, monthNames);
						break;
					case &#39;y&#39;:
						year = getNumber(&#39;y&#39;);
						break;
					case &#39;@&#39;:
						var date = new Date(getNumber(&#39;@&#39;));
						year = date.getFullYear();
						month = date.getMonth() + 1;
						day = date.getDate();
						break;
					case &#39;!&#39;:
						var date = new Date((getNumber(&#39;!&#39;) - this._ticksTo1970) / 10000);
						year = date.getFullYear();
						month = date.getMonth() + 1;
						day = date.getDate();
						break;
					case &quot;&#39;&quot;:
						if (lookAhead(&quot;&#39;&quot;))
							checkLiteral();
						else
							literal = true;
						break;
					default:
						checkLiteral();
				}
		}
		if (iValue </span><span class="xd">&lt; </span><span class="xn">value.length</span><span class="xd">){
			throw &quot;Extra/unparsed characters found in date: &quot; + value.substring(iValue);
		}
		if (year == -1)
			year = new Date().getFullYear();
		else if (year </span><span class="xd">&lt; </span><span class="xn">100</span><span class="xd">)
			year += new Date().getFullYear() - new Date().getFullYear() % 100 +
				(year </span><span class="xd">&lt;</span><span class="xd">= </span><span class="xav">shortYearCutoff</span><span class="xd"> ? 0 : -100);
		if (doy &gt;</span> -1) {
			month = 1;
			day = doy;
			do {
				var dim = this._getDaysInMonth(year, month - 1);
				if (day <span class="xd">&lt;</span><span class="xd">= </span><span class="xav">dim)</span><span class="xan">
					break</span><span class="xd">;
				month++;
				day -= dim;
			} while (true);
		}
		var date = this._daylightSavingAdjust(new Date(year, month - 1, day));
		if (date.getFullYear() != year || date.getMonth() + 1 != month || date.getDate() != day)
			throw &#39;Invalid date&#39;; // E.g. 31/02/00
		return date;
	},

	/* Standard date formats. */
	ATOM: &#39;yy-mm-dd&#39;, // RFC 3339 (ISO 8601)
	COOKIE: &#39;D, dd M yy&#39;,
	ISO_8601: &#39;yy-mm-dd&#39;,
	RFC_822: &#39;D, d M y&#39;,
	RFC_850: &#39;DD, dd-M-y&#39;,
	RFC_1036: &#39;D, d M y&#39;,
	RFC_1123: &#39;D, d M yy&#39;,
	RFC_2822: &#39;D, d M yy&#39;,
	RSS: &#39;D, d M y&#39;, // RFC 822
	TICKS: &#39;!&#39;,
	TIMESTAMP: &#39;@&#39;,
	W3C: &#39;yy-mm-dd&#39;, // ISO 8601

	_ticksTo1970: (((1970 - 1) * 365 + Math.floor(1970 / 4) - Math.floor(1970 / 100) +
		Math.floor(1970 / 400)) * 24 * 60 * 60 * 10000000),

	/* Format a date object into a string value.
	   The format can be combinations of the following:
	   d  - day of month (no leading zero)
	   dd - day of month (two digit)
	   o  - day of year (no leading zeros)
	   oo - day of year (three digit)
	   D  - day name short
	   DD - day name long
	   m  - month of year (no leading zero)
	   mm - month of year (two digit)
	   M  - month name short
	   MM - month name long
	   y  - year (two digit)
	   yy - year (four digit)
	   @ - Unix timestamp (ms since 01/01/1970)
	   ! - Windows ticks (100ns since 01/01/0001)
	   &#39;...&#39; - literal text
	   &#39;&#39; - single quote

	   @param  format    string - the desired format of the date
	   @param  date      Date - the date value to format
	   @param  settings  Object - attributes include:
	                     dayNamesShort    string[7] - abbreviated names of the days from Sunday (optional)
	                     dayNames         string[7] - names of the days from Sunday (optional)
	                     monthNamesShort  string[12] - abbreviated names of the months (optional)
	                     monthNames       string[12] - names of the months (optional)
	   @return  string - the date in the above format */
	formatDate: function (format, date, settings) {
		if (!date)
			return &#39;&#39;;
		var dayNamesShort = (settings ? settings.dayNamesShort : null) || this._defaults.dayNamesShort;
		var dayNames = (settings ? settings.dayNames : null) || this._defaults.dayNames;
		var monthNamesShort = (settings ? settings.monthNamesShort : null) || this._defaults.monthNamesShort;
		var monthNames = (settings ? settings.monthNames : null) || this._defaults.monthNames;
		// Check whether a format character is doubled
		var lookAhead = function(match) {
			var matches = (iFormat + 1 </span><span class="xd">&lt; </span><span class="xn">format.length </span><span class="xan">&amp;&amp; </span><span class="xan">format.charAt</span><span class="xd">(iFormat + 1) == match);
			if (matches)
				iFormat++;
			return matches;
		};
		// Format a number, with leading zero if necessary
		var formatNumber = function(match, value, len) {
			var num = &#39;&#39; + value;
			if (lookAhead(match))
				while (num.length </span><span class="xd">&lt; </span><span class="xn">len</span><span class="xd">)
					num = &#39;0&#39; + num;
			return num;
		};
		// Format a name, short or long as requested
		var formatName = function(match, value, shortNames, longNames) {
			return (lookAhead(match) ? longNames[value] : shortNames[value]);
		};
		var output = &#39;&#39;;
		var literal = false;
		if (date)
			for (var iFormat = 0; iFormat </span><span class="xd">&lt; </span><span class="xn">format.length</span><span class="xd">; iFormat++) {
				if (literal)
					if (format.charAt(iFormat) == &quot;&#39;&quot; &amp;&amp; !lookAhead(&quot;&#39;&quot;))
						literal = false;
					else
						output += format.charAt(iFormat);
				else
					switch (format.charAt(iFormat)) {
						case &#39;d&#39;:
							output += formatNumber(&#39;d&#39;, date.getDate(), 2);
							break;
						case &#39;D&#39;:
							output += formatName(&#39;D&#39;, date.getDay(), dayNamesShort, dayNames);
							break;
						case &#39;o&#39;:
							output += formatNumber(&#39;o&#39;,
								Math.round((new Date(date.getFullYear(), date.getMonth(), date.getDate()).getTime() - new Date(date.getFullYear(), 0, 0).getTime()) / 86400000), 3);
							break;
						case &#39;m&#39;:
							output += formatNumber(&#39;m&#39;, date.getMonth() + 1, 2);
							break;
						case &#39;M&#39;:
							output += formatName(&#39;M&#39;, date.getMonth(), monthNamesShort, monthNames);
							break;
						case &#39;y&#39;:
							output += (lookAhead(&#39;y&#39;) ? date.getFullYear() :
								(date.getYear() % 100 </span><span class="xd">&lt; </span><span class="xn">10 </span><span class="xd">? &#39;0&#39; : &#39;&#39;) + date.getYear() % 100);
							break;
						case &#39;@&#39;:
							output += date.getTime();
							break;
						case &#39;!&#39;:
							output += date.getTime() * 10000 + this._ticksTo1970;
							break;
						case &quot;&#39;&quot;:
							if (lookAhead(&quot;&#39;&quot;))
								output += &quot;&#39;&quot;;
							else
								literal = true;
							break;
						default:
							output += format.charAt(iFormat);
					}
			}
		return output;
	},

	/* Extract all possible characters from the date format. */
	_possibleChars: function (format) {
		var chars = &#39;&#39;;
		var literal = false;
		// Check whether a format character is doubled
		var lookAhead = function(match) {
			var matches = (iFormat + 1 </span><span class="xd">&lt; </span><span class="xn">format.length </span><span class="xan">&amp;&amp; </span><span class="xan">format.charAt</span><span class="xd">(iFormat + 1) == match);
			if (matches)
				iFormat++;
			return matches;
		};
		for (var iFormat = 0; iFormat </span><span class="xd">&lt; </span><span class="xn">format.length</span><span class="xd">; iFormat++)
			if (literal)
				if (format.charAt(iFormat) == &quot;&#39;&quot; &amp;&amp; !lookAhead(&quot;&#39;&quot;))
					literal = false;
				else
					chars += format.charAt(iFormat);
			else
				switch (format.charAt(iFormat)) {
					case &#39;d&#39;: case &#39;m&#39;: case &#39;y&#39;: case &#39;@&#39;:
						chars += &#39;0123456789&#39;;
						break;
					case &#39;D&#39;: case &#39;M&#39;:
						return null; // Accept anything
					case &quot;&#39;&quot;:
						if (lookAhead(&quot;&#39;&quot;))
							chars += &quot;&#39;&quot;;
						else
							literal = true;
						break;
					default:
						chars += format.charAt(iFormat);
				}
		return chars;
	},

	/* Get a setting value, defaulting if necessary. */
	_get: function(inst, name) {
		return inst.settings[name] !== undefined ?
			inst.settings[name] : this._defaults[name];
	},

	/* Parse existing date and initialise date picker. */
	_setDateFromField: function(inst, noDefault) {
		if (inst.input.val() == inst.lastVal) {
			return;
		}
		var dateFormat = this._get(inst, &#39;dateFormat&#39;);
		var dates = inst.lastVal = inst.input ? inst.input.val() : null;
		var date, defaultDate;
		date = defaultDate = this._getDefaultDate(inst);
		var settings = this._getFormatConfig(inst);
		try {
			date = this.parseDate(dateFormat, dates, settings) || defaultDate;
		} catch (event) {
			this.log(event);
			dates = (noDefault ? &#39;&#39; : dates);
		}
		inst.selectedDay = date.getDate();
		inst.drawMonth = inst.selectedMonth = date.getMonth();
		inst.drawYear = inst.selectedYear = date.getFullYear();
		inst.currentDay = (dates ? date.getDate() : 0);
		inst.currentMonth = (dates ? date.getMonth() : 0);
		inst.currentYear = (dates ? date.getFullYear() : 0);
		this._adjustInstDate(inst);
	},

	/* Retrieve the default date shown on opening. */
	_getDefaultDate: function(inst) {
		return this._restrictMinMax(inst,
			this._determineDate(inst, this._get(inst, &#39;defaultDate&#39;), new Date()));
	},

	/* A date may be specified as an exact value or a relative one. */
	_determineDate: function(inst, date, defaultDate) {
		var offsetNumeric = function(offset) {
			var date = new Date();
			date.setDate(date.getDate() + offset);
			return date;
		};
		var offsetString = function(offset) {
			try {
				return $.datepicker.parseDate($.datepicker._get(inst, &#39;dateFormat&#39;),
					offset, $.datepicker._getFormatConfig(inst));
			}
			catch (e) {
				// Ignore
			}
			var date = (offset.toLowerCase().match(/^c/) ?
				$.datepicker._getDate(inst) : null) || new Date();
			var year = date.getFullYear();
			var month = date.getMonth();
			var day = date.getDate();
			var pattern = /([+-]?[0-9]+)\s*(d|D|w|W|m|M|y|Y)?/g;
			var matches = pattern.exec(offset);
			while (matches) {
				switch (matches[2] || &#39;d&#39;) {
					case &#39;d&#39; : case &#39;D&#39; :
						day += parseInt(matches[1],10); break;
					case &#39;w&#39; : case &#39;W&#39; :
						day += parseInt(matches[1],10) * 7; break;
					case &#39;m&#39; : case &#39;M&#39; :
						month += parseInt(matches[1],10);
						day = Math.min(day, $.datepicker._getDaysInMonth(year, month));
						break;
					case &#39;y&#39;: case &#39;Y&#39; :
						year += parseInt(matches[1],10);
						day = Math.min(day, $.datepicker._getDaysInMonth(year, month));
						break;
				}
				matches = pattern.exec(offset);
			}
			return new Date(year, month, day);
		};
		var newDate = (date == null || date === &#39;&#39; ? defaultDate : (typeof date == &#39;string&#39; ? offsetString(date) :
			(typeof date == &#39;number&#39; ? (isNaN(date) ? defaultDate : offsetNumeric(date)) : new Date(date.getTime()))));
		newDate = (newDate &amp;&amp; newDate.toString() == &#39;Invalid Date&#39; ? defaultDate : newDate);
		if (newDate) {
			newDate.setHours(0);
			newDate.setMinutes(0);
			newDate.setSeconds(0);
			newDate.setMilliseconds(0);
		}
		return this._daylightSavingAdjust(newDate);
	},

	/* Handle switch to/from daylight saving.
	   Hours may be non-zero on daylight saving cut-over:
	   &gt;</span> 12 when midnight changeover, but then cannot generate
	   midnight datetime, so jump to 1AM, otherwise reset.
	   @param  date  (Date) the date to check
	   @return  (Date) the corrected date */
	_daylightSavingAdjust: function(date) {
		if (!date) return null;
		date.setHours(date.getHours() &gt; 12 ? date.getHours() + 2 : 0);
		return date;
	},

	/* Set the date(s) directly. */
	_setDate: function(inst, date, noChange) {
		var clear = !date;
		var origMonth = inst.selectedMonth;
		var origYear = inst.selectedYear;
		var newDate = this._restrictMinMax(inst, this._determineDate(inst, date, new Date()));
		inst.selectedDay = inst.currentDay = newDate.getDate();
		inst.drawMonth = inst.selectedMonth = inst.currentMonth = newDate.getMonth();
		inst.drawYear = inst.selectedYear = inst.currentYear = newDate.getFullYear();
		if ((origMonth != inst.selectedMonth || origYear != inst.selectedYear) <span class="xer">&amp;</span><span class="xer">&amp;</span> !noChange)
			this._notifyChange(inst);
		this._adjustInstDate(inst);
		if (inst.input) {
			inst.input.val(clear ? &#39;&#39; : this._formatDate(inst));
		}
	},

	/* Retrieve the date(s) directly. */
	_getDate: function(inst) {
		var startDate = (!inst.currentYear || (inst.input <span class="xer">&amp;</span><span class="xer">&amp;</span> inst.input.val() == &#39;&#39;) ? null :
			this._daylightSavingAdjust(new Date(
			inst.currentYear, inst.currentMonth, inst.currentDay)));
			return startDate;
	},

	/* Generate the HTML for the current state of the date picker. */
	_generateHTML: function(inst) {
		var today = new Date();
		today = this._daylightSavingAdjust(
			new Date(today.getFullYear(), today.getMonth(), today.getDate())); // clear time
		var isRTL = this._get(inst, &#39;isRTL&#39;);
		var showButtonPanel = this._get(inst, &#39;showButtonPanel&#39;);
		var hideIfNoPrevNext = this._get(inst, &#39;hideIfNoPrevNext&#39;);
		var navigationAsDateFormat = this._get(inst, &#39;navigationAsDateFormat&#39;);
		var numMonths = this._getNumberOfMonths(inst);
		var showCurrentAtPos = this._get(inst, &#39;showCurrentAtPos&#39;);
		var stepMonths = this._get(inst, &#39;stepMonths&#39;);
		var isMultiMonth = (numMonths[0] != 1 || numMonths[1] != 1);
		var currentDate = this._daylightSavingAdjust((!inst.currentDay ? new Date(9999, 9, 9) :
			new Date(inst.currentYear, inst.currentMonth, inst.currentDay)));
		var minDate = this._getMinMaxDate(inst, &#39;min&#39;);
		var maxDate = this._getMinMaxDate(inst, &#39;max&#39;);
		var drawMonth = inst.drawMonth - showCurrentAtPos;
		var drawYear = inst.drawYear;
		if (drawMonth <span class="xd">&lt; </span><span class="xn">0</span><span class="xd">) {
			drawMonth += 12;
			drawYear--;
		}
		if (maxDate) {
			var maxDraw = this._daylightSavingAdjust(new Date(maxDate.getFullYear(),
				maxDate.getMonth() - (numMonths[0] * numMonths[1]) + 1, maxDate.getDate()));
			maxDraw = (minDate &amp;&amp; maxDraw </span><span class="xd">&lt; </span><span class="xn">minDate </span><span class="xd">? minDate : maxDraw);
			while (this._daylightSavingAdjust(new Date(drawYear, drawMonth, 1)) &gt;</span> maxDraw) {
				drawMonth--;
				if (drawMonth <span class="xd">&lt; </span><span class="xn">0</span><span class="xd">) {
					drawMonth = 11;
					drawYear--;
				}
			}
		}
		inst.drawMonth = drawMonth;
		inst.drawYear = drawYear;
		var prevText = this._get(inst, &#39;prevText&#39;);
		prevText = (!navigationAsDateFormat ? prevText : this.formatDate(prevText,
			this._daylightSavingAdjust(new Date(drawYear, drawMonth - stepMonths, 1)),
			this._getFormatConfig(inst)));
		var prev = (this._canAdjustMonth(inst, -1, drawYear, drawMonth) ?
			&#39;</span><span class="xd">&lt;</span><span class="xn">a </span><span class="xan">class</span><span class="xd">=</span>&quot;<span class="xav">ui-datepicker-prev ui-corner-all</span>&quot; <span class="xan">onclick</span><span class="xd">=</span>&quot;<span class="xav">DP_jQuery_&#39; + dpuuid +
			&#39;.datepicker._adjustDate(\&#39;#&#39; + inst.id + &#39;\&#39;, -&#39; + stepMonths + &#39;, \&#39;M\&#39;);</span>&quot;&#39;<span class="xav"> +
			</span>&#39; <span class="xan">title</span><span class="xd">=</span>&quot;<span class="xav">&#39; + prevText + &#39;</span>&quot;<span class="xd">&gt;</span><span class="xd">&lt;</span><span class="xn">span </span><span class="xan">class</span><span class="xd">=</span>&quot;<span class="xav">ui-icon ui-icon-circle-triangle-&#39; + ( isRTL ? &#39;e&#39; : &#39;w&#39;) + &#39;</span>&quot;<span class="xd">&gt;</span>&#39; + prevText + &#39;<span class="xd">&lt;/</span><span class="xn">span</span><span class="xd">&gt;</span><span class="xd">&lt;/</span><span class="xn">a</span><span class="xd">&gt;</span>&#39; :
			(hideIfNoPrevNext ? &#39;&#39; : &#39;<span class="xd">&lt;</span><span class="xn">a </span><span class="xan">class</span><span class="xd">=</span>&quot;<span class="xav">ui-datepicker-prev ui-corner-all ui-state-disabled</span>&quot; <span class="xan">title</span><span class="xd">=</span>&quot;<span class="xav">&#39;+ prevText +&#39;</span>&quot;<span class="xd">&gt;</span><span class="xd">&lt;</span><span class="xn">span </span><span class="xan">class</span><span class="xd">=</span>&quot;<span class="xav">ui-icon ui-icon-circle-triangle-&#39; + ( isRTL ? &#39;e&#39; : &#39;w&#39;) + &#39;</span>&quot;<span class="xd">&gt;</span>&#39; + prevText + &#39;<span class="xd">&lt;/</span><span class="xn">span</span><span class="xd">&gt;</span><span class="xd">&lt;/</span><span class="xn">a</span><span class="xd">&gt;</span>&#39;));
		var nextText = this._get(inst, &#39;nextText&#39;);
		nextText = (!navigationAsDateFormat ? nextText : this.formatDate(nextText,
			this._daylightSavingAdjust(new Date(drawYear, drawMonth + stepMonths, 1)),
			this._getFormatConfig(inst)));
		var next = (this._canAdjustMonth(inst, +1, drawYear, drawMonth) ?
			&#39;<span class="xd">&lt;</span><span class="xn">a </span><span class="xan">class</span><span class="xd">=</span>&quot;<span class="xav">ui-datepicker-next ui-corner-all</span>&quot; <span class="xan">onclick</span><span class="xd">=</span>&quot;<span class="xav">DP_jQuery_&#39; + dpuuid +
			&#39;.datepicker._adjustDate(\&#39;#&#39; + inst.id + &#39;\&#39;, +&#39; + stepMonths + &#39;, \&#39;M\&#39;);</span>&quot;&#39;<span class="xav"> +
			</span>&#39; <span class="xan">title</span><span class="xd">=</span>&quot;<span class="xav">&#39; + nextText + &#39;</span>&quot;<span class="xd">&gt;</span><span class="xd">&lt;</span><span class="xn">span </span><span class="xan">class</span><span class="xd">=</span>&quot;<span class="xav">ui-icon ui-icon-circle-triangle-&#39; + ( isRTL ? &#39;w&#39; : &#39;e&#39;) + &#39;</span>&quot;<span class="xd">&gt;</span>&#39; + nextText + &#39;<span class="xd">&lt;/</span><span class="xn">span</span><span class="xd">&gt;</span><span class="xd">&lt;/</span><span class="xn">a</span><span class="xd">&gt;</span>&#39; :
			(hideIfNoPrevNext ? &#39;&#39; : &#39;<span class="xd">&lt;</span><span class="xn">a </span><span class="xan">class</span><span class="xd">=</span>&quot;<span class="xav">ui-datepicker-next ui-corner-all ui-state-disabled</span>&quot; <span class="xan">title</span><span class="xd">=</span>&quot;<span class="xav">&#39;+ nextText + &#39;</span>&quot;<span class="xd">&gt;</span><span class="xd">&lt;</span><span class="xn">span </span><span class="xan">class</span><span class="xd">=</span>&quot;<span class="xav">ui-icon ui-icon-circle-triangle-&#39; + ( isRTL ? &#39;w&#39; : &#39;e&#39;) + &#39;</span>&quot;<span class="xd">&gt;</span>&#39; + nextText + &#39;<span class="xd">&lt;/</span><span class="xn">span</span><span class="xd">&gt;</span><span class="xd">&lt;/</span><span class="xn">a</span><span class="xd">&gt;</span>&#39;));
		var currentText = this._get(inst, &#39;currentText&#39;);
		var gotoDate = (this._get(inst, &#39;gotoCurrent&#39;) <span class="xer">&amp;</span><span class="xer">&amp;</span> inst.currentDay ? currentDate : today);
		currentText = (!navigationAsDateFormat ? currentText :
			this.formatDate(currentText, gotoDate, this._getFormatConfig(inst)));
		var controls = (!inst.inline ? &#39;<span class="xd">&lt;</span><span class="xn">button </span><span class="xan">type</span><span class="xd">=</span>&quot;<span class="xav">button</span>&quot; <span class="xan">class</span><span class="xd">=</span>&quot;<span class="xav">ui-datepicker-close ui-state-default ui-priority-primary ui-corner-all</span>&quot; <span class="xan">onclick</span><span class="xd">=</span>&quot;<span class="xav">DP_jQuery_&#39; + dpuuid +
			&#39;.datepicker._hideDatepicker();</span>&quot;<span class="xd">&gt;</span>&#39; + this._get(inst, &#39;closeText&#39;) + &#39;<span class="xd">&lt;/</span><span class="xn">button</span><span class="xd">&gt;</span>&#39; : &#39;&#39;);
		var buttonPanel = (showButtonPanel) ? &#39;<span class="xd">&lt;</span><span class="xn">div </span><span class="xan">class</span><span class="xd">=</span>&quot;<span class="xav">ui-datepicker-buttonpane ui-widget-content</span>&quot;<span class="xd">&gt;</span>&#39; + (isRTL ? controls : &#39;&#39;) +
			(this._isInRange(inst, gotoDate) ? &#39;<span class="xd">&lt;</span><span class="xn">button </span><span class="xan">type</span><span class="xd">=</span>&quot;<span class="xav">button</span>&quot; <span class="xan">class</span><span class="xd">=</span>&quot;<span class="xav">ui-datepicker-current ui-state-default ui-priority-secondary ui-corner-all</span>&quot; <span class="xan">onclick</span><span class="xd">=</span>&quot;<span class="xav">DP_jQuery_&#39; + dpuuid +
			&#39;.datepicker._gotoToday(\&#39;#&#39; + inst.id + &#39;\&#39;);</span>&quot;&#39;<span class="xav"> +
			</span>&#39;<span class="xd">&gt;</span>&#39; + currentText + &#39;<span class="xd">&lt;/</span><span class="xn">button</span><span class="xd">&gt;</span>&#39; : &#39;&#39;) + (isRTL ? &#39;&#39; : controls) + &#39;<span class="xd">&lt;/</span><span class="xn">div</span><span class="xd">&gt;</span>&#39; : &#39;&#39;;
		var firstDay = parseInt(this._get(inst, &#39;firstDay&#39;),10);
		firstDay = (isNaN(firstDay) ? 0 : firstDay);
		var showWeek = this._get(inst, &#39;showWeek&#39;);
		var dayNames = this._get(inst, &#39;dayNames&#39;);
		var dayNamesShort = this._get(inst, &#39;dayNamesShort&#39;);
		var dayNamesMin = this._get(inst, &#39;dayNamesMin&#39;);
		var monthNames = this._get(inst, &#39;monthNames&#39;);
		var monthNamesShort = this._get(inst, &#39;monthNamesShort&#39;);
		var beforeShowDay = this._get(inst, &#39;beforeShowDay&#39;);
		var showOtherMonths = this._get(inst, &#39;showOtherMonths&#39;);
		var selectOtherMonths = this._get(inst, &#39;selectOtherMonths&#39;);
		var calculateWeek = this._get(inst, &#39;calculateWeek&#39;) || this.iso8601Week;
		var defaultDate = this._getDefaultDate(inst);
		var html = &#39;&#39;;
		for (var row = 0; row <span class="xd">&lt; </span><span class="xn">numMonths[0]</span><span class="xd">; row++) {
			var group = &#39;&#39;;
			this.maxRows = 4;
			for (var col = 0; col </span><span class="xd">&lt; </span><span class="xn">numMonths[1]</span><span class="xd">; col++) {
				var selectedDate = this._daylightSavingAdjust(new Date(drawYear, drawMonth, inst.selectedDay));
				var cornerClass = &#39; ui-corner-all&#39;;
				var calender = &#39;&#39;;
				if (isMultiMonth) {
					calender += &#39;</span><span class="xd">&lt;</span><span class="xn">div </span><span class="xan">class</span><span class="xd">=</span>&quot;<span class="xav">ui-datepicker-group&#39;;
					if (numMonths[1] &gt; 1)
						switch (col) {
							case 0: calender += &#39; ui-datepicker-group-first&#39;;
								cornerClass = &#39; ui-corner-&#39; + (isRTL ? &#39;right&#39; : &#39;left&#39;); break;
							case numMonths[1]-1: calender += &#39; ui-datepicker-group-last&#39;;
								cornerClass = &#39; ui-corner-&#39; + (isRTL ? &#39;left&#39; : &#39;right&#39;); break;
							default: calender += &#39; ui-datepicker-group-middle&#39;; cornerClass = &#39;&#39;; break;
						}
					calender += &#39;</span>&quot;<span class="xd">&gt;</span>&#39;;
				}
				calender += &#39;<span class="xd">&lt;</span><span class="xn">div </span><span class="xan">class</span><span class="xd">=</span>&quot;<span class="xav">ui-datepicker-header ui-widget-header ui-helper-clearfix&#39; + cornerClass + &#39;</span>&quot;<span class="xd">&gt;</span>&#39; +
					(/all|left/.test(cornerClass) <span class="xer">&amp;</span><span class="xer">&amp;</span> row == 0 ? (isRTL ? next : prev) : &#39;&#39;) +
					(/all|right/.test(cornerClass) <span class="xer">&amp;</span><span class="xer">&amp;</span> row == 0 ? (isRTL ? prev : next) : &#39;&#39;) +
					this._generateMonthYearHeader(inst, drawMonth, drawYear, minDate, maxDate,
					row &gt; 0 || col &gt; 0, monthNames, monthNamesShort) + // draw month headers
					&#39;<span class="xd">&lt;/</span><span class="xn">div</span><span class="xd">&gt;</span><span class="xd">&lt;</span><span class="xn">table </span><span class="xan">class</span><span class="xd">=</span>&quot;<span class="xav">ui-datepicker-calendar</span>&quot;<span class="xd">&gt;</span><span class="xd">&lt;</span><span class="xn">thead</span><span class="xd">&gt;</span>&#39; +
					&#39;<span class="xd">&lt;</span><span class="xn">tr</span><span class="xd">&gt;</span>&#39;;
				var thead = (showWeek ? &#39;<span class="xd">&lt;</span><span class="xn">th </span><span class="xan">class</span><span class="xd">=</span>&quot;<span class="xav">ui-datepicker-week-col</span>&quot;<span class="xd">&gt;</span>&#39; + this._get(inst, &#39;weekHeader&#39;) + &#39;<span class="xd">&lt;/</span><span class="xn">th</span><span class="xd">&gt;</span>&#39; : &#39;&#39;);
				for (var dow = 0; dow <span class="xd">&lt; </span><span class="xn">7</span><span class="xd">; dow++) { // days of the week
					var day = (dow + firstDay) % 7;
					thead += &#39;</span><span class="xd">&lt;</span><span class="xn">th</span>&#39;<span class="xav"> + ((dow + firstDay + 6) % 7 &gt;= 5 ? </span>&#39; <span class="xan">class</span><span class="xd">=</span>&quot;<span class="xav">ui-datepicker-week-end</span>&quot;&#39;<span class="xav"> : </span>&#39;&#39;<span class="xav">) + </span>&#39;<span class="xd">&gt;</span>&#39; +
						&#39;<span class="xd">&lt;</span><span class="xn">span </span><span class="xan">title</span><span class="xd">=</span>&quot;<span class="xav">&#39; + dayNames[day] + &#39;</span>&quot;<span class="xd">&gt;</span>&#39; + dayNamesMin[day] + &#39;<span class="xd">&lt;/</span><span class="xn">span</span><span class="xd">&gt;</span><span class="xd">&lt;/</span><span class="xn">th</span><span class="xd">&gt;</span>&#39;;
				}
				calender += thead + &#39;<span class="xd">&lt;/</span><span class="xn">tr</span><span class="xd">&gt;</span><span class="xd">&lt;/</span><span class="xn">thead</span><span class="xd">&gt;</span><span class="xd">&lt;</span><span class="xn">tbody</span><span class="xd">&gt;</span>&#39;;
				var daysInMonth = this._getDaysInMonth(drawYear, drawMonth);
				if (drawYear == inst.selectedYear <span class="xer">&amp;</span><span class="xer">&amp;</span> drawMonth == inst.selectedMonth)
					inst.selectedDay = Math.min(inst.selectedDay, daysInMonth);
				var leadDays = (this._getFirstDayOfMonth(drawYear, drawMonth) - firstDay + 7) % 7;
				var curRows = Math.ceil((leadDays + daysInMonth) / 7); // calculate the number of rows to generate
				var numRows = (isMultiMonth ? this.maxRows &gt; curRows ? this.maxRows : curRows : curRows); //If multiple months, use the higher number of rows (see #7043)
				this.maxRows = numRows;
				var printDate = this._daylightSavingAdjust(new Date(drawYear, drawMonth, 1 - leadDays));
				for (var dRow = 0; dRow <span class="xd">&lt; </span><span class="xn">numRows</span><span class="xd">; dRow++) { // create date picker rows
					calender += &#39;</span><span class="xd">&lt;</span><span class="xn">tr</span><span class="xd">&gt;</span>&#39;;
					var tbody = (!showWeek ? &#39;&#39; : &#39;<span class="xd">&lt;</span><span class="xn">td </span><span class="xan">class</span><span class="xd">=</span>&quot;<span class="xav">ui-datepicker-week-col</span>&quot;<span class="xd">&gt;</span>&#39; +
						this._get(inst, &#39;calculateWeek&#39;)(printDate) + &#39;<span class="xd">&lt;/</span><span class="xn">td</span><span class="xd">&gt;</span>&#39;);
					for (var dow = 0; dow <span class="xd">&lt; </span><span class="xn">7</span><span class="xd">; dow++) { // create date picker days
						var daySettings = (beforeShowDay ?
							beforeShowDay.apply((inst.input ? inst.input[0] : null), [printDate]) : [true, &#39;&#39;]);
						var otherMonth = (printDate.getMonth() != drawMonth);
						var unselectable = (otherMonth &amp;&amp; !selectOtherMonths) || !daySettings[0] ||
							(minDate &amp;&amp; printDate </span><span class="xd">&lt; </span><span class="xn">minDate</span><span class="xd">) || (maxDate &amp;&amp; printDate &gt;</span> maxDate);
						tbody += &#39;<span class="xd">&lt;</span><span class="xn">td </span><span class="xan">class</span><span class="xd">=</span>&quot;<span class="xav">&#39; +
							((dow + firstDay + 6) % 7 &gt;= 5 ? &#39; ui-datepicker-week-end&#39; : &#39;&#39;) + // highlight weekends
							(otherMonth ? &#39; ui-datepicker-other-month&#39; : &#39;&#39;) + // highlight days from other months
							((printDate.getTime() == selectedDate.getTime() &amp;&amp; drawMonth == inst.selectedMonth &amp;&amp; inst._keyEvent) || // user pressed key
							(defaultDate.getTime() == printDate.getTime() &amp;&amp; defaultDate.getTime() == selectedDate.getTime()) ?
							// or defaultDate is current printedDate and defaultDate is selectedDate
							&#39; &#39; + this._dayOverClass : &#39;&#39;) + // highlight selected day
							(unselectable ? &#39; &#39; + this._unselectableClass + &#39; ui-state-disabled&#39;: &#39;&#39;) +  // highlight unselectable days
							(otherMonth &amp;&amp; !showOtherMonths ? &#39;&#39; : &#39; &#39; + daySettings[1] + // highlight custom dates
							(printDate.getTime() == currentDate.getTime() ? &#39; &#39; + this._currentClass : &#39;&#39;) + // highlight selected day
							(printDate.getTime() == today.getTime() ? &#39; ui-datepicker-today&#39; : &#39;&#39;)) + &#39;</span>&quot;&#39;<span class="xav"> + // highlight today (if different)
							((!otherMonth || showOtherMonths) &amp;&amp; daySettings[2] ? </span>&#39; <span class="xan">title</span><span class="xd">=</span>&quot;<span class="xav">&#39; + daySettings[2] + &#39;</span>&quot;&#39;<span class="xav"> : </span>&#39;&#39;<span class="xav">) + // cell title
							(unselectable ? </span>&#39;&#39;<span class="xav"> : </span>&#39; <span class="xan">onclick</span><span class="xd">=</span>&quot;<span class="xav">DP_jQuery_&#39; + dpuuid + &#39;.datepicker._selectDay(\&#39;#&#39; +
							inst.id + &#39;\&#39;,&#39; + printDate.getMonth() + &#39;,&#39; + printDate.getFullYear() + &#39;, this);return false;</span>&quot;&#39;<span class="xav">) + </span>&#39;<span class="xd">&gt;</span>&#39; + // actions
							(otherMonth <span class="xer">&amp;</span><span class="xer">&amp;</span> !showOtherMonths ? &#39;<span class="xer">&amp;#xa0;</span>&#39; : // display for other months
							(unselectable ? &#39;<span class="xd">&lt;</span><span class="xn">span </span><span class="xan">class</span><span class="xd">=</span>&quot;<span class="xav">ui-state-default</span>&quot;<span class="xd">&gt;</span>&#39; + printDate.getDate() + &#39;<span class="xd">&lt;/</span><span class="xn">span</span><span class="xd">&gt;</span>&#39; : &#39;<span class="xd">&lt;</span><span class="xn">a </span><span class="xan">class</span><span class="xd">=</span>&quot;<span class="xav">ui-state-default&#39; +
							(printDate.getTime() == today.getTime() ? &#39; ui-state-highlight&#39; : &#39;&#39;) +
							(printDate.getTime() == currentDate.getTime() ? &#39; ui-state-active&#39; : &#39;&#39;) + // highlight selected day
							(otherMonth ? &#39; ui-priority-secondary&#39; : &#39;&#39;) + // distinguish dates from other months
							&#39;</span>&quot; <span class="xan">href</span><span class="xd">=</span>&quot;<span class="xav">#</span>&quot;<span class="xd">&gt;</span>&#39; + printDate.getDate() + &#39;<span class="xd">&lt;/</span><span class="xn">a</span><span class="xd">&gt;</span>&#39;)) + &#39;<span class="xd">&lt;/</span><span class="xn">td</span><span class="xd">&gt;</span>&#39;; // display selectable date
						printDate.setDate(printDate.getDate() + 1);
						printDate = this._daylightSavingAdjust(printDate);
					}
					calender += tbody + &#39;<span class="xd">&lt;/</span><span class="xn">tr</span><span class="xd">&gt;</span>&#39;;
				}
				drawMonth++;
				if (drawMonth &gt; 11) {
					drawMonth = 0;
					drawYear++;
				}
				calender += &#39;<span class="xd">&lt;/</span><span class="xn">tbody</span><span class="xd">&gt;</span><span class="xd">&lt;/</span><span class="xn">table</span><span class="xd">&gt;</span>&#39; + (isMultiMonth ? &#39;<span class="xd">&lt;/</span><span class="xn">div</span><span class="xd">&gt;</span>&#39; + 
							((numMonths[0] &gt; 0 <span class="xer">&amp;</span><span class="xer">&amp;</span> col == numMonths[1]-1) ? &#39;<span class="xd">&lt;</span><span class="xn">div </span><span class="xan">class</span><span class="xd">=</span>&quot;<span class="xav">ui-datepicker-row-break</span>&quot;<span class="xd">&gt;</span><span class="xd">&lt;/</span><span class="xn">div</span><span class="xd">&gt;</span>&#39; : &#39;&#39;) : &#39;&#39;);
				group += calender;
			}
			html += group;
		}
		html += buttonPanel + ($.browser.msie <span class="xer">&amp;</span><span class="xer">&amp;</span> parseInt($.browser.version,10) <span class="xd">&lt; </span><span class="xn">7 </span><span class="xan">&amp;&amp; </span><span class="xd">!inst.inline ?
			&#39;</span><span class="xd">&lt;</span><span class="xn">iframe </span><span class="xan">src</span><span class="xd">=</span>&quot;<span class="xav">javascript:false;</span>&quot; <span class="xan">class</span><span class="xd">=</span>&quot;<span class="xav">ui-datepicker-cover</span>&quot; <span class="xan">frameborder</span><span class="xd">=</span>&quot;<span class="xav">0</span>&quot;<span class="xd">&gt;</span><span class="xd">&lt;/</span><span class="xn">iframe</span><span class="xd">&gt;</span>&#39; : &#39;&#39;);
		inst._keyEvent = false;
		return html;
	},

	/* Generate the month and year header. */
	_generateMonthYearHeader: function(inst, drawMonth, drawYear, minDate, maxDate,
			secondary, monthNames, monthNamesShort) {
		var changeMonth = this._get(inst, &#39;changeMonth&#39;);
		var changeYear = this._get(inst, &#39;changeYear&#39;);
		var showMonthAfterYear = this._get(inst, &#39;showMonthAfterYear&#39;);
		var html = &#39;<span class="xd">&lt;</span><span class="xn">div </span><span class="xan">class</span><span class="xd">=</span>&quot;<span class="xav">ui-datepicker-title</span>&quot;<span class="xd">&gt;</span>&#39;;
		var monthHtml = &#39;&#39;;
		// month selection
		if (secondary || !changeMonth)
			monthHtml += &#39;<span class="xd">&lt;</span><span class="xn">span </span><span class="xan">class</span><span class="xd">=</span>&quot;<span class="xav">ui-datepicker-month</span>&quot;<span class="xd">&gt;</span>&#39; + monthNames[drawMonth] + &#39;<span class="xd">&lt;/</span><span class="xn">span</span><span class="xd">&gt;</span>&#39;;
		else {
			var inMinYear = (minDate <span class="xer">&amp;</span><span class="xer">&amp;</span> minDate.getFullYear() == drawYear);
			var inMaxYear = (maxDate <span class="xer">&amp;</span><span class="xer">&amp;</span> maxDate.getFullYear() == drawYear);
			monthHtml += &#39;<span class="xd">&lt;</span><span class="xn">select </span><span class="xan">class</span><span class="xd">=</span>&quot;<span class="xav">ui-datepicker-month</span>&quot; &#39;<span class="xav"> +
				</span>&#39;<span class="xan">onchange</span><span class="xd">=</span>&quot;<span class="xav">DP_jQuery_&#39; + dpuuid + &#39;.datepicker._selectMonthYear(\&#39;#&#39; + inst.id + &#39;\&#39;, this, \&#39;M\&#39;);</span>&quot; &#39;<span class="xav"> +
			 	</span>&#39;<span class="xd">&gt;</span>&#39;;
			for (var month = 0; month <span class="xd">&lt; </span><span class="xn">12</span><span class="xd">; month++) {
				if ((!inMinYear || month &gt;</span>= minDate.getMonth()) <span class="xer">&amp;</span><span class="xer">&amp;</span>
						(!inMaxYear || month <span class="xd">&lt;</span><span class="xd">= </span><span class="xav">maxDate.getMonth()))</span><span class="xan">
					monthHtml </span><span class="xan">+</span><span class="xd">= </span>&#39;<span class="xd">&lt;</span><span class="xn">option </span><span class="xan">value</span><span class="xd">=</span>&quot;<span class="xav">&#39; + month + &#39;</span>&quot;&#39;<span class="xav"> +
						(month == drawMonth ? </span>&#39; <span class="xan">selected</span><span class="xd">=</span>&quot;<span class="xav">selected</span>&quot;&#39;<span class="xav"> : </span>&#39;&#39;<span class="xav">) +
						</span>&#39;<span class="xd">&gt;</span>&#39; + monthNamesShort[month] + &#39;<span class="xd">&lt;/</span><span class="xn">option</span><span class="xd">&gt;</span>&#39;;
			}
			monthHtml += &#39;<span class="xd">&lt;/</span><span class="xn">select</span><span class="xd">&gt;</span>&#39;;
		}
		if (!showMonthAfterYear)
			html += monthHtml + (secondary || !(changeMonth <span class="xer">&amp;</span><span class="xer">&amp;</span> changeYear) ? &#39;<span class="xer">&amp;#xa0;</span>&#39; : &#39;&#39;);
		// year selection
		if ( !inst.yearshtml ) {
			inst.yearshtml = &#39;&#39;;
			if (secondary || !changeYear)
				html += &#39;<span class="xd">&lt;</span><span class="xn">span </span><span class="xan">class</span><span class="xd">=</span>&quot;<span class="xav">ui-datepicker-year</span>&quot;<span class="xd">&gt;</span>&#39; + drawYear + &#39;<span class="xd">&lt;/</span><span class="xn">span</span><span class="xd">&gt;</span>&#39;;
			else {
				// determine range of years to display
				var years = this._get(inst, &#39;yearRange&#39;).split(&#39;:&#39;);
				var thisYear = new Date().getFullYear();
				var determineYear = function(value) {
					var year = (value.match(/c[+-].*/) ? drawYear + parseInt(value.substring(1), 10) :
						(value.match(/[+-].*/) ? thisYear + parseInt(value, 10) :
						parseInt(value, 10)));
					return (isNaN(year) ? thisYear : year);
				};
				var year = determineYear(years[0]);
				var endYear = Math.max(year, determineYear(years[1] || &#39;&#39;));
				year = (minDate ? Math.max(year, minDate.getFullYear()) : year);
				endYear = (maxDate ? Math.min(endYear, maxDate.getFullYear()) : endYear);
				inst.yearshtml += &#39;<span class="xd">&lt;</span><span class="xn">select </span><span class="xan">class</span><span class="xd">=</span>&quot;<span class="xav">ui-datepicker-year</span>&quot; &#39;<span class="xav"> +
					</span>&#39;<span class="xan">onchange</span><span class="xd">=</span>&quot;<span class="xav">DP_jQuery_&#39; + dpuuid + &#39;.datepicker._selectMonthYear(\&#39;#&#39; + inst.id + &#39;\&#39;, this, \&#39;Y\&#39;);</span>&quot; &#39;<span class="xav"> +
					</span>&#39;<span class="xd">&gt;</span>&#39;;
				for (; year <span class="xd">&lt;</span><span class="xd">= </span><span class="xav">endYear;</span><span class="xan"> year++</span><span class="xd">) {
					inst.yearshtml += &#39;</span><span class="xd">&lt;</span><span class="xn">option </span><span class="xan">value</span><span class="xd">=</span>&quot;<span class="xav">&#39; + year + &#39;</span>&quot;&#39;<span class="xav"> +
						(year == drawYear ? </span>&#39; <span class="xan">selected</span><span class="xd">=</span>&quot;<span class="xav">selected</span>&quot;&#39;<span class="xav"> : </span>&#39;&#39;<span class="xav">) +
						</span>&#39;<span class="xd">&gt;</span>&#39; + year + &#39;<span class="xd">&lt;/</span><span class="xn">option</span><span class="xd">&gt;</span>&#39;;
				}
				inst.yearshtml += &#39;<span class="xd">&lt;/</span><span class="xn">select</span><span class="xd">&gt;</span>&#39;;
				
				html += inst.yearshtml;
				inst.yearshtml = null;
			}
		}
		html += this._get(inst, &#39;yearSuffix&#39;);
		if (showMonthAfterYear)
			html += (secondary || !(changeMonth <span class="xer">&amp;</span><span class="xer">&amp;</span> changeYear) ? &#39;<span class="xer">&amp;#xa0;</span>&#39; : &#39;&#39;) + monthHtml;
		html += &#39;<span class="xd">&lt;/</span><span class="xn">div</span><span class="xd">&gt;</span>&#39;; // Close datepicker_header
		return html;
	},

	/* Adjust one of the date sub-fields. */
	_adjustInstDate: function(inst, offset, period) {
		var year = inst.drawYear + (period == &#39;Y&#39; ? offset : 0);
		var month = inst.drawMonth + (period == &#39;M&#39; ? offset : 0);
		var day = Math.min(inst.selectedDay, this._getDaysInMonth(year, month)) +
			(period == &#39;D&#39; ? offset : 0);
		var date = this._restrictMinMax(inst,
			this._daylightSavingAdjust(new Date(year, month, day)));
		inst.selectedDay = date.getDate();
		inst.drawMonth = inst.selectedMonth = date.getMonth();
		inst.drawYear = inst.selectedYear = date.getFullYear();
		if (period == &#39;M&#39; || period == &#39;Y&#39;)
			this._notifyChange(inst);
	},

	/* Ensure a date is within any min/max bounds. */
	_restrictMinMax: function(inst, date) {
		var minDate = this._getMinMaxDate(inst, &#39;min&#39;);
		var maxDate = this._getMinMaxDate(inst, &#39;max&#39;);
		var newDate = (minDate <span class="xer">&amp;</span><span class="xer">&amp;</span> date <span class="xd">&lt; </span><span class="xn">minDate </span><span class="xd">? minDate : date);
		newDate = (maxDate &amp;&amp; newDate &gt;</span> maxDate ? maxDate : newDate);
		return newDate;
	},

	/* Notify change of month/year. */
	_notifyChange: function(inst) {
		var onChange = this._get(inst, &#39;onChangeMonthYear&#39;);
		if (onChange)
			onChange.apply((inst.input ? inst.input[0] : null),
				[inst.selectedYear, inst.selectedMonth + 1, inst]);
	},

	/* Determine the number of months to show. */
	_getNumberOfMonths: function(inst) {
		var numMonths = this._get(inst, &#39;numberOfMonths&#39;);
		return (numMonths == null ? [1, 1] : (typeof numMonths == &#39;number&#39; ? [1, numMonths] : numMonths));
	},

	/* Determine the current maximum date - ensure no time components are set. */
	_getMinMaxDate: function(inst, minMax) {
		return this._determineDate(inst, this._get(inst, minMax + &#39;Date&#39;), null);
	},

	/* Find the number of days in a given month. */
	_getDaysInMonth: function(year, month) {
		return 32 - this._daylightSavingAdjust(new Date(year, month, 32)).getDate();
	},

	/* Find the day of the week of the first of a month. */
	_getFirstDayOfMonth: function(year, month) {
		return new Date(year, month, 1).getDay();
	},

	/* Determines if we should allow a &quot;next/prev&quot; month display change. */
	_canAdjustMonth: function(inst, offset, curYear, curMonth) {
		var numMonths = this._getNumberOfMonths(inst);
		var date = this._daylightSavingAdjust(new Date(curYear,
			curMonth + (offset <span class="xd">&lt; </span><span class="xn">0 </span><span class="xd">? offset : numMonths[0] * numMonths[1]), 1));
		if (offset </span><span class="xd">&lt; </span><span class="xn">0</span><span class="xd">)
			date.setDate(this._getDaysInMonth(date.getFullYear(), date.getMonth()));
		return this._isInRange(inst, date);
	},

	/* Is the given date in the accepted range? */
	_isInRange: function(inst, date) {
		var minDate = this._getMinMaxDate(inst, &#39;min&#39;);
		var maxDate = this._getMinMaxDate(inst, &#39;max&#39;);
		return ((!minDate || date.getTime() &gt;</span>= minDate.getTime()) <span class="xer">&amp;</span><span class="xer">&amp;</span>
			(!maxDate || date.getTime() <span class="xd">&lt;</span><span class="xd">= </span><span class="xav">maxDate.getTime()));</span><span class="xd">
	},

	/* Provide the configuration settings for formatting/parsing. */
	_getFormatConfig: function(inst) {
		var shortYearCutoff = this._get(inst, &#39;shortYearCutoff&#39;);
		shortYearCutoff = (typeof shortYearCutoff != &#39;string&#39; ? shortYearCutoff :
			new Date().getFullYear() % 100 + parseInt(shortYearCutoff, 10));
		return {shortYearCutoff: shortYearCutoff,
			dayNamesShort: this._get(inst, &#39;dayNamesShort&#39;), dayNames: this._get(inst, &#39;dayNames&#39;),
			monthNamesShort: this._get(inst, &#39;monthNamesShort&#39;), monthNames: this._get(inst, &#39;monthNames&#39;)};
	},

	/* Format the given date for display. */
	_formatDate: function(inst, day, month, year) {
		if (!day) {
			inst.currentDay = inst.selectedDay;
			inst.currentMonth = inst.selectedMonth;
			inst.currentYear = inst.selectedYear;
		}
		var date = (day ? (typeof day == &#39;object&#39; ? day :
			this._daylightSavingAdjust(new Date(year, month, day))) :
			this._daylightSavingAdjust(new Date(inst.currentYear, inst.currentMonth, inst.currentDay)));
		return this.formatDate(this._get(inst, &#39;dateFormat&#39;), date, this._getFormatConfig(inst));
	}
});

/*
 * Bind hover events for datepicker elements.
 * Done via delegate so the binding only occurs once in the lifetime of the parent div.
 * Global instActive, set by _updateDatepicker allows the handlers to find their way back to the active picker.
 */ 
function bindHover(dpDiv) {
	var selector = &#39;button, .ui-datepicker-prev, .ui-datepicker-next, .ui-datepicker-calendar td a&#39;;
	return dpDiv.bind(&#39;mouseout&#39;, function(event) {
			var elem = $( event.target ).closest( selector );
			if ( !elem.length ) {
				return;
			}
			elem.removeClass( &quot;ui-state-hover ui-datepicker-prev-hover ui-datepicker-next-hover&quot; );
		})
		.bind(&#39;mouseover&#39;, function(event) {
			var elem = $( event.target ).closest( selector );
			if ($.datepicker._isDisabledDatepicker( instActive.inline ? dpDiv.parent()[0] : instActive.input[0]) ||
					!elem.length ) {
				return;
			}
			elem.parents(&#39;.ui-datepicker-calendar&#39;).find(&#39;a&#39;).removeClass(&#39;ui-state-hover&#39;);
			elem.addClass(&#39;ui-state-hover&#39;);
			if (elem.hasClass(&#39;ui-datepicker-prev&#39;)) elem.addClass(&#39;ui-datepicker-prev-hover&#39;);
			if (elem.hasClass(&#39;ui-datepicker-next&#39;)) elem.addClass(&#39;ui-datepicker-next-hover&#39;);
		});
}

/* jQuery extend now ignores nulls! */
function extendRemove(target, props) {
	$.extend(target, props);
	for (var name in props)
		if (props[name] == null || props[name] == undefined)
			target[name] = props[name];
	return target;
};

/* Determine whether an object is an array. */
function isArray(a) {
	return (a &amp;&amp; (($.browser.safari &amp;&amp; typeof a == &#39;object&#39; &amp;&amp; a.length) ||
		(a.constructor &amp;&amp; a.constructor.toString().match(/\Array\(\)/))));
};

/* Invoke the datepicker functionality.
   @param  options  string - a command, optionally followed by additional parameters or
                    Object - settings for attaching new datepicker functionality
   @return  jQuery object */
$.fn.datepicker = function(options){
	
	/* Verify an empty collection wasn&#39;t passed - Fixes #6976 */
	if ( !this.length ) {
		return this;
	}
	
	/* Initialise the date picker. */
	if (!$.datepicker.initialized) {
		$(document).mousedown($.datepicker._checkExternalClick).
			find(&#39;body&#39;).append($.datepicker.dpDiv);
		$.datepicker.initialized = true;
	}

	var otherArgs = Array.prototype.slice.call(arguments, 1);
	if (typeof options == &#39;string&#39; &amp;&amp; (options == &#39;isDisabled&#39; || options == &#39;getDate&#39; || options == &#39;widget&#39;))
		return $.datepicker[&#39;_&#39; + options + &#39;Datepicker&#39;].
			apply($.datepicker, [this[0]].concat(otherArgs));
	if (options == &#39;option&#39; &amp;&amp; arguments.length == 2 &amp;&amp; typeof arguments[1] == &#39;string&#39;)
		return $.datepicker[&#39;_&#39; + options + &#39;Datepicker&#39;].
			apply($.datepicker, [this[0]].concat(otherArgs));
	return this.each(function() {
		typeof options == &#39;string&#39; ?
			$.datepicker[&#39;_&#39; + options + &#39;Datepicker&#39;].
				apply($.datepicker, [this].concat(otherArgs)) :
			$.datepicker._attachDatepicker(this, options);
	});
};

$.datepicker = new Datepicker(); // singleton instance
$.datepicker.initialized = false;
$.datepicker.uuid = new Date().getTime();
$.datepicker.version = &quot;1.8.18&quot;;

// Workaround for #4055
// Add another global to avoid noConflict issues with inline event handlers
window[&#39;DP_jQuery_&#39; + dpuuid] = $;

})(jQuery);
/*
 * jQuery UI Progressbar 1.8.18
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Progressbar
 *
 * Depends:
 *   jquery.ui.core.js
 *   jquery.ui.widget.js
 */
(function( $, undefined ) {

$.widget( &quot;ui.progressbar&quot;, {
	options: {
		value: 0,
		max: 100
	},

	min: 0,

	_create: function() {
		this.element
			.addClass( &quot;ui-progressbar ui-widget ui-widget-content ui-corner-all&quot; )
			.attr({
				role: &quot;progressbar&quot;,
				&quot;aria-valuemin&quot;: this.min,
				&quot;aria-valuemax&quot;: this.options.max,
				&quot;aria-valuenow&quot;: this._value()
			});

		this.valueDiv = $( &quot;</span><span class="xd">&lt;</span><span class="xn">div </span><span class="xan">class</span><span class="xd">=</span>&#39;<span class="xav">ui-progressbar-value ui-widget-header ui-corner-left</span>&#39;<span class="xd">&gt;</span><span class="xd">&lt;/</span><span class="xn">div</span><span class="xd">&gt;</span>&quot; )
			.appendTo( this.element );

		this.oldValue = this._value();
		this._refreshValue();
	},

	destroy: function() {
		this.element
			.removeClass( &quot;ui-progressbar ui-widget ui-widget-content ui-corner-all&quot; )
			.removeAttr( &quot;role&quot; )
			.removeAttr( &quot;aria-valuemin&quot; )
			.removeAttr( &quot;aria-valuemax&quot; )
			.removeAttr( &quot;aria-valuenow&quot; );

		this.valueDiv.remove();

		$.Widget.prototype.destroy.apply( this, arguments );
	},

	value: function( newValue ) {
		if ( newValue === undefined ) {
			return this._value();
		}

		this._setOption( &quot;value&quot;, newValue );
		return this;
	},

	_setOption: function( key, value ) {
		if ( key === &quot;value&quot; ) {
			this.options.value = value;
			this._refreshValue();
			if ( this._value() === this.options.max ) {
				this._trigger( &quot;complete&quot; );
			}
		}

		$.Widget.prototype._setOption.apply( this, arguments );
	},

	_value: function() {
		var val = this.options.value;
		// normalize invalid value
		if ( typeof val !== &quot;number&quot; ) {
			val = 0;
		}
		return Math.min( this.options.max, Math.max( this.min, val ) );
	},

	_percentage: function() {
		return 100 * this._value() / this.options.max;
	},

	_refreshValue: function() {
		var value = this.value();
		var percentage = this._percentage();

		if ( this.oldValue !== value ) {
			this.oldValue = value;
			this._trigger( &quot;change&quot; );
		}

		this.valueDiv
			.toggle( value &gt; this.min )
			.toggleClass( &quot;ui-corner-right&quot;, value === this.options.max )
			.width( percentage.toFixed(0) + &quot;%&quot; );
		this.element.attr( &quot;aria-valuenow&quot;, value );
	}
});

$.extend( $.ui.progressbar, {
	version: &quot;1.8.18&quot;
});

})( jQuery );
/*
 * jQuery UI Effects 1.8.18
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Effects/
 */
;jQuery.effects || (function($, undefined) {

$.effects = {};



/******************************************************************************/
/****************************** COLOR ANIMATIONS ******************************/
/******************************************************************************/

// override the animation for color styles
$.each([&#39;backgroundColor&#39;, &#39;borderBottomColor&#39;, &#39;borderLeftColor&#39;,
	&#39;borderRightColor&#39;, &#39;borderTopColor&#39;, &#39;borderColor&#39;, &#39;color&#39;, &#39;outlineColor&#39;],
function(i, attr) {
	$.fx.step[attr] = function(fx) {
		if (!fx.colorInit) {
			fx.start = getColor(fx.elem, attr);
			fx.end = getRGB(fx.end);
			fx.colorInit = true;
		}

		fx.elem.style[attr] = &#39;rgb(&#39; +
			Math.max(Math.min(parseInt((fx.pos * (fx.end[0] - fx.start[0])) + fx.start[0], 10), 255), 0) + &#39;,&#39; +
			Math.max(Math.min(parseInt((fx.pos * (fx.end[1] - fx.start[1])) + fx.start[1], 10), 255), 0) + &#39;,&#39; +
			Math.max(Math.min(parseInt((fx.pos * (fx.end[2] - fx.start[2])) + fx.start[2], 10), 255), 0) + &#39;)&#39;;
	};
});

// Color Conversion functions from highlightFade
// By Blair Mitchelmore
// http://jquery.offput.ca/highlightFade/

// Parse strings looking for color tuples [255,255,255]
function getRGB(color) {
		var result;

		// Check if we&#39;re already dealing with an array of colors
		if ( color <span class="xer">&amp;</span><span class="xer">&amp;</span> color.constructor == Array <span class="xer">&amp;</span><span class="xer">&amp;</span> color.length == 3 )
				return color;

		// Look for rgb(num,num,num)
		if (result = /rgb\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*\)/.exec(color))
				return [parseInt(result[1],10), parseInt(result[2],10), parseInt(result[3],10)];

		// Look for rgb(num%,num%,num%)
		if (result = /rgb\(\s*([0-9]+(?:\.[0-9]+)?)\%\s*,\s*([0-9]+(?:\.[0-9]+)?)\%\s*,\s*([0-9]+(?:\.[0-9]+)?)\%\s*\)/.exec(color))
				return [parseFloat(result[1])*2.55, parseFloat(result[2])*2.55, parseFloat(result[3])*2.55];

		// Look for #a0b1c2
		if (result = /#([a-fA-F0-9]{2})([a-fA-F0-9]{2})([a-fA-F0-9]{2})/.exec(color))
				return [parseInt(result[1],16), parseInt(result[2],16), parseInt(result[3],16)];

		// Look for #fff
		if (result = /#([a-fA-F0-9])([a-fA-F0-9])([a-fA-F0-9])/.exec(color))
				return [parseInt(result[1]+result[1],16), parseInt(result[2]+result[2],16), parseInt(result[3]+result[3],16)];

		// Look for rgba(0, 0, 0, 0) == transparent in Safari 3
		if (result = /rgba\(0, 0, 0, 0\)/.exec(color))
				return colors[&#39;transparent&#39;];

		// Otherwise, we&#39;re most likely dealing with a named color
		return colors[$.trim(color).toLowerCase()];
}

function getColor(elem, attr) {
		var color;

		do {
				color = $.curCSS(elem, attr);

				// Keep going until we find an element that has color, or we hit the body
				if ( color != &#39;&#39; <span class="xer">&amp;</span><span class="xer">&amp;</span> color != &#39;transparent&#39; || $.nodeName(elem, &quot;body&quot;) )
						break;

				attr = &quot;backgroundColor&quot;;
		} while ( elem = elem.parentNode );

		return getRGB(color);
};

// Some named colors to work with
// From Interface by Stefan Petre
// http://interface.eyecon.ro/

var colors = {
	aqua:[0,255,255],
	azure:[240,255,255],
	beige:[245,245,220],
	black:[0,0,0],
	blue:[0,0,255],
	brown:[165,42,42],
	cyan:[0,255,255],
	darkblue:[0,0,139],
	darkcyan:[0,139,139],
	darkgrey:[169,169,169],
	darkgreen:[0,100,0],
	darkkhaki:[189,183,107],
	darkmagenta:[139,0,139],
	darkolivegreen:[85,107,47],
	darkorange:[255,140,0],
	darkorchid:[153,50,204],
	darkred:[139,0,0],
	darksalmon:[233,150,122],
	darkviolet:[148,0,211],
	fuchsia:[255,0,255],
	gold:[255,215,0],
	green:[0,128,0],
	indigo:[75,0,130],
	khaki:[240,230,140],
	lightblue:[173,216,230],
	lightcyan:[224,255,255],
	lightgreen:[144,238,144],
	lightgrey:[211,211,211],
	lightpink:[255,182,193],
	lightyellow:[255,255,224],
	lime:[0,255,0],
	magenta:[255,0,255],
	maroon:[128,0,0],
	navy:[0,0,128],
	olive:[128,128,0],
	orange:[255,165,0],
	pink:[255,192,203],
	purple:[128,0,128],
	violet:[128,0,128],
	red:[255,0,0],
	silver:[192,192,192],
	white:[255,255,255],
	yellow:[255,255,0],
	transparent: [255,255,255]
};



/******************************************************************************/
/****************************** CLASS ANIMATIONS ******************************/
/******************************************************************************/

var classAnimationActions = [&#39;add&#39;, &#39;remove&#39;, &#39;toggle&#39;],
	shorthandStyles = {
		border: 1,
		borderBottom: 1,
		borderColor: 1,
		borderLeft: 1,
		borderRight: 1,
		borderTop: 1,
		borderWidth: 1,
		margin: 1,
		padding: 1
	};

function getElementStyles() {
	var style = document.defaultView
			? document.defaultView.getComputedStyle(this, null)
			: this.currentStyle,
		newStyle = {},
		key,
		camelCase;

	// webkit enumerates style porperties
	if (style <span class="xer">&amp;</span><span class="xer">&amp;</span> style.length <span class="xer">&amp;</span><span class="xer">&amp;</span> style[0] <span class="xer">&amp;</span><span class="xer">&amp;</span> style[style[0]]) {
		var len = style.length;
		while (len--) {
			key = style[len];
			if (typeof style[key] == &#39;string&#39;) {
				camelCase = key.replace(/\-(\w)/g, function(all, letter){
					return letter.toUpperCase();
				});
				newStyle[camelCase] = style[key];
			}
		}
	} else {
		for (key in style) {
			if (typeof style[key] === &#39;string&#39;) {
				newStyle[key] = style[key];
			}
		}
	}
	
	return newStyle;
}

function filterStyles(styles) {
	var name, value;
	for (name in styles) {
		value = styles[name];
		if (
			// ignore null and undefined values
			value == null ||
			// ignore functions (when does this occur?)
			$.isFunction(value) ||
			// shorthand styles that need to be expanded
			name in shorthandStyles ||
			// ignore scrollbars (break in IE)
			(/scrollbar/).test(name) ||

			// only colors or values that can be converted to numbers
			(!(/color/i).test(name) <span class="xer">&amp;</span><span class="xer">&amp;</span> isNaN(parseFloat(value)))
		) {
			delete styles[name];
		}
	}
	
	return styles;
}

function styleDifference(oldStyle, newStyle) {
	var diff = { _: 0 }, // http://dev.jquery.com/ticket/5459
		name;

	for (name in newStyle) {
		if (oldStyle[name] != newStyle[name]) {
			diff[name] = newStyle[name];
		}
	}

	return diff;
}

$.effects.animateClass = function(value, duration, easing, callback) {
	if ($.isFunction(easing)) {
		callback = easing;
		easing = null;
	}

	return this.queue(function() {
		var that = $(this),
			originalStyleAttr = that.attr(&#39;style&#39;) || &#39; &#39;,
			originalStyle = filterStyles(getElementStyles.call(this)),
			newStyle,
			className = that.attr(&#39;class&#39;);

		$.each(classAnimationActions, function(i, action) {
			if (value[action]) {
				that[action + &#39;Class&#39;](value[action]);
			}
		});
		newStyle = filterStyles(getElementStyles.call(this));
		that.attr(&#39;class&#39;, className);

		that.animate(styleDifference(originalStyle, newStyle), {
			queue: false,
			duration: duration,
			easing: easing,
			complete: function() {
				$.each(classAnimationActions, function(i, action) {
					if (value[action]) { that[action + &#39;Class&#39;](value[action]); }
				});
				// work around bug in IE by clearing the cssText before setting it
				if (typeof that.attr(&#39;style&#39;) == &#39;object&#39;) {
					that.attr(&#39;style&#39;).cssText = &#39;&#39;;
					that.attr(&#39;style&#39;).cssText = originalStyleAttr;
				} else {
					that.attr(&#39;style&#39;, originalStyleAttr);
				}
				if (callback) { callback.apply(this, arguments); }
				$.dequeue( this );
			}
		});
	});
};

$.fn.extend({
	_addClass: $.fn.addClass,
	addClass: function(classNames, speed, easing, callback) {
		return speed ? $.effects.animateClass.apply(this, [{ add: classNames },speed,easing,callback]) : this._addClass(classNames);
	},

	_removeClass: $.fn.removeClass,
	removeClass: function(classNames,speed,easing,callback) {
		return speed ? $.effects.animateClass.apply(this, [{ remove: classNames },speed,easing,callback]) : this._removeClass(classNames);
	},

	_toggleClass: $.fn.toggleClass,
	toggleClass: function(classNames, force, speed, easing, callback) {
		if ( typeof force == &quot;boolean&quot; || force === undefined ) {
			if ( !speed ) {
				// without speed parameter;
				return this._toggleClass(classNames, force);
			} else {
				return $.effects.animateClass.apply(this, [(force?{add:classNames}:{remove:classNames}),speed,easing,callback]);
			}
		} else {
			// without switch parameter;
			return $.effects.animateClass.apply(this, [{ toggle: classNames },force,speed,easing]);
		}
	},

	switchClass: function(remove,add,speed,easing,callback) {
		return $.effects.animateClass.apply(this, [{ add: add, remove: remove },speed,easing,callback]);
	}
});



/******************************************************************************/
/*********************************** EFFECTS **********************************/
/******************************************************************************/

$.extend($.effects, {
	version: &quot;1.8.18&quot;,

	// Saves a set of properties in a data storage
	save: function(element, set) {
		for(var i=0; i <span class="xd">&lt; </span><span class="xn">set.length</span><span class="xd">; i++) {
			if(set[i] !== null) element.data(&quot;ec.storage.&quot;+set[i], element[0].style[set[i]]);
		}
	},

	// Restores a set of previously saved properties from a data storage
	restore: function(element, set) {
		for(var i=0; i </span><span class="xd">&lt; </span><span class="xn">set.length</span><span class="xd">; i++) {
			if(set[i] !== null) element.css(set[i], element.data(&quot;ec.storage.&quot;+set[i]));
		}
	},

	setMode: function(el, mode) {
		if (mode == &#39;toggle&#39;) mode = el.is(&#39;:hidden&#39;) ? &#39;show&#39; : &#39;hide&#39;; // Set for toggle
		return mode;
	},

	getBaseline: function(origin, original) { // Translates a [top,left] array into a baseline value
		// this should be a little more flexible in the future to handle a string &amp; hash
		var y, x;
		switch (origin[0]) {
			case &#39;top&#39;: y = 0; break;
			case &#39;middle&#39;: y = 0.5; break;
			case &#39;bottom&#39;: y = 1; break;
			default: y = origin[0] / original.height;
		};
		switch (origin[1]) {
			case &#39;left&#39;: x = 0; break;
			case &#39;center&#39;: x = 0.5; break;
			case &#39;right&#39;: x = 1; break;
			default: x = origin[1] / original.width;
		};
		return {x: x, y: y};
	},

	// Wraps the element around a wrapper that copies position properties
	createWrapper: function(element) {

		// if the element is already wrapped, return it
		if (element.parent().is(&#39;.ui-effects-wrapper&#39;)) {
			return element.parent();
		}

		// wrap the element
		var props = {
				width: element.outerWidth(true),
				height: element.outerHeight(true),
				&#39;float&#39;: element.css(&#39;float&#39;)
			},
			wrapper = $(&#39;</span><span class="xd">&lt;</span><span class="xn">div</span><span class="xd">&gt;</span><span class="xd">&lt;/</span><span class="xn">div</span><span class="xd">&gt;</span>&#39;)
				.addClass(&#39;ui-effects-wrapper&#39;)
				.css({
					fontSize: &#39;100%&#39;,
					background: &#39;transparent&#39;,
					border: &#39;none&#39;,
					margin: 0,
					padding: 0
				}),
			active = document.activeElement;

		element.wrap(wrapper);

		// Fixes #7595 - Elements lose focus when wrapped.
		if ( element[ 0 ] === active || $.contains( element[ 0 ], active ) ) {
			$( active ).focus();
		}
		
		wrapper = element.parent(); //Hotfix for jQuery 1.4 since some change in wrap() seems to actually loose the reference to the wrapped element

		// transfer positioning properties to the wrapper
		if (element.css(&#39;position&#39;) == &#39;static&#39;) {
			wrapper.css({ position: &#39;relative&#39; });
			element.css({ position: &#39;relative&#39; });
		} else {
			$.extend(props, {
				position: element.css(&#39;position&#39;),
				zIndex: element.css(&#39;z-index&#39;)
			});
			$.each([&#39;top&#39;, &#39;left&#39;, &#39;bottom&#39;, &#39;right&#39;], function(i, pos) {
				props[pos] = element.css(pos);
				if (isNaN(parseInt(props[pos], 10))) {
					props[pos] = &#39;auto&#39;;
				}
			});
			element.css({position: &#39;relative&#39;, top: 0, left: 0, right: &#39;auto&#39;, bottom: &#39;auto&#39; });
		}

		return wrapper.css(props).show();
	},

	removeWrapper: function(element) {
		var parent,
			active = document.activeElement;
		
		if (element.parent().is(&#39;.ui-effects-wrapper&#39;)) {
			parent = element.parent().replaceWith(element);
			// Fixes #7595 - Elements lose focus when wrapped.
			if ( element[ 0 ] === active || $.contains( element[ 0 ], active ) ) {
				$( active ).focus();
			}
			return parent;
		}
			
		return element;
	},

	setTransition: function(element, list, factor, value) {
		value = value || {};
		$.each(list, function(i, x){
			unit = element.cssUnit(x);
			if (unit[0] &gt; 0) value[x] = unit[0] * factor + unit[1];
		});
		return value;
	}
});


function _normalizeArguments(effect, options, speed, callback) {
	// shift params for method overloading
	if (typeof effect == &#39;object&#39;) {
		callback = options;
		speed = null;
		options = effect;
		effect = options.effect;
	}
	if ($.isFunction(options)) {
		callback = options;
		speed = null;
		options = {};
	}
        if (typeof options == &#39;number&#39; || $.fx.speeds[options]) {
		callback = speed;
		speed = options;
		options = {};
	}
	if ($.isFunction(speed)) {
		callback = speed;
		speed = null;
	}

	options = options || {};

	speed = speed || options.duration;
	speed = $.fx.off ? 0 : typeof speed == &#39;number&#39;
		? speed : speed in $.fx.speeds ? $.fx.speeds[speed] : $.fx.speeds._default;

	callback = callback || options.complete;

	return [effect, options, speed, callback];
}

function standardSpeed( speed ) {
	// valid standard speeds
	if ( !speed || typeof speed === &quot;number&quot; || $.fx.speeds[ speed ] ) {
		return true;
	}
	
	// invalid strings - treat as &quot;normal&quot; speed
	if ( typeof speed === &quot;string&quot; <span class="xer">&amp;</span><span class="xer">&amp;</span> !$.effects[ speed ] ) {
		return true;
	}
	
	return false;
}

$.fn.extend({
	effect: function(effect, options, speed, callback) {
		var args = _normalizeArguments.apply(this, arguments),
			// TODO: make effects take actual parameters instead of a hash
			args2 = {
				options: args[1],
				duration: args[2],
				callback: args[3]
			},
			mode = args2.options.mode,
			effectMethod = $.effects[effect];
		
		if ( $.fx.off || !effectMethod ) {
			// delegate to the original method (e.g., .show()) if possible
			if ( mode ) {
				return this[ mode ]( args2.duration, args2.callback );
			} else {
				return this.each(function() {
					if ( args2.callback ) {
						args2.callback.call( this );
					}
				});
			}
		}
		
		return effectMethod.call(this, args2);
	},

	_show: $.fn.show,
	show: function(speed) {
		if ( standardSpeed( speed ) ) {
			return this._show.apply(this, arguments);
		} else {
			var args = _normalizeArguments.apply(this, arguments);
			args[1].mode = &#39;show&#39;;
			return this.effect.apply(this, args);
		}
	},

	_hide: $.fn.hide,
	hide: function(speed) {
		if ( standardSpeed( speed ) ) {
			return this._hide.apply(this, arguments);
		} else {
			var args = _normalizeArguments.apply(this, arguments);
			args[1].mode = &#39;hide&#39;;
			return this.effect.apply(this, args);
		}
	},

	// jQuery core overloads toggle and creates _toggle
	__toggle: $.fn.toggle,
	toggle: function(speed) {
		if ( standardSpeed( speed ) || typeof speed === &quot;boolean&quot; || $.isFunction( speed ) ) {
			return this.__toggle.apply(this, arguments);
		} else {
			var args = _normalizeArguments.apply(this, arguments);
			args[1].mode = &#39;toggle&#39;;
			return this.effect.apply(this, args);
		}
	},

	// helper functions
	cssUnit: function(key) {
		var style = this.css(key), val = [];
		$.each( [&#39;em&#39;,&#39;px&#39;,&#39;%&#39;,&#39;pt&#39;], function(i, unit){
			if(style.indexOf(unit) &gt; 0)
				val = [parseFloat(style), unit];
		});
		return val;
	}
});



/******************************************************************************/
/*********************************** EASING ***********************************/
/******************************************************************************/

/*
 * jQuery Easing v1.3 - http://gsgd.co.uk/sandbox/jquery/easing/
 *
 * Uses the built in easing capabilities added In jQuery 1.1
 * to offer multiple easing options
 *
 * TERMS OF USE - jQuery Easing
 *
 * Open source under the BSD License.
 *
 * Copyright 2008 George McGinley Smith
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 *
 * Redistributions of source code must retain the above copyright notice, this list of
 * conditions and the following disclaimer.
 * Redistributions in binary form must reproduce the above copyright notice, this list
 * of conditions and the following disclaimer in the documentation and/or other materials
 * provided with the distribution.
 *
 * Neither the name of the author nor the names of contributors may be used to endorse
 * or promote products derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
 * GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
 * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 *
*/

// t: current time, b: begInnIng value, c: change In value, d: duration
$.easing.jswing = $.easing.swing;

$.extend($.easing,
{
	def: &#39;easeOutQuad&#39;,
	swing: function (x, t, b, c, d) {
		//alert($.easing.default);
		return $.easing[$.easing.def](x, t, b, c, d);
	},
	easeInQuad: function (x, t, b, c, d) {
		return c*(t/=d)*t + b;
	},
	easeOutQuad: function (x, t, b, c, d) {
		return -c *(t/=d)*(t-2) + b;
	},
	easeInOutQuad: function (x, t, b, c, d) {
		if ((t/=d/2) <span class="xd">&lt; </span><span class="xn">1</span><span class="xd">) return c/2*t*t + b;
		return -c/2 * ((--t)*(t-2) - 1) + b;
	},
	easeInCubic: function (x, t, b, c, d) {
		return c*(t/=d)*t*t + b;
	},
	easeOutCubic: function (x, t, b, c, d) {
		return c*((t=t/d-1)*t*t + 1) + b;
	},
	easeInOutCubic: function (x, t, b, c, d) {
		if ((t/=d/2) </span><span class="xd">&lt; </span><span class="xn">1</span><span class="xd">) return c/2*t*t*t + b;
		return c/2*((t-=2)*t*t + 2) + b;
	},
	easeInQuart: function (x, t, b, c, d) {
		return c*(t/=d)*t*t*t + b;
	},
	easeOutQuart: function (x, t, b, c, d) {
		return -c * ((t=t/d-1)*t*t*t - 1) + b;
	},
	easeInOutQuart: function (x, t, b, c, d) {
		if ((t/=d/2) </span><span class="xd">&lt; </span><span class="xn">1</span><span class="xd">) return c/2*t*t*t*t + b;
		return -c/2 * ((t-=2)*t*t*t - 2) + b;
	},
	easeInQuint: function (x, t, b, c, d) {
		return c*(t/=d)*t*t*t*t + b;
	},
	easeOutQuint: function (x, t, b, c, d) {
		return c*((t=t/d-1)*t*t*t*t + 1) + b;
	},
	easeInOutQuint: function (x, t, b, c, d) {
		if ((t/=d/2) </span><span class="xd">&lt; </span><span class="xn">1</span><span class="xd">) return c/2*t*t*t*t*t + b;
		return c/2*((t-=2)*t*t*t*t + 2) + b;
	},
	easeInSine: function (x, t, b, c, d) {
		return -c * Math.cos(t/d * (Math.PI/2)) + c + b;
	},
	easeOutSine: function (x, t, b, c, d) {
		return c * Math.sin(t/d * (Math.PI/2)) + b;
	},
	easeInOutSine: function (x, t, b, c, d) {
		return -c/2 * (Math.cos(Math.PI*t/d) - 1) + b;
	},
	easeInExpo: function (x, t, b, c, d) {
		return (t==0) ? b : c * Math.pow(2, 10 * (t/d - 1)) + b;
	},
	easeOutExpo: function (x, t, b, c, d) {
		return (t==d) ? b+c : c * (-Math.pow(2, -10 * t/d) + 1) + b;
	},
	easeInOutExpo: function (x, t, b, c, d) {
		if (t==0) return b;
		if (t==d) return b+c;
		if ((t/=d/2) </span><span class="xd">&lt; </span><span class="xn">1</span><span class="xd">) return c/2 * Math.pow(2, 10 * (t - 1)) + b;
		return c/2 * (-Math.pow(2, -10 * --t) + 2) + b;
	},
	easeInCirc: function (x, t, b, c, d) {
		return -c * (Math.sqrt(1 - (t/=d)*t) - 1) + b;
	},
	easeOutCirc: function (x, t, b, c, d) {
		return c * Math.sqrt(1 - (t=t/d-1)*t) + b;
	},
	easeInOutCirc: function (x, t, b, c, d) {
		if ((t/=d/2) </span><span class="xd">&lt; </span><span class="xn">1</span><span class="xd">) return -c/2 * (Math.sqrt(1 - t*t) - 1) + b;
		return c/2 * (Math.sqrt(1 - (t-=2)*t) + 1) + b;
	},
	easeInElastic: function (x, t, b, c, d) {
		var s=1.70158;var p=0;var a=c;
		if (t==0) return b;  if ((t/=d)==1) return b+c;  if (!p) p=d*.3;
		if (a </span><span class="xd">&lt; </span><span class="xn">Math.abs</span><span class="xd">(c)) { a=c; var s=p/4; }
		else var s = p/(2*Math.PI) * Math.asin (c/a);
		return -(a*Math.pow(2,10*(t-=1)) * Math.sin( (t*d-s)*(2*Math.PI)/p )) + b;
	},
	easeOutElastic: function (x, t, b, c, d) {
		var s=1.70158;var p=0;var a=c;
		if (t==0) return b;  if ((t/=d)==1) return b+c;  if (!p) p=d*.3;
		if (a </span><span class="xd">&lt; </span><span class="xn">Math.abs</span><span class="xd">(c)) { a=c; var s=p/4; }
		else var s = p/(2*Math.PI) * Math.asin (c/a);
		return a*Math.pow(2,-10*t) * Math.sin( (t*d-s)*(2*Math.PI)/p ) + c + b;
	},
	easeInOutElastic: function (x, t, b, c, d) {
		var s=1.70158;var p=0;var a=c;
		if (t==0) return b;  if ((t/=d/2)==2) return b+c;  if (!p) p=d*(.3*1.5);
		if (a </span><span class="xd">&lt; </span><span class="xn">Math.abs</span><span class="xd">(c)) { a=c; var s=p/4; }
		else var s = p/(2*Math.PI) * Math.asin (c/a);
		if (t </span><span class="xd">&lt; </span><span class="xn">1</span><span class="xd">) return -.5*(a*Math.pow(2,10*(t-=1)) * Math.sin( (t*d-s)*(2*Math.PI)/p )) + b;
		return a*Math.pow(2,-10*(t-=1)) * Math.sin( (t*d-s)*(2*Math.PI)/p )*.5 + c + b;
	},
	easeInBack: function (x, t, b, c, d, s) {
		if (s == undefined) s = 1.70158;
		return c*(t/=d)*t*((s+1)*t - s) + b;
	},
	easeOutBack: function (x, t, b, c, d, s) {
		if (s == undefined) s = 1.70158;
		return c*((t=t/d-1)*t*((s+1)*t + s) + 1) + b;
	},
	easeInOutBack: function (x, t, b, c, d, s) {
		if (s == undefined) s = 1.70158;
		if ((t/=d/2) </span><span class="xd">&lt; </span><span class="xn">1</span><span class="xd">) return c/2*(t*t*(((s*=(1.525))+1)*t - s)) + b;
		return c/2*((t-=2)*t*(((s*=(1.525))+1)*t + s) + 2) + b;
	},
	easeInBounce: function (x, t, b, c, d) {
		return c - $.easing.easeOutBounce (x, d-t, 0, c, d) + b;
	},
	easeOutBounce: function (x, t, b, c, d) {
		if ((t/=d) </span><span class="xd">&lt; </span><span class="xd">(1/2.75)) {
			return c*(7.5625*t*t) + b;
		} else if (t </span><span class="xd">&lt; </span><span class="xd">(2/2.75)) {
			return c*(7.5625*(t-=(1.5/2.75))*t + .75) + b;
		} else if (t </span><span class="xd">&lt; </span><span class="xd">(2.5/2.75)) {
			return c*(7.5625*(t-=(2.25/2.75))*t + .9375) + b;
		} else {
			return c*(7.5625*(t-=(2.625/2.75))*t + .984375) + b;
		}
	},
	easeInOutBounce: function (x, t, b, c, d) {
		if (t </span><span class="xd">&lt; </span><span class="xn">d</span><span class="xd">/2) return $.easing.easeInBounce (x, t*2, 0, c, d) * .5 + b;
		return $.easing.easeOutBounce (x, t*2-d, 0, c, d) * .5 + c*.5 + b;
	}
});

/*
 *
 * TERMS OF USE - EASING EQUATIONS
 *
 * Open source under the BSD License.
 *
 * Copyright 2001 Robert Penner
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 *
 * Redistributions of source code must retain the above copyright notice, this list of
 * conditions and the following disclaimer.
 * Redistributions in binary form must reproduce the above copyright notice, this list
 * of conditions and the following disclaimer in the documentation and/or other materials
 * provided with the distribution.
 *
 * Neither the name of the author nor the names of contributors may be used to endorse
 * or promote products derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
 * GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
 * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

})(jQuery);
/*
 * jQuery UI Effects Blind 1.8.18
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Effects/Blind
 *
 * Depends:
 *	jquery.effects.core.js
 */
(function( $, undefined ) {

$.effects.blind = function(o) {

	return this.queue(function() {

		// Create element
		var el = $(this), props = [&#39;position&#39;,&#39;top&#39;,&#39;bottom&#39;,&#39;left&#39;,&#39;right&#39;];

		// Set options
		var mode = $.effects.setMode(el, o.options.mode || &#39;hide&#39;); // Set Mode
		var direction = o.options.direction || &#39;vertical&#39;; // Default direction

		// Adjust
		$.effects.save(el, props); el.show(); // Save &amp; Show
		var wrapper = $.effects.createWrapper(el).css({overflow:&#39;hidden&#39;}); // Create Wrapper
		var ref = (direction == &#39;vertical&#39;) ? &#39;height&#39; : &#39;width&#39;;
		var distance = (direction == &#39;vertical&#39;) ? wrapper.height() : wrapper.width();
		if(mode == &#39;show&#39;) wrapper.css(ref, 0); // Shift

		// Animation
		var animation = {};
		animation[ref] = mode == &#39;show&#39; ? distance : 0;

		// Animate
		wrapper.animate(animation, o.duration, o.options.easing, function() {
			if(mode == &#39;hide&#39;) el.hide(); // Hide
			$.effects.restore(el, props); $.effects.removeWrapper(el); // Restore
			if(o.callback) o.callback.apply(el[0], arguments); // Callback
			el.dequeue();
		});

	});

};

})(jQuery);
/*
 * jQuery UI Effects Bounce 1.8.18
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Effects/Bounce
 *
 * Depends:
 *	jquery.effects.core.js
 */
(function( $, undefined ) {

$.effects.bounce = function(o) {

	return this.queue(function() {

		// Create element
		var el = $(this), props = [&#39;position&#39;,&#39;top&#39;,&#39;bottom&#39;,&#39;left&#39;,&#39;right&#39;];

		// Set options
		var mode = $.effects.setMode(el, o.options.mode || &#39;effect&#39;); // Set Mode
		var direction = o.options.direction || &#39;up&#39;; // Default direction
		var distance = o.options.distance || 20; // Default distance
		var times = o.options.times || 5; // Default # of times
		var speed = o.duration || 250; // Default speed per bounce
		if (/show|hide/.test(mode)) props.push(&#39;opacity&#39;); // Avoid touching opacity to prevent clearType and PNG issues in IE

		// Adjust
		$.effects.save(el, props); el.show(); // Save &amp; Show
		$.effects.createWrapper(el); // Create Wrapper
		var ref = (direction == &#39;up&#39; || direction == &#39;down&#39;) ? &#39;top&#39; : &#39;left&#39;;
		var motion = (direction == &#39;up&#39; || direction == &#39;left&#39;) ? &#39;pos&#39; : &#39;neg&#39;;
		var distance = o.options.distance || (ref == &#39;top&#39; ? el.outerHeight({margin:true}) / 3 : el.outerWidth({margin:true}) / 3);
		if (mode == &#39;show&#39;) el.css(&#39;opacity&#39;, 0).css(ref, motion == &#39;pos&#39; ? -distance : distance); // Shift
		if (mode == &#39;hide&#39;) distance = distance / (times * 2);
		if (mode != &#39;hide&#39;) times--;

		// Animate
		if (mode == &#39;show&#39;) { // Show Bounce
			var animation = {opacity: 1};
			animation[ref] = (motion == &#39;pos&#39; ? &#39;+=&#39; : &#39;-=&#39;) + distance;
			el.animate(animation, speed / 2, o.options.easing);
			distance = distance / 2;
			times--;
		};
		for (var i = 0; i </span><span class="xd">&lt; </span><span class="xn">times</span><span class="xd">; i++) { // Bounces
			var animation1 = {}, animation2 = {};
			animation1[ref] = (motion == &#39;pos&#39; ? &#39;-=&#39; : &#39;+=&#39;) + distance;
			animation2[ref] = (motion == &#39;pos&#39; ? &#39;+=&#39; : &#39;-=&#39;) + distance;
			el.animate(animation1, speed / 2, o.options.easing).animate(animation2, speed / 2, o.options.easing);
			distance = (mode == &#39;hide&#39;) ? distance * 2 : distance / 2;
		};
		if (mode == &#39;hide&#39;) { // Last Bounce
			var animation = {opacity: 0};
			animation[ref] = (motion == &#39;pos&#39; ? &#39;-=&#39; : &#39;+=&#39;)  + distance;
			el.animate(animation, speed / 2, o.options.easing, function(){
				el.hide(); // Hide
				$.effects.restore(el, props); $.effects.removeWrapper(el); // Restore
				if(o.callback) o.callback.apply(this, arguments); // Callback
			});
		} else {
			var animation1 = {}, animation2 = {};
			animation1[ref] = (motion == &#39;pos&#39; ? &#39;-=&#39; : &#39;+=&#39;) + distance;
			animation2[ref] = (motion == &#39;pos&#39; ? &#39;+=&#39; : &#39;-=&#39;) + distance;
			el.animate(animation1, speed / 2, o.options.easing).animate(animation2, speed / 2, o.options.easing, function(){
				$.effects.restore(el, props); $.effects.removeWrapper(el); // Restore
				if(o.callback) o.callback.apply(this, arguments); // Callback
			});
		};
		el.queue(&#39;fx&#39;, function() { el.dequeue(); });
		el.dequeue();
	});

};

})(jQuery);
/*
 * jQuery UI Effects Clip 1.8.18
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Effects/Clip
 *
 * Depends:
 *	jquery.effects.core.js
 */
(function( $, undefined ) {

$.effects.clip = function(o) {

	return this.queue(function() {

		// Create element
		var el = $(this), props = [&#39;position&#39;,&#39;top&#39;,&#39;bottom&#39;,&#39;left&#39;,&#39;right&#39;,&#39;height&#39;,&#39;width&#39;];

		// Set options
		var mode = $.effects.setMode(el, o.options.mode || &#39;hide&#39;); // Set Mode
		var direction = o.options.direction || &#39;vertical&#39;; // Default direction

		// Adjust
		$.effects.save(el, props); el.show(); // Save &amp; Show
		var wrapper = $.effects.createWrapper(el).css({overflow:&#39;hidden&#39;}); // Create Wrapper
		var animate = el[0].tagName == &#39;IMG&#39; ? wrapper : el;
		var ref = {
			size: (direction == &#39;vertical&#39;) ? &#39;height&#39; : &#39;width&#39;,
			position: (direction == &#39;vertical&#39;) ? &#39;top&#39; : &#39;left&#39;
		};
		var distance = (direction == &#39;vertical&#39;) ? animate.height() : animate.width();
		if(mode == &#39;show&#39;) { animate.css(ref.size, 0); animate.css(ref.position, distance / 2); } // Shift

		// Animation
		var animation = {};
		animation[ref.size] = mode == &#39;show&#39; ? distance : 0;
		animation[ref.position] = mode == &#39;show&#39; ? 0 : distance / 2;

		// Animate
		animate.animate(animation, { queue: false, duration: o.duration, easing: o.options.easing, complete: function() {
			if(mode == &#39;hide&#39;) el.hide(); // Hide
			$.effects.restore(el, props); $.effects.removeWrapper(el); // Restore
			if(o.callback) o.callback.apply(el[0], arguments); // Callback
			el.dequeue();
		}});

	});

};

})(jQuery);
/*
 * jQuery UI Effects Drop 1.8.18
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Effects/Drop
 *
 * Depends:
 *	jquery.effects.core.js
 */
(function( $, undefined ) {

$.effects.drop = function(o) {

	return this.queue(function() {

		// Create element
		var el = $(this), props = [&#39;position&#39;,&#39;top&#39;,&#39;bottom&#39;,&#39;left&#39;,&#39;right&#39;,&#39;opacity&#39;];

		// Set options
		var mode = $.effects.setMode(el, o.options.mode || &#39;hide&#39;); // Set Mode
		var direction = o.options.direction || &#39;left&#39;; // Default Direction

		// Adjust
		$.effects.save(el, props); el.show(); // Save &amp; Show
		$.effects.createWrapper(el); // Create Wrapper
		var ref = (direction == &#39;up&#39; || direction == &#39;down&#39;) ? &#39;top&#39; : &#39;left&#39;;
		var motion = (direction == &#39;up&#39; || direction == &#39;left&#39;) ? &#39;pos&#39; : &#39;neg&#39;;
		var distance = o.options.distance || (ref == &#39;top&#39; ? el.outerHeight({margin:true}) / 2 : el.outerWidth({margin:true}) / 2);
		if (mode == &#39;show&#39;) el.css(&#39;opacity&#39;, 0).css(ref, motion == &#39;pos&#39; ? -distance : distance); // Shift

		// Animation
		var animation = {opacity: mode == &#39;show&#39; ? 1 : 0};
		animation[ref] = (mode == &#39;show&#39; ? (motion == &#39;pos&#39; ? &#39;+=&#39; : &#39;-=&#39;) : (motion == &#39;pos&#39; ? &#39;-=&#39; : &#39;+=&#39;)) + distance;

		// Animate
		el.animate(animation, { queue: false, duration: o.duration, easing: o.options.easing, complete: function() {
			if(mode == &#39;hide&#39;) el.hide(); // Hide
			$.effects.restore(el, props); $.effects.removeWrapper(el); // Restore
			if(o.callback) o.callback.apply(this, arguments); // Callback
			el.dequeue();
		}});

	});

};

})(jQuery);
/*
 * jQuery UI Effects Explode 1.8.18
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Effects/Explode
 *
 * Depends:
 *	jquery.effects.core.js
 */
(function( $, undefined ) {

$.effects.explode = function(o) {

	return this.queue(function() {

	var rows = o.options.pieces ? Math.round(Math.sqrt(o.options.pieces)) : 3;
	var cells = o.options.pieces ? Math.round(Math.sqrt(o.options.pieces)) : 3;

	o.options.mode = o.options.mode == &#39;toggle&#39; ? ($(this).is(&#39;:visible&#39;) ? &#39;hide&#39; : &#39;show&#39;) : o.options.mode;
	var el = $(this).show().css(&#39;visibility&#39;, &#39;hidden&#39;);
	var offset = el.offset();

	//Substract the margins - not fixing the problem yet.
	offset.top -= parseInt(el.css(&quot;marginTop&quot;),10) || 0;
	offset.left -= parseInt(el.css(&quot;marginLeft&quot;),10) || 0;

	var width = el.outerWidth(true);
	var height = el.outerHeight(true);

	for(var i=0;i</span><span class="xd">&lt;</span><span class="xn">rows</span><span class="xd">;i++) { // =
		for(var j=0;j</span><span class="xd">&lt;</span><span class="xn">cells</span><span class="xd">;j++) { // ||
			el
				.clone()
				.appendTo(&#39;body&#39;)
				.wrap(&#39;</span><span class="xd">&lt;</span><span class="xn">div</span><span class="xd">&gt;</span><span class="xd">&lt;/</span><span class="xn">div</span><span class="xd">&gt;</span>&#39;)
				.css({
					position: &#39;absolute&#39;,
					visibility: &#39;visible&#39;,
					left: -j*(width/cells),
					top: -i*(height/rows)
				})
				.parent()
				.addClass(&#39;ui-effects-explode&#39;)
				.css({
					position: &#39;absolute&#39;,
					overflow: &#39;hidden&#39;,
					width: width/cells,
					height: height/rows,
					left: offset.left + j*(width/cells) + (o.options.mode == &#39;show&#39; ? (j-Math.floor(cells/2))*(width/cells) : 0),
					top: offset.top + i*(height/rows) + (o.options.mode == &#39;show&#39; ? (i-Math.floor(rows/2))*(height/rows) : 0),
					opacity: o.options.mode == &#39;show&#39; ? 0 : 1
				}).animate({
					left: offset.left + j*(width/cells) + (o.options.mode == &#39;show&#39; ? 0 : (j-Math.floor(cells/2))*(width/cells)),
					top: offset.top + i*(height/rows) + (o.options.mode == &#39;show&#39; ? 0 : (i-Math.floor(rows/2))*(height/rows)),
					opacity: o.options.mode == &#39;show&#39; ? 1 : 0
				}, o.duration || 500);
		}
	}

	// Set a timeout, to call the callback approx. when the other animations have finished
	setTimeout(function() {

		o.options.mode == &#39;show&#39; ? el.css({ visibility: &#39;visible&#39; }) : el.css({ visibility: &#39;visible&#39; }).hide();
				if(o.callback) o.callback.apply(el[0]); // Callback
				el.dequeue();

				$(&#39;div.ui-effects-explode&#39;).remove();

	}, o.duration || 500);


	});

};

})(jQuery);
/*
 * jQuery UI Effects Fade 1.8.18
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Effects/Fade
 *
 * Depends:
 *	jquery.effects.core.js
 */
(function( $, undefined ) {

$.effects.fade = function(o) {
	return this.queue(function() {
		var elem = $(this),
			mode = $.effects.setMode(elem, o.options.mode || &#39;hide&#39;);

		elem.animate({ opacity: mode }, {
			queue: false,
			duration: o.duration,
			easing: o.options.easing,
			complete: function() {
				(o.callback <span class="xer">&amp;</span><span class="xer">&amp;</span> o.callback.apply(this, arguments));
				elem.dequeue();
			}
		});
	});
};

})(jQuery);
/*
 * jQuery UI Effects Fold 1.8.18
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Effects/Fold
 *
 * Depends:
 *	jquery.effects.core.js
 */
(function( $, undefined ) {

$.effects.fold = function(o) {

	return this.queue(function() {

		// Create element
		var el = $(this), props = [&#39;position&#39;,&#39;top&#39;,&#39;bottom&#39;,&#39;left&#39;,&#39;right&#39;];

		// Set options
		var mode = $.effects.setMode(el, o.options.mode || &#39;hide&#39;); // Set Mode
		var size = o.options.size || 15; // Default fold size
		var horizFirst = !(!o.options.horizFirst); // Ensure a boolean value
		var duration = o.duration ? o.duration / 2 : $.fx.speeds._default / 2;

		// Adjust
		$.effects.save(el, props); el.show(); // Save <span class="xer">&amp;</span> Show
		var wrapper = $.effects.createWrapper(el).css({overflow:&#39;hidden&#39;}); // Create Wrapper
		var widthFirst = ((mode == &#39;show&#39;) != horizFirst);
		var ref = widthFirst ? [&#39;width&#39;, &#39;height&#39;] : [&#39;height&#39;, &#39;width&#39;];
		var distance = widthFirst ? [wrapper.width(), wrapper.height()] : [wrapper.height(), wrapper.width()];
		var percent = /([0-9]+)%/.exec(size);
		if(percent) size = parseInt(percent[1],10) / 100 * distance[mode == &#39;hide&#39; ? 0 : 1];
		if(mode == &#39;show&#39;) wrapper.css(horizFirst ? {height: 0, width: size} : {height: size, width: 0}); // Shift

		// Animation
		var animation1 = {}, animation2 = {};
		animation1[ref[0]] = mode == &#39;show&#39; ? distance[0] : size;
		animation2[ref[1]] = mode == &#39;show&#39; ? distance[1] : 0;

		// Animate
		wrapper.animate(animation1, duration, o.options.easing)
		.animate(animation2, duration, o.options.easing, function() {
			if(mode == &#39;hide&#39;) el.hide(); // Hide
			$.effects.restore(el, props); $.effects.removeWrapper(el); // Restore
			if(o.callback) o.callback.apply(el[0], arguments); // Callback
			el.dequeue();
		});

	});

};

})(jQuery);
/*
 * jQuery UI Effects Highlight 1.8.18
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Effects/Highlight
 *
 * Depends:
 *	jquery.effects.core.js
 */
(function( $, undefined ) {

$.effects.highlight = function(o) {
	return this.queue(function() {
		var elem = $(this),
			props = [&#39;backgroundImage&#39;, &#39;backgroundColor&#39;, &#39;opacity&#39;],
			mode = $.effects.setMode(elem, o.options.mode || &#39;show&#39;),
			animation = {
				backgroundColor: elem.css(&#39;backgroundColor&#39;)
			};

		if (mode == &#39;hide&#39;) {
			animation.opacity = 0;
		}

		$.effects.save(elem, props);
		elem
			.show()
			.css({
				backgroundImage: &#39;none&#39;,
				backgroundColor: o.options.color || &#39;#ffff99&#39;
			})
			.animate(animation, {
				queue: false,
				duration: o.duration,
				easing: o.options.easing,
				complete: function() {
					(mode == &#39;hide&#39; <span class="xer">&amp;</span><span class="xer">&amp;</span> elem.hide());
					$.effects.restore(elem, props);
					(mode == &#39;show&#39; <span class="xer">&amp;</span><span class="xer">&amp;</span> !$.support.opacity <span class="xer">&amp;</span><span class="xer">&amp;</span> this.style.removeAttribute(&#39;filter&#39;));
					(o.callback <span class="xer">&amp;</span><span class="xer">&amp;</span> o.callback.apply(this, arguments));
					elem.dequeue();
				}
			});
	});
};

})(jQuery);
/*
 * jQuery UI Effects Pulsate 1.8.18
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Effects/Pulsate
 *
 * Depends:
 *	jquery.effects.core.js
 */
(function( $, undefined ) {

$.effects.pulsate = function(o) {
	return this.queue(function() {
		var elem = $(this),
			mode = $.effects.setMode(elem, o.options.mode || &#39;show&#39;);
			times = ((o.options.times || 5) * 2) - 1;
			duration = o.duration ? o.duration / 2 : $.fx.speeds._default / 2,
			isVisible = elem.is(&#39;:visible&#39;),
			animateTo = 0;

		if (!isVisible) {
			elem.css(&#39;opacity&#39;, 0).show();
			animateTo = 1;
		}

		if ((mode == &#39;hide&#39; <span class="xer">&amp;</span><span class="xer">&amp;</span> isVisible) || (mode == &#39;show&#39; <span class="xer">&amp;</span><span class="xer">&amp;</span> !isVisible)) {
			times--;
		}

		for (var i = 0; i <span class="xd">&lt; </span><span class="xn">times</span><span class="xd">; i++) {
			elem.animate({ opacity: animateTo }, duration, o.options.easing);
			animateTo = (animateTo + 1) % 2;
		}

		elem.animate({ opacity: animateTo }, duration, o.options.easing, function() {
			if (animateTo == 0) {
				elem.hide();
			}
			(o.callback &amp;&amp; o.callback.apply(this, arguments));
		});

		elem
			.queue(&#39;fx&#39;, function() { elem.dequeue(); })
			.dequeue();
	});
};

})(jQuery);
/*
 * jQuery UI Effects Scale 1.8.18
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Effects/Scale
 *
 * Depends:
 *	jquery.effects.core.js
 */
(function( $, undefined ) {

$.effects.puff = function(o) {
	return this.queue(function() {
		var elem = $(this),
			mode = $.effects.setMode(elem, o.options.mode || &#39;hide&#39;),
			percent = parseInt(o.options.percent, 10) || 150,
			factor = percent / 100,
			original = { height: elem.height(), width: elem.width() };

		$.extend(o.options, {
			fade: true,
			mode: mode,
			percent: mode == &#39;hide&#39; ? percent : 100,
			from: mode == &#39;hide&#39;
				? original
				: {
					height: original.height * factor,
					width: original.width * factor
				}
		});

		elem.effect(&#39;scale&#39;, o.options, o.duration, o.callback);
		elem.dequeue();
	});
};

$.effects.scale = function(o) {

	return this.queue(function() {

		// Create element
		var el = $(this);

		// Set options
		var options = $.extend(true, {}, o.options);
		var mode = $.effects.setMode(el, o.options.mode || &#39;effect&#39;); // Set Mode
		var percent = parseInt(o.options.percent,10) || (parseInt(o.options.percent,10) == 0 ? 0 : (mode == &#39;hide&#39; ? 0 : 100)); // Set default scaling percent
		var direction = o.options.direction || &#39;both&#39;; // Set default axis
		var origin = o.options.origin; // The origin of the scaling
		if (mode != &#39;effect&#39;) { // Set default origin and restore for show/hide
			options.origin = origin || [&#39;middle&#39;,&#39;center&#39;];
			options.restore = true;
		}
		var original = {height: el.height(), width: el.width()}; // Save original
		el.from = o.options.from || (mode == &#39;show&#39; ? {height: 0, width: 0} : original); // Default from state

		// Adjust
		var factor = { // Set scaling factor
			y: direction != &#39;horizontal&#39; ? (percent / 100) : 1,
			x: direction != &#39;vertical&#39; ? (percent / 100) : 1
		};
		el.to = {height: original.height * factor.y, width: original.width * factor.x}; // Set to state

		if (o.options.fade) { // Fade option to support puff
			if (mode == &#39;show&#39;) {el.from.opacity = 0; el.to.opacity = 1;};
			if (mode == &#39;hide&#39;) {el.from.opacity = 1; el.to.opacity = 0;};
		};

		// Animation
		options.from = el.from; options.to = el.to; options.mode = mode;

		// Animate
		el.effect(&#39;size&#39;, options, o.duration, o.callback);
		el.dequeue();
	});

};

$.effects.size = function(o) {

	return this.queue(function() {

		// Create element
		var el = $(this), props = [&#39;position&#39;,&#39;top&#39;,&#39;bottom&#39;,&#39;left&#39;,&#39;right&#39;,&#39;width&#39;,&#39;height&#39;,&#39;overflow&#39;,&#39;opacity&#39;];
		var props1 = [&#39;position&#39;,&#39;top&#39;,&#39;bottom&#39;,&#39;left&#39;,&#39;right&#39;,&#39;overflow&#39;,&#39;opacity&#39;]; // Always restore
		var props2 = [&#39;width&#39;,&#39;height&#39;,&#39;overflow&#39;]; // Copy for children
		var cProps = [&#39;fontSize&#39;];
		var vProps = [&#39;borderTopWidth&#39;, &#39;borderBottomWidth&#39;, &#39;paddingTop&#39;, &#39;paddingBottom&#39;];
		var hProps = [&#39;borderLeftWidth&#39;, &#39;borderRightWidth&#39;, &#39;paddingLeft&#39;, &#39;paddingRight&#39;];

		// Set options
		var mode = $.effects.setMode(el, o.options.mode || &#39;effect&#39;); // Set Mode
		var restore = o.options.restore || false; // Default restore
		var scale = o.options.scale || &#39;both&#39;; // Default scale mode
		var origin = o.options.origin; // The origin of the sizing
		var original = {height: el.height(), width: el.width()}; // Save original
		el.from = o.options.from || original; // Default from state
		el.to = o.options.to || original; // Default to state
		// Adjust
		if (origin) { // Calculate baseline shifts
			var baseline = $.effects.getBaseline(origin, original);
			el.from.top = (original.height - el.from.height) * baseline.y;
			el.from.left = (original.width - el.from.width) * baseline.x;
			el.to.top = (original.height - el.to.height) * baseline.y;
			el.to.left = (original.width - el.to.width) * baseline.x;
		};
		var factor = { // Set scaling factor
			from: {y: el.from.height / original.height, x: el.from.width / original.width},
			to: {y: el.to.height / original.height, x: el.to.width / original.width}
		};
		if (scale == &#39;box&#39; || scale == &#39;both&#39;) { // Scale the css box
			if (factor.from.y != factor.to.y) { // Vertical props scaling
				props = props.concat(vProps);
				el.from = $.effects.setTransition(el, vProps, factor.from.y, el.from);
				el.to = $.effects.setTransition(el, vProps, factor.to.y, el.to);
			};
			if (factor.from.x != factor.to.x) { // Horizontal props scaling
				props = props.concat(hProps);
				el.from = $.effects.setTransition(el, hProps, factor.from.x, el.from);
				el.to = $.effects.setTransition(el, hProps, factor.to.x, el.to);
			};
		};
		if (scale == &#39;content&#39; || scale == &#39;both&#39;) { // Scale the content
			if (factor.from.y != factor.to.y) { // Vertical props scaling
				props = props.concat(cProps);
				el.from = $.effects.setTransition(el, cProps, factor.from.y, el.from);
				el.to = $.effects.setTransition(el, cProps, factor.to.y, el.to);
			};
		};
		$.effects.save(el, restore ? props : props1); el.show(); // Save &amp; Show
		$.effects.createWrapper(el); // Create Wrapper
		el.css(&#39;overflow&#39;,&#39;hidden&#39;).css(el.from); // Shift

		// Animate
		if (scale == &#39;content&#39; || scale == &#39;both&#39;) { // Scale the children
			vProps = vProps.concat([&#39;marginTop&#39;,&#39;marginBottom&#39;]).concat(cProps); // Add margins/font-size
			hProps = hProps.concat([&#39;marginLeft&#39;,&#39;marginRight&#39;]); // Add margins
			props2 = props.concat(vProps).concat(hProps); // Concat
			el.find(&quot;*[width]&quot;).each(function(){
				child = $(this);
				if (restore) $.effects.save(child, props2);
				var c_original = {height: child.height(), width: child.width()}; // Save original
				child.from = {height: c_original.height * factor.from.y, width: c_original.width * factor.from.x};
				child.to = {height: c_original.height * factor.to.y, width: c_original.width * factor.to.x};
				if (factor.from.y != factor.to.y) { // Vertical props scaling
					child.from = $.effects.setTransition(child, vProps, factor.from.y, child.from);
					child.to = $.effects.setTransition(child, vProps, factor.to.y, child.to);
				};
				if (factor.from.x != factor.to.x) { // Horizontal props scaling
					child.from = $.effects.setTransition(child, hProps, factor.from.x, child.from);
					child.to = $.effects.setTransition(child, hProps, factor.to.x, child.to);
				};
				child.css(child.from); // Shift children
				child.animate(child.to, o.duration, o.options.easing, function(){
					if (restore) $.effects.restore(child, props2); // Restore children
				}); // Animate children
			});
		};

		// Animate
		el.animate(el.to, { queue: false, duration: o.duration, easing: o.options.easing, complete: function() {
			if (el.to.opacity === 0) {
				el.css(&#39;opacity&#39;, el.from.opacity);
			}
			if(mode == &#39;hide&#39;) el.hide(); // Hide
			$.effects.restore(el, restore ? props : props1); $.effects.removeWrapper(el); // Restore
			if(o.callback) o.callback.apply(this, arguments); // Callback
			el.dequeue();
		}});

	});

};

})(jQuery);
/*
 * jQuery UI Effects Shake 1.8.18
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Effects/Shake
 *
 * Depends:
 *	jquery.effects.core.js
 */
(function( $, undefined ) {

$.effects.shake = function(o) {

	return this.queue(function() {

		// Create element
		var el = $(this), props = [&#39;position&#39;,&#39;top&#39;,&#39;bottom&#39;,&#39;left&#39;,&#39;right&#39;];

		// Set options
		var mode = $.effects.setMode(el, o.options.mode || &#39;effect&#39;); // Set Mode
		var direction = o.options.direction || &#39;left&#39;; // Default direction
		var distance = o.options.distance || 20; // Default distance
		var times = o.options.times || 3; // Default # of times
		var speed = o.duration || o.options.duration || 140; // Default speed per shake

		// Adjust
		$.effects.save(el, props); el.show(); // Save &amp; Show
		$.effects.createWrapper(el); // Create Wrapper
		var ref = (direction == &#39;up&#39; || direction == &#39;down&#39;) ? &#39;top&#39; : &#39;left&#39;;
		var motion = (direction == &#39;up&#39; || direction == &#39;left&#39;) ? &#39;pos&#39; : &#39;neg&#39;;

		// Animation
		var animation = {}, animation1 = {}, animation2 = {};
		animation[ref] = (motion == &#39;pos&#39; ? &#39;-=&#39; : &#39;+=&#39;)  + distance;
		animation1[ref] = (motion == &#39;pos&#39; ? &#39;+=&#39; : &#39;-=&#39;)  + distance * 2;
		animation2[ref] = (motion == &#39;pos&#39; ? &#39;-=&#39; : &#39;+=&#39;)  + distance * 2;

		// Animate
		el.animate(animation, speed, o.options.easing);
		for (var i = 1; i </span><span class="xd">&lt; </span><span class="xn">times</span><span class="xd">; i++) { // Shakes
			el.animate(animation1, speed, o.options.easing).animate(animation2, speed, o.options.easing);
		};
		el.animate(animation1, speed, o.options.easing).
		animate(animation, speed / 2, o.options.easing, function(){ // Last shake
			$.effects.restore(el, props); $.effects.removeWrapper(el); // Restore
			if(o.callback) o.callback.apply(this, arguments); // Callback
		});
		el.queue(&#39;fx&#39;, function() { el.dequeue(); });
		el.dequeue();
	});

};

})(jQuery);
/*
 * jQuery UI Effects Slide 1.8.18
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Effects/Slide
 *
 * Depends:
 *	jquery.effects.core.js
 */
(function( $, undefined ) {

$.effects.slide = function(o) {

	return this.queue(function() {

		// Create element
		var el = $(this), props = [&#39;position&#39;,&#39;top&#39;,&#39;bottom&#39;,&#39;left&#39;,&#39;right&#39;];

		// Set options
		var mode = $.effects.setMode(el, o.options.mode || &#39;show&#39;); // Set Mode
		var direction = o.options.direction || &#39;left&#39;; // Default Direction

		// Adjust
		$.effects.save(el, props); el.show(); // Save &amp; Show
		$.effects.createWrapper(el).css({overflow:&#39;hidden&#39;}); // Create Wrapper
		var ref = (direction == &#39;up&#39; || direction == &#39;down&#39;) ? &#39;top&#39; : &#39;left&#39;;
		var motion = (direction == &#39;up&#39; || direction == &#39;left&#39;) ? &#39;pos&#39; : &#39;neg&#39;;
		var distance = o.options.distance || (ref == &#39;top&#39; ? el.outerHeight({margin:true}) : el.outerWidth({margin:true}));
		if (mode == &#39;show&#39;) el.css(ref, motion == &#39;pos&#39; ? (isNaN(distance) ? &quot;-&quot; + distance : -distance) : distance); // Shift

		// Animation
		var animation = {};
		animation[ref] = (mode == &#39;show&#39; ? (motion == &#39;pos&#39; ? &#39;+=&#39; : &#39;-=&#39;) : (motion == &#39;pos&#39; ? &#39;-=&#39; : &#39;+=&#39;)) + distance;

		// Animate
		el.animate(animation, { queue: false, duration: o.duration, easing: o.options.easing, complete: function() {
			if(mode == &#39;hide&#39;) el.hide(); // Hide
			$.effects.restore(el, props); $.effects.removeWrapper(el); // Restore
			if(o.callback) o.callback.apply(this, arguments); // Callback
			el.dequeue();
		}});

	});

};

})(jQuery);
/*
 * jQuery UI Effects Transfer 1.8.18
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Effects/Transfer
 *
 * Depends:
 *	jquery.effects.core.js
 */
(function( $, undefined ) {

$.effects.transfer = function(o) {
	return this.queue(function() {
		var elem = $(this),
			target = $(o.options.to),
			endPosition = target.offset(),
			animation = {
				top: endPosition.top,
				left: endPosition.left,
				height: target.innerHeight(),
				width: target.innerWidth()
			},
			startPosition = elem.offset(),
			transfer = $(&#39;</span><span class="xd">&lt;</span><span class="xn">div </span><span class="xan">class</span><span class="xd">=</span>&quot;<span class="xav">ui-effects-transfer</span>&quot;<span class="xd">&gt;</span><span class="xd">&lt;/</span><span class="xn">div</span><span class="xd">&gt;</span>&#39;)
				.appendTo(document.body)
				.addClass(o.options.className)
				.css({
					top: startPosition.top,
					left: startPosition.left,
					height: elem.innerHeight(),
					width: elem.innerWidth(),
					position: &#39;absolute&#39;
				})
				.animate(animation, o.duration, o.options.easing, function() {
					transfer.remove();
					(o.callback <span class="xer">&amp;</span><span class="xer">&amp;</span> o.callback.apply(elem[0], arguments));
					elem.dequeue();
				});
	});
};

})(jQuery);
</pre></td></tr></table></div></body></html>
